/************************************************************************
 *  File: pcie_diag.c
 *
 *  Sample user-mode diagnostics application for accessing JSEB2
 *  devices using WinDriver's API.
 *  Code was generated by DriverWizard v10.21.
 *
 *  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
 *************************************************************************/

#define _POSIX_C_SOURCE 199309L
#define _XOPEN_SOURCE 600

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#include "diag_lib.h"
#include "pci_regs.h"
#include "status_strings.h"
#include "utils.h"
#include "wdc_defs.h"
#include "wdc_diag_lib.h"
#include "wdc_lib.h"

#include "include/jseb2_lib.h"
#include "include/sphenix.h"

#define JSEB2_ERR printf

static CHAR gsInput[256];

static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* main function */
static void ll1_trigger_test(WDC_DEVICE_HANDLE hDev);

#define _DMA_SEND 0
#define _DMA_REC  1

struct wd_dma_buffer_t {
    UINT32* buffer;
    WD_DMA* pDMA;
};

struct pcie_interface_t {
    WDC_DEVICE_HANDLE dev;
    struct wd_dma_buffer_t send;
    struct wd_dma_buffer_t rec;
};

/* pcie data transfer */
static int pcie_init(struct pcie_interface_t* pcie);
static int pcie_send(struct pcie_interface_t* pcie, int mode, int nword);
static int pcie_rec(struct pcie_interface_t* pcie, int state, int nword, UINT32 *buffer);

/* helper functions */
static void ll1_setup(struct pcie_interface_t* pcie, int addr_mod, int fifo_delay, int sync_step, int opt_mask, int thr, int nsample, int delay);
static void adc_setup(struct pcie_interface_t* pcie, int addr_mod);
static void adc_load_testram(struct pcie_interface_t* pcie, int addr_mod, int delay, UINT64 cmask, UINT32* data, int silent);
static void adc_load_lookup_tables(struct pcie_interface_t* pcie, int addr_mod, UINT32* l1_adc_table, UINT32* l1_slewing_table);

/* enumeration for pcie_send mode */
#define _M_WORD 0
#define _M_DMA  1

/* enumeration for pcie_rec state */
#define _S_INIT 0
#define _S_READ 1

/* format adc command */
#define _SP_ADC_CMD(mod, chip, cmd) \
    ((mod) << 11) + ((chip) << 8) + ((cmd) << 0)

#define _SP_ADC_CMD_FMT(mod, chip, cmd, data) \
    ((mod) << 11) + ((chip) << 8) + ((cmd) << 0) + ((data) << 16)

/* format ll1 command */
#define _SP_LL1_CMD(mod, chip, cmd) \
    ((mod) << 10) + ((chip) << 8) + ((cmd) << 0)

#define _SP_LL1_CMD_FMT(mod, chip, cmd, data) \
    ((mod) << 10) + ((chip) << 8) + ((cmd) << 0) + ((data) << 16)

/* FIXME: original comment for sp_adc_spi_data command: */
/* 1st next word will be overwritten by the next next word */

/* formats next data word (uint32_t) for sp_adc_spi_data command. argument
 * names are reasonable guesses; last two arguments are always 0. original
 * accompanying comment: */
/* set /w=0, w1,w2=0, a12-a0=cmd, data=data; */
#define _SP_ADC_SPI_FMT(cmd, data, _0, _1) \
    ((cmd) + ((_0) << 13) + ((_1) << 16) + ((data) << 24))

/* formats data buffer in the format: [ data word ] */
static void pack_int16(UINT32* buffer, UINT32 word, UINT32 data) {
    buffer[0] = (word) + (data << 16);
}

/* formats data buffers of packed 16-bit data from a 32-bit array */
/* ignores first element of buffer and packs the rest in the format:
 * [ * * ] [ 2 1 ] [ 4 3 ] ... */
static void pack_array(UINT32* buffer, UINT32 word, UINT32* data, int size) {
    int i;

    buffer[0] = (word) + (data[0] << 16);

    for (i=0; i<(size-1)/2; ++i) {
        buffer[i+1] = (data[(i*2)+1]) + (data[(i+1)*2] << 16);
    }

    if ((i+1)*2 == size) {
        buffer[i+1] = (data[size-1]);
    }
}

/* enumeration for data order */
#define _U_BE 0x10
#define _U_LE 0x00

/* unpacks data buffers of packed 16-bit data from a 32-bit array */
/* each 16-bit word is stored as a 32-bit element in the output array (data) */
static void unpack_array(UINT32* buffer, UINT32* data, int size, int shift) {
    int i;

    for (i=0; i<size; ++i, shift^=0x10) {
        data[i] = (buffer[i/2] >> shift) & 0xffff;
    }
}

static void _sp_adc_cmd_int16(struct pcie_interface_t* pcie, int mod, int chip, int cmd, UINT32 data) {
    pack_int16(pcie->send.buffer, _SP_ADC_CMD(mod, chip, cmd), data);
    pcie_send(pcie, _M_DMA, 1);
    /* usleep(10); */
    usleep(1);
}

static void _sp_adc_cmd_array(struct pcie_interface_t* pcie, int mod, int chip, int cmd, UINT32* data, int size) {
    pack_array(pcie->send.buffer, _SP_ADC_CMD(mod, chip, cmd), data, size);
    pcie_send(pcie, _M_DMA, size / 2 + 1);
    usleep(1000);
}

static void _sp_ll1_cmd_int16(struct pcie_interface_t* pcie, int mod, int chip, int cmd, UINT32 data) {
    pack_int16(pcie->send.buffer, _SP_LL1_CMD(mod, chip, cmd), data);
    pcie_send(pcie, _M_DMA, 1);
    usleep(10);
}

/* data structure for adc mbd output */
struct sp_adc_mbd_t {
    int charge[8], nhit, time[4];
};

/* enumeration for ll1 directions */
#define _MBD_RIGHT  0
#define _MBD_LEFT   1

/* data structure for ll1 mbd algorithm output */
struct sp_ll1_mbd_t {
    int tsum[2];
    int nhit[2];
    int tavg[2];
    int trem[2];
    int vtxs;
    int vtxd;
};

/* simulation of adc data processing */
static void calculate_mbd_adc_output(struct sp_adc_mbd_t* output, UINT64 cmask, UINT32* input, UINT32* l1_adc_table, UINT32* l1_slewing_table) {
    int i;

    UINT32 tmp;
    UINT32 qadd[32];

    memset(output, 0, sizeof(struct sp_adc_mbd_t));

    /* charge channels */
    for (i=0; i<32; ++i) {
        tmp = l1_adc_table[input[i + 32] >> 4];

        qadd[i] = (tmp & 0x0380) >> 7;

        output->charge[i/4] += tmp & 0x7f;
    }

    /* time channels */
    for (i=0; i<32; ++i) {
        tmp = l1_adc_table[input[i] >> 4];

        output->nhit += (tmp & 0x0200) >> 9;

        tmp = l1_slewing_table[(qadd[i] << 9) + (tmp & 0x01ff)];

        output->time[i/8] += tmp;
    }
}

/* simulation of ll1 mbd algorithm */
static void simulate_ll1_mbd_algorithm(struct sp_adc_mbd_t input[4], struct sp_ll1_mbd_t* output) {
    int i, j;

    memset(output, 0, sizeof(struct sp_ll1_mbd_t));

    for (i=0; i<2; ++i) {
        for (j=0; j<4; ++j) {
            output->tsum[0] += input[i+0].time[j];
            output->tsum[1] += input[i+2].time[j];
        }

        output->nhit[0] += input[i+0].nhit;
        output->nhit[1] += input[i+2].nhit;
    }

    for (i=0; i<2; ++i) {
        output->tavg[i] = output->tsum[i] / output->nhit[i];
        output->trem[i] = output->tsum[i] % output->nhit[i];
    }

    output->vtxs = (output->tavg[0] - output->tavg[1]) & 0x01ff;
    output->vtxd = (output->tavg[0] + output->tavg[1]) & 0x03ff;
}

/* fill data structure with data from valid beam crossing */
int fill_adc_output_data(struct sp_adc_mbd_t adc[4], int adc_data[64][40], int trig_nsample) {
    int i, j, k;

    int itmp, jtmp;

    for (i=0; i<trig_nsample; ++i) {
        itmp = 0xffffffff;

        for (j=0; j<4; ++j) {
            jtmp = 0x00000000;

            for (k=0; k<8; ++k) {
                jtmp |= adc_data[j*8+k][i];
            }

            itmp &= jtmp;
        }

        if (itmp) { break; }
    }

    if (i == trig_nsample)
        return -1;

    for (j=0; j<4; j++) {
        adc[j].charge[0] = ((adc_data[j*8+0][i] & 0x01ff));                                              //8-0
        adc[j].charge[1] = ((adc_data[j*8+0][i] & 0xfe00) >>  9) + ((adc_data[j*8+1][i] & 0x0003) << 7); //17-9
        adc[j].charge[2] = ((adc_data[j*8+1][i] & 0x07fc) >>  2);                                        //26-18
        adc[j].charge[3] = ((adc_data[j*8+1][i] & 0xf800) >> 11) + ((adc_data[j*8+2][i] & 0x000f) << 5); //35-27
        adc[j].charge[4] = ((adc_data[j*8+2][i] & 0x1ff0) >>  4);                                        //44-36
        adc[j].charge[5] = ((adc_data[j*8+2][i] & 0xe000) >> 13) + ((adc_data[j*8+3][i] & 0x003f) << 3); //53-45
        adc[j].charge[6] = ((adc_data[j*8+3][i] & 0x7fc0) >>  6);                                        //62-54
        adc[j].charge[7] = ((adc_data[j*8+3][i] & 0x8000) >> 15) + ((adc_data[j*8+4][i] & 0x00ff) << 1); //71-63
        adc[j].nhit      = ((adc_data[j*8+4][i] & 0xff00) >>  8);                                        //79-72
        adc[j].time[0]   = ((adc_data[j*8+5][i] & 0x0fff));                                              //91-80
        adc[j].time[1]   = ((adc_data[j*8+5][i] & 0xf000) >> 12) + ((adc_data[j*8+6][i] & 0x00ff) << 4); //103-92
        adc[j].time[2]   = ((adc_data[j*8+6][i] & 0xff00) >>  8) + ((adc_data[j*8+7][i] & 0x000f) << 8); //115-104
        adc[j].time[3]   = ((adc_data[j*8+7][i] & 0xfff0) >>  4);                                        //127-116
    }

    return i;
}

/* display data array in columnar format */
static void fprint_data_array(FILE* f, UINT32* data, int size, int col, int width) {
    int i;

    for (i=0; i<size; ++i) {
        if (i % col == 0) fprintf(f, " %4x", i);
        fprintf(f, " %*x", width, data[i]);
        if (i % col == col - 1) fprintf(f, "\n");
    }
    if (i % col != 0) fprintf(f, "\n");
}

/* main function */
int main(int argc, char* argv[])
{
    if (argc != 1) {
        printf("usage: %s\n", argv[0]);
        return 1;
    }
    printf("test");

    WDC_DEVICE_HANDLE hDev;

    DWORD dwStatus;

    hDev = NULL;

    printf("\n");
    printf("JSEB2 diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the JSEB2 library */
    dwStatus = JSEB2_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("pcie_diag: Failed to initialize the JSEB2 library: %s",
                JSEB2_GetLastErr());
        return dwStatus;
    }

    /* Find and open a JSEB2 device (by default ID) */
    if (JSEB2_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(JSEB2_DEFAULT_VENDOR_ID, JSEB2_DEFAULT_DEVICE_ID);

    ll1_trigger_test(hDev);

    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);

    dwStatus = JSEB2_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        JSEB2_ERR("pcie_diag: Failed to uninit the JSEB2 library: %s", JSEB2_GetLastErr());

    return dwStatus;
}

/* Find and open a JSEB2 device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
    WD_PCI_SLOT slot;

    if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
        return NULL;

    return DeviceOpen(&slot);
}

/* Find a JSEB2 device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if (dwVendorId == 0)
    {
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
                    "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
                    "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("DeviceFind: Failed scanning the PCI bus.\n"
                "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        JSEB2_ERR("No matching device was found for search criteria "
                "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
                dwVendorId, dwDeviceId);

        return FALSE;
    }

    printf("\n");
    printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
            dwNumDevices, dwNumDevices > 1 ? "s" : "",
            dwVendorId, dwVendorId ? "" : " (ALL)",
            dwDeviceId, dwDeviceId ? "" : " (ALL)");

    for (i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
                i + 1,
                scanResult.deviceId[i].dwVendorId,
                scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
    printf("\n");

    if (dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i,
                    gsInput, FALSE, 1, dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

/* Open a handle to a JSEB2 device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;

    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
                "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = JSEB2_DeviceOpen(&deviceInfo);
    if (!hDev)
    {
        JSEB2_ERR("DeviceOpen: Failed opening a handle to the device: %s",
                JSEB2_GetLastErr());
        return NULL;
    }

    return hDev;
}

/* Close handle to a JSEB2 device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if (!hDev)
        return;

    if (!JSEB2_DeviceClose(hDev))
    {
        JSEB2_ERR("DeviceClose: Failed closing JSEB2 device: %s",
                JSEB2_GetLastErr());
    }
}

static void ll1_trigger_test(WDC_DEVICE_HANDLE hDev)
{
    int addr_mod, chip;

    UINT32 buf_rec[40000], tmp[40000];

    int i,k,ic,ie,im,is,iw;

    int log, interactive, silent, debug;
    FILE *outf;

    int nevent, nsample, nword;
    int mod_start, mod_count;
    int mod_ll1, chip_ll1, addr_ll1;
    int trig_fifo_delay, trig_sync_step, trig_opt_mask, trig_thr;
    int trig_nsample, trig_delay;

    UINT64 cmask;
    UINT32 data[64];

    struct sp_adc_mbd_t ref;

    UINT32 l1_slewing_table[4096], l1_adc_table[1024];

    int parity;
    int count;

    int adc_data[64][40];
    int trig_charge[4][8][40], trig_nhit[4][40], trig_time[4][8][40];
    int mbd_right_tavg[40], mbd_left_tavg[40], mbd_right_nhit[40], mbd_left_nhit[40];
    int mbd_right_remain[40], mbd_left_remain[40], mbd_vertex_sub[40], mbd_vertex_add[40];

    struct sp_adc_mbd_t adc[4];
    struct sp_ll1_mbd_t ll1;

    char buffer[256];

    srand(time(NULL));

    log = 0;
    interactive = 0;
    silent = 0;
    debug = 0;

    count = 0;

    if (interactive == 1) {
        printf(" [input] number of events\n");
        scanf("%d", &nevent);
        printf(" [input] 1st FEM module slot number\n");
        scanf("%d", &mod_start);
        printf(" [input] number of FEM module\n");
        scanf("%d", &mod_count);
        printf(" [input] trigger module address\n");
        scanf("%d", &mod_ll1);
        printf(" [input] enter 0 for lower chip and 1 for upper chip\n");
        scanf("%d", &chip_ll1);
    } else {
        nevent = 100000;
        mod_start = 6;
        mod_count = 4;
        mod_ll1 = 18;
        chip_ll1 = 0;
    }

    nsample = 24;

    trig_fifo_delay = 100;
    trig_sync_step = 15;
    trig_opt_mask = 0;
    trig_thr = 30;
    trig_nsample = 30;
    trig_delay = 20;

    if (log == 0) {
        outf = stdout;
    } else {
        snprintf(buffer, 255, "/home/grape/jseb/sPHENIXJSEB/logs/tmp.log");
        outf = fopen(buffer, "w");
    }

    struct pcie_interface_t pcie;

    pcie.dev = hDev;

    if (pcie_init(&pcie)) {
        printf(" failed to initialise pcie\n");
        return;
    }

    pcie.send.buffer[0] = 0x0;
    pcie_send(&pcie, _M_DMA, 1);

    /* enable offline run on */
    _sp_adc_cmd_int16(&pcie, 0, 0, sp_cntrl_offline, 0x1);

    /* send init to the controller */
    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_init);
    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_init);

    printf(" [input] type 1 to continue\n");
    scanf("%d", &i);

    /* send reset to the controller */
    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_reset);
    usleep(1000);

    printf(" call ll1 setup\n");

    /* take care to shift module address */
    addr_ll1 = (mod_ll1 << 1) + chip_ll1;
    ll1_setup(&pcie, addr_ll1, trig_fifo_delay, trig_sync_step, trig_opt_mask, trig_thr, trig_nsample, trig_delay);

    /* set adc test data */
    cmask = 0xffffffffffffffffULL;

    for (ic=0; ic<64; ++ic) {
        /* data[ic] = (rand() & 0x3ff) << 4; */
        data[ic] = 0x2f2e;
    }

    /* set adc lookup tables */
    for (i=0; i<1024; i++) {
        l1_adc_table[i] = (i) & 0x3ff;
    }

    for (i=0; i<4096; i++) {
        l1_slewing_table[i] = (i) & 0x1ff;
    }

    /* setup adc modules */
    for (im=0; im<mod_count; im++) {
        addr_mod = im + mod_start;
        chip = sp_adc_slowcntl_sub;

        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_evt_sample, nsample - 1);
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_l1_delay, 0x10);
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_rd_link, 0x0);
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_rd_cntrl, 0x1);
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_sel_pulse, 0x0);
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_sel_caltrig, 0x0);

        printf(" module %2d : set test ram state\n", addr_mod);
        usleep(400000);

        /* set data to 0x0 if not loading test data */
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_test_pulse, 0x1);

        /* set select L1 trigger on */
        printf(" module %2d : select L1 trigger\n", addr_mod);
        usleep(400000);

        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_sel_l1, 0x1);

        printf(" module %2d : call adc setup\n", addr_mod);
        usleep(400000);

        adc_setup(&pcie, addr_mod);

        printf(" module %2d : load adc testram and lookup tables\n", addr_mod);
        usleep(400000);

        adc_load_testram(&pcie, addr_mod, /* delay */ 400, cmask, data, silent);
        adc_load_lookup_tables(&pcie, addr_mod, l1_adc_table, l1_slewing_table);

        printf(" ---------------------------------\n");
    }

    /* calculate expected adc output */
    calculate_mbd_adc_output(&ref, cmask, data, l1_adc_table, l1_slewing_table);

    usleep(400000);

    /* reset system again... */

    /* send init to the controller */
    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_init);
    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_init);

    /* send reset to the controller */
    if (interactive == 1) {
        printf(" [input] type 1 to send reset\n");
        scanf("%d", &i);
    } else {
        usleep(400000);
    }

    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_reset);
    usleep(1000);

    /* readout status */
    if (interactive == 1) {
        printf(" [input] send l1 trigger status read command\n");
        scanf("%d", &i);
    } else {
        usleep(400000);
    }

    _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_o_read, 0x0);

    pcie_rec(&pcie, _S_INIT, 2, buf_rec);
    usleep(10);

    _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_o_read, 0x0);

    pcie_rec(&pcie, _S_READ, 2, buf_rec);
    usleep(10);

    if (!silent) {
        fprintf(outf, " module number %d, chip %d\n", ((buf_rec[0] >> 9) & 0x1f), ((buf_rec[0] >> 8) & 0x1));
        fprintf(outf, " optical cable locked status = %06x\n", ((buf_rec[0] & 0xff) + ((buf_rec[0] >> 8) & 0xffff00)));
        fprintf(outf, " PLL lock status %d\n", ((buf_rec[1] >> 8) & 0x1));
        fprintf(outf, "\n");
    }

    /* readout header */
    if (interactive == 1) {
        printf(" [input] send l1 trigger header read command\n");
        scanf("%d", &i);
    } else {
        usleep(400000);
    }

    pcie_rec(&pcie, _S_INIT, 14, buf_rec);
    usleep(10);

    _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_h_read, 0x0);

    pcie_rec(&pcie, _S_READ, 14, buf_rec);
    usleep(10);

    fprintf(outf, " module number %d, chip %d\n", ((buf_rec[0] & 0xf8) >> 3), ((buf_rec[0] & 0x4) >> 2));
    fprintf(outf, " ------------------------------------------\n");

    unpack_array(buf_rec, tmp, 26, _U_LE);

    for (i=0; i<4; ++i) {
        fprintf(outf, " fiber %2d, FEM address %3d, beam counter %02x\n",
                i, ((tmp[i+1] >> 8) & 0xff), (tmp[i+1] & 0xff));
    }

    fprintf(outf, " trigger board beam counter =            %02x\n", tmp[25] & 0xff);
    fprintf(outf, " ------------------------------------------\n");

    /* send L1 trigger to the controller */
    int badcounter = 0;
    for (ie=0; ie<nevent; ie++) {
        if(ie%1000==0){
            time_t now = time(NULL);
            struct tm* t_now = localtime(&now);
            char b_now[64];

            strftime(b_now, sizeof(b_now), "%y/%m/%d-%H:%M:%S", t_now);
            printf("Event %d out of %d done... (%f%%) @ %s\n", ie, nevent, (float)ie/nevent*100, b_now);
        }

        if (interactive == 1) {
            printf(" [input] type 1 to send L1 trigger\n");
            scanf("%d", &i);
        } else {
            usleep(400000);
        }

        for (im=0; im<mod_count; im++) {
            addr_mod = im + mod_start;

            /* controller data go to ADC input section */
            chip = sp_adc_readback_sub;

            /* read out status */
            _sp_adc_cmd_int16(&pcie, addr_mod, chip, 8, 0x0);

            pcie_rec(&pcie, _S_INIT, 1, buf_rec);

            _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_readback_status, 0x0);

            pcie_rec(&pcie, _S_READ, 1, buf_rec);

            /* printf(" module %d receive data word: %08x, %08x\n", addr_mod, buf_rec[0], buf_rec[1]); */
            /* printf(" header word =              %02x\n", ((buf_rec[0] >> 8) & 0xff)); */
            /* printf(" module address =           %2d\n", (buf_rec[0] & 0x1f)); */
            /* printf(" upper adc rx pll locked     %d\n", ((buf_rec[0] >> 31) & 0x1)); */
            /* printf(" upper adc rx dpa locked     %d\n", ((buf_rec[0] >> 30) & 0x1)); */
            /* printf(" upper adc rx alignment      %d\n", ((buf_rec[0] >> 29) & 0x1)); */
            /* printf(" upper adc rx data valid     %d\n", ((buf_rec[0] >> 28) & 0x1)); */
            /* printf(" lower adc rx pll locked     %d\n", ((buf_rec[0] >> 27) & 0x1)); */
            /* printf(" lower adc rx dpa locked     %d\n", ((buf_rec[0] >> 26) & 0x1)); */
            /* printf(" lower adc rx alignment      %d\n", ((buf_rec[0] >> 25) & 0x1)); */
            /* printf(" lower adc rx data valid     %d\n", ((buf_rec[0] >> 24) & 0x1)); */
            /* printf(" link pll locked             %d\n", ((buf_rec[0] >> 23) & 0x1)); */
            /* printf(" clock pll locked            %d\n", ((buf_rec[0] >> 22) & 0x1)); */
            /* printf(" trigger buffer empty        %d\n", ((buf_rec[0] >> 21) & 0x1)); */
            /* printf("\n"); */
        }

        /* /1* generate new test data *1/ */
        /* for (ic=0; ic<64; ++ic) { */
        /*     data[ic] = (rand() & 0x3ff) << 4; */
        /* } */

        /* fprintf(outf, "\n"); */
        /* fprintf(outf, " generated data:\n"); */
        /* fprint_data_array(outf, data, 64, 8, 4); */
        /* fprintf(outf, "\n"); */

        /* /1* calculate expected adc output *1/ */
        /* calculate_mbd_adc_output(&ref, cmask, data, l1_adc_table, l1_slewing_table); */

        /* /1* load new test data *1/ */
        /* for (im=0; im<mod_count; im++) { */
        /*     addr_mod = im + mod_start; */
        /*     adc_load_testram(&pcie, addr_mod, /1* delay *1/ 400, cmask, data, silent); */
        /* } */

        _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_l1);

        /* crate controller readout */
        _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_m_data_transfer, 0x0);
        usleep(1000);

        /* set nword */
        nword = 2 + (40 * trig_nsample / 2) + 1;

        pcie_rec(&pcie, _S_INIT, nword, buf_rec);

        _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_m_data_read, 0x0);
        usleep(1000);

        pcie_rec(&pcie, _S_READ, nword, buf_rec);

        /* fprint_data_array(outf, buf_rec + 2, nword - 3, 8, 8); */

        /* fprintf(outf, " header = %4x\n", (buf_rec[0] & 0xffff)); */
        /* fprintf(outf, " module number = %d\n", ((buf_rec[0] >> 16) & 0x3f)); */
        /* fprintf(outf, " triggernumber = %d\n", (buf_rec[1] & 0xffff)); */
        /* fprintf(outf, " beam crossing number = %4x\n", ((buf_rec[1] >> 16) & 0xff)); */

        for (is=0; is<trig_nsample; is++) {
            for (k=0; k<20; k++) {
                adc_data[k*2+1][is] = (buf_rec[(k*trig_nsample)+is+2]) & 0xffff;
                adc_data[k*2+0][is] = (buf_rec[(k*trig_nsample)+is+2] >> 16) & 0xffff;
            }

            for (k=0; k<4; k++) {
                trig_charge[k][0][is] = ((adc_data[k*8+0][is] & 0x01ff));                                               //8-0
                trig_charge[k][1][is] = ((adc_data[k*8+0][is] & 0xfe00) >>  9) + ((adc_data[k*8+1][is] & 0x0003) << 7); //17-9
                trig_charge[k][2][is] = ((adc_data[k*8+1][is] & 0x07fc) >>  2);                                         //26-18
                trig_charge[k][3][is] = ((adc_data[k*8+1][is] & 0xf800) >> 11) + ((adc_data[k*8+2][is] & 0x000f) << 5); //35-27
                trig_charge[k][4][is] = ((adc_data[k*8+2][is] & 0x1ff0) >>  4);                                         //44-36
                trig_charge[k][5][is] = ((adc_data[k*8+2][is] & 0xe000) >> 13) + ((adc_data[k*8+3][is] & 0x003f) << 3); //53-45
                trig_charge[k][6][is] = ((adc_data[k*8+3][is] & 0x7fc0) >>  6);                                         //62-54
                trig_charge[k][7][is] = ((adc_data[k*8+3][is] & 0x8000) >> 15) + ((adc_data[k*8+4][is] & 0x00ff) << 1); //71-63
                trig_nhit[k][is]      = ((adc_data[k*8+4][is] & 0xff00) >>  8);                                         //79-72
                trig_time[k][0][is]   = ((adc_data[k*8+5][is] & 0x0fff));                                               //91-80
                trig_time[k][1][is]   = ((adc_data[k*8+5][is] & 0xf000) >> 12) + ((adc_data[k*8+6][is] & 0x00ff) << 4); //103-92
                trig_time[k][2][is]   = ((adc_data[k*8+6][is] & 0xff00) >>  8) + ((adc_data[k*8+7][is] & 0x000f) << 8); //115-104
                trig_time[k][3][is]   = ((adc_data[k*8+7][is] & 0xfff0) >>  4);                                         //127-116
            }

            mbd_right_tavg[is]   = ((adc_data[32][is] & 0x7fff));
            mbd_left_tavg[is]    = ((adc_data[32][is] & 0x8000) >> 15) + ((adc_data[33][is] & 0x3fff) << 1);
            mbd_right_nhit[is]   = ((adc_data[33][is] & 0xc000) >> 14) + ((adc_data[34][is] & 0x000f) << 2);
            mbd_left_nhit[is]    = ((adc_data[34][is] & 0x03f0) >>  4);
            mbd_right_remain[is] = ((adc_data[34][is] & 0xfc00) >> 10);
            mbd_left_remain[is]  = ((adc_data[35][is] & 0x003f));
            mbd_vertex_sub[is]   = ((adc_data[35][is] & 0x7fc0) >>  6);
            mbd_vertex_add[is]   = ((adc_data[35][is] & 0x8000) >> 15) + ((adc_data[36][is] & 0x01ff) << 1);
        }


        is = fill_adc_output_data(adc, adc_data, trig_nsample);
        if (is == -1)
            continue;

        simulate_ll1_mbd_algorithm(adc, &ll1);

        if (      (mbd_right_tavg[is]   ^ ll1.tavg[0])
                | (mbd_left_tavg[is]    ^ ll1.tavg[1])
                | (mbd_right_nhit[is]   ^ ll1.nhit[0])
                | (mbd_left_nhit[is]    ^ ll1.nhit[1])
                | (mbd_right_remain[is] ^ ll1.trem[0])
                | (mbd_left_remain[is]  ^ ll1.trem[1])
                | (mbd_vertex_sub[is]   ^ ll1.vtxs   )
                | (mbd_vertex_add[is]   ^ ll1.vtxd   )) {
            ++count;

            _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_o_read, 0x0);

            pcie_rec(&pcie, _S_INIT, 2, buf_rec);
            usleep(10);

            _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_o_read, 0x0);

            pcie_rec(&pcie, _S_READ, 2, buf_rec);
            usleep(10);

            /* readout header */
            pcie_rec(&pcie, _S_INIT, 14, buf_rec);
            usleep(10);

            _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_h_read, 0x0);

            pcie_rec(&pcie, _S_READ, 14, buf_rec);
            usleep(10);

            unpack_array(buf_rec, tmp, 26, _U_LE);

            /*
            printf("\n");
            printf(" bc: [ %04x %04x %04x %04x ] [ %04x ]\n", tmp[1] & 0xff, tmp[2] & 0xff, tmp[3] & 0xff, tmp[4] & 0xff, ((buf_rec[1] >> 16) & 0xff));
            printf("   r_tavg  |   l_tavg  |   r_nhit  |   l_nhit  |   r_remn  |   l_remn  |   vrtx_s  |   vtrx_d \n");
            printf(" %04x %04x | %04x %04x | %04x %04x | %04x %04x | %04x %04x | %04x %04x | %04x %04x | %04x %04x\n",
                    mbd_right_tavg[is]   , ll1.tavg[0],
                    mbd_left_tavg[is]    , ll1.tavg[1],
                    mbd_right_nhit[is]   , ll1.nhit[0],
                    mbd_left_nhit[is]    , ll1.nhit[1],
                    mbd_right_remain[is] , ll1.trem[0],
                    mbd_left_remain[is]  , ll1.trem[1],
                    mbd_vertex_sub[is]   , ll1.vtxs   ,
                    mbd_vertex_add[is]   , ll1.vtxd   );

            if(interactive) scanf("%d", &i);
            */
        }

        if (0) {
            printf(" nevents: %8i [ %8i ]\r", ie, count);
            fflush(stdout);
        }

        /* for (k=0; k<40; k++) { */
        /*     fprintf(outf, " raw %2d ", k); */
        /*     for (is=0; is<trig_nsample; is++) { */
        /*         fprintf(outf, " %4x", adc_data[k][is]); */
        /*     } */
        /*     fprintf(outf, "\n"); */
        /* } */

        /* fprintf(outf, "\n"); */


        /* comparison test */
        int isOne = 1;
        for (k=0; k<4; k++ ) {
            for (ic=0; ic<8; ic++) {
                isOne &= (trig_charge[k][ic][is] == ref.charge[ic]);
            }
            isOne &= (trig_nhit[k][is] == ref.nhit);
            for (ic=0; ic<4; ic++) {
                isOne &= (trig_time[k][ic][is] == ref.time[ic]);
            }
        }
        if(!isOne){
            badcounter++;

            fprintf(outf, "     |");
            for (ic=0; ic<8; ic++) {
                fprintf(outf, "  Q%1d |", ic);
            }
            fprintf(outf, "  NH |");
            for (ic=0; ic<4; ic++) {
                fprintf(outf, "  T%1d |", ic);
            }
            fprintf(outf, "\n");

            for (k=0; k<4; k++ ) {
                fprintf(outf, "ADC %1d\n", k);

                fprintf(outf, " OUT |");
                for (ic=0; ic<8; ic++) {
                    fprintf(outf, " %3x |", trig_charge[k][ic][is]);
                }
                fprintf(outf, " %3x |", trig_nhit[k][is]);
                for (ic=0; ic<4; ic++) {
                    fprintf(outf, " %3x |", trig_time[k][ic][is]);
                }
                fprintf(outf, "\n");

                fprintf(outf, " REF |");
                for (ic=0; ic<8; ic++) {
                    fprintf(outf, " %3x |", ref.charge[ic]);
                }
                fprintf(outf, " %3x |", ref.nhit);

                for (ic=0; ic<4; ic++) {
                    fprintf(outf, " %3x |", ref.time[ic]);
                }
                fprintf(outf, "\n");

                fprintf(outf, " CMP |");
                for (ic=0; ic<8; ic++) {
                    fprintf(outf, " %3x |", (trig_charge[k][ic][is] == ref.charge[ic]) );
                }
                fprintf(outf, " %3x |", trig_nhit[k][is] == ref.nhit);
                for (ic=0; ic<4; ic++) {
                    fprintf(outf, " %3x |", trig_time[k][ic][is] == ref.time[ic]);
                }
                fprintf(outf, "\n");
            }
        }

        if (0) {
            for (k=0; k<4; k++ ) {
                for (ic=0; ic<8; ic++) {
                    fprintf(outf, " %1d Q%1d", k, ic);
                    for (is=0; is<trig_nsample; is++) {
                        fprintf(outf, " %3x", trig_charge[k][ic][is]);
                    }
                    fprintf(outf, " | %3x", ref.charge[ic]);
                    fprintf(outf, "\n");
                }

                fprintf(outf, " %1d NH", k);
                for (is=0; is<trig_nsample; is++) {
                    fprintf(outf, " %3x", trig_nhit[k][is]);
                }
                fprintf(outf, " | %3x", ref.nhit);
                fprintf(outf, "\n");

                for (ic=0; ic<4; ic++) {
                    fprintf(outf, " %1d T%1d", k, ic);
                    for (is=0; is<trig_nsample; is++) {
                        fprintf(outf, " %3x", trig_time[k][ic][is]);
                    }
                    fprintf(outf, " | %3x", ref.time[ic]);
                    fprintf(outf, "\n");
                }

                fprintf(outf, "\n");
            }

            fprintf(outf, " r_tavg ");
            for (is=0; is<trig_nsample; is++) {
                fprintf(outf, " %4x", mbd_right_tavg[is]);
            }
            fprintf(outf, "\n");
            fprintf(outf, " l_tavg ");
            for (is=0; is<trig_nsample; is++) {
                fprintf(outf, " %4x", mbd_left_tavg[is]);
            }
            fprintf(outf, "\n");
            fprintf(outf, " r_nhit ");
            for (is=0; is<trig_nsample; is++) {
                fprintf(outf, " %4x", mbd_right_nhit[is]);
            }
            fprintf(outf, "\n");
            fprintf(outf, " l_nhit ");
            for (is=0; is<trig_nsample; is++) {
                fprintf(outf, " %4x", mbd_left_nhit[is]);
            }
            fprintf(outf, "\n");
            fprintf(outf, " r_remn ");
            for (is=0; is<trig_nsample; is++) {
                fprintf(outf, " %4x", mbd_right_remain[is]);
            }
            fprintf(outf, "\n");
            fprintf(outf, " l_remn ");
            for (is=0; is<trig_nsample; is++) {
                fprintf(outf, " %4x", mbd_left_remain[is]);
            }
            fprintf(outf, "\n");
            fprintf(outf, " vrtx_s ");
            for (is=0; is<trig_nsample; is++) {
                fprintf(outf, " %4x", mbd_vertex_sub[is]);
            }
            fprintf(outf, "\n");
            fprintf(outf, " vrtx_d ");
            for (is=0; is<trig_nsample; is++) {
                fprintf(outf, " %4x", mbd_vertex_add[is]);
            }
            fprintf(outf, "\n");
            /* end crate controller readout */
        }

        if (!debug) { continue; }

        if (interactive == 1) {
            printf(" [input] type 1 to send the transfer\n");
            scanf("%d", &i);
        } else {
            usleep(400000);
        }

        /* controller data go to ADC input section */
        chip = sp_adc_readback_sub;

        for (im=0; im<mod_count; im++) {
            addr_mod = im + mod_start;
            parity = 0;

            _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_readback_transfer, 0x0);

            /* set nword */
            nword = 2 + (64 * nsample / 2) + 1;

            pcie_rec(&pcie, _S_INIT, nword, buf_rec);

            _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_readback_read, 0x1);

            pcie_rec(&pcie, _S_READ, nword, buf_rec);

            fprintf(outf, " header 1 = %08x\n", buf_rec[0]);
            fprintf(outf, " header 2 = %08x\n", buf_rec[1]);

            fprint_data_array(outf, buf_rec + 2, nword - 2, 8, 8);

            for (iw=0; iw<nword-1; iw++) {
                parity = parity ^ buf_rec[iw];
            }

            printf(" parity, received / calculated: %08x / %08x\n", buf_rec[nword-1], parity);
            if (buf_rec[nword-1] != parity) printf(" [!] parity error...\n");

            fprintf(outf, "\n");

            fprintf(outf, " header = %04x\n", (buf_rec[0] & 0xffff));
            fprintf(outf, " module number = %d\n", ((buf_rec[0] >> 16) & 0x1f));
            fprintf(outf, " triggernumber = %04x\n", (buf_rec[1] & 0xffff));
            fprintf(outf, " beam crossing number = %04x\n", ((buf_rec[1] >> 16) & 0xff));

            for (is=0; is<nsample; is++) {
                for (k=0; k<32; k++) {
                    adc_data[k*2+0][is] = (buf_rec[(k*nsample)+is+2]) & 0xffff;
                    adc_data[k*2+1][is] = (buf_rec[(k*nsample)+is+2] >> 16) & 0xffff;
                }
            }

            for (is=0; is<64; is++) {
                fprintf(outf, " channel %02d ", is);
                for (k=0; k<nsample; k++) {
                    fprintf(outf, " %4x", adc_data[is][k]);
                }
                fprintf(outf, "\n");
            }

            fprintf(outf, "\n");
        }
    }

    printf("\n");
    printf("Number of bad events/total events = %d/%d = %f%%\n", badcounter, nevent, (float)badcounter/nevent*100);

    if (log == 1) {
        fclose(outf);
    }

    printf(" event loop finished\n");
}

static void ll1_setup(struct pcie_interface_t* pcie, int addr_mod, int fifo_delay, int sync_step, int opt_mask, int thr, int nsample, int delay)
{
    /* reset the optical parts */
    printf("  reset trigger module optics\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_RESET, 0x0);
    usleep(1000);

    /* disable optical channel */
    printf("  disable optical channel\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_ch_dis1, (opt_mask & 0xffff));
    usleep(1000);

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_ch_dis2, ((opt_mask >> 16) & 0xff));
    usleep(1000);

    printf("  reset trigger module pll reset\n");

    /* pll reset */
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_rst_p, sp_L1_s10_rst_pll);
    usleep(1000);

    printf("  reset trigger module stitch transmitter reset\n");

    /* stitch transmitter reset */
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_rst_p, sp_L1_s10_rst_opt_st_t);
    usleep(1000);

    printf("  reset trigger module stitch receiver reset\n");

    /* stitch receiver reset */
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_rst_p, sp_L1_s10_rst_opt_st_r);
    usleep(1000);

    /* transmitter reset */
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_rst_p, sp_L1_s10_rst_opt_out_t);
    usleep(1000);

    printf("  reset test data register\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_reset, 0x0);
    usleep(1000);

    printf("  set phase number (0-15)\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_phasen, sync_step);
    usleep(1000);

    printf("  set align data delay\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_delay, fifo_delay);
    usleep(1000);

    printf("  set threshold\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_thr, thr);
    usleep(1000);

    printf("  set trigger board m_size\n");
    usleep(400000);

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_m_size, nsample - 1);

    printf("  set trigger board m_delay\n");
    usleep(400000);

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_m_delay, delay);

    /* readout from crate controller */
    printf("  set trigger board rstblk, dat2rbdk, dat2link\n");
    usleep(400000);

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_rstblk, 0x0);
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_dat2rbdk, 0x1);
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_dat2link, 0x0);
    /* end crate controller readout */

    /* /1* read out status *1/ */
    /* int i; */
    /* UINT32 buf_rec[10000]; */

    /* printf(" [input] send read command\n"); */
    /* scanf("%d", &i); */

    /* pcie_rec(pcie, _S_INIT, 4, buf_rec); */
    /* usleep(10); */

    /* _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_mbd_o_read, 0x0); */

    /* pcie_rec(pcie, _S_READ, 4, buf_rec); */
    /* usleep(10); */

    /* printf(" data word received = %08x %08x\n", buf_rec[0], buf_rec[1]); */

    usleep(400000);
}

static void adc_setup(struct pcie_interface_t* pcie, int addr_mod)
{
    int ic;
    int chip;

    /* controller data goes to ADC input section */
    chip = sp_adc_input_sub;

    for (ic=0; ic<8; ic++) {
        printf(" module %2d :  set spi address to channel %2d\r", addr_mod, ic);
        fflush(stdout);

        /* set spi address */
        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_spi_add, ic);

        /* power reset the ADC */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x08, 0x03, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);

        /* remove power reset */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x08, 0x00, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);

        /* reset ADC */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x00, 0x3c, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);

        /* set LVDS termination - set address 0x15 to 1 for 2x drive */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x15, 0x20, 0, 0); // 100 ohms termination
        /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x15, 0x00, 0, 0); // no termination, 1x drive */
        /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x15, 0x01, 0, 0); // no termination, 2x drive */
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);

        /* set fix pattern: 0xa = sync pattern */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x0d, 0xa, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);
    }

    printf(" module %2d :  set spi address to channels [done]\n", addr_mod);

    usleep(100);

    /* set up for ADC alignment */

    /* controller data go to ADC slow control section */
    chip = sp_adc_slowcntl_sub;

    /* /1* pll reset *1/ */
    /* printf(" module %2d :  send pll reset\n", addr_mod); */

    /* _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_pll_reset, 0x0); */
    /* usleep(1000); */

    /* DPA reset */
    printf(" module %2d :  send ADC DPA reset\n", addr_mod);

    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_dpa_reset, 0x0);
    usleep(1000);

    /* upper ADC alignment */
    printf(" module %2d :  send upper channel align\n", addr_mod);

    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_u_adc_align, 0x0);
    usleep(1000);

    /* lower ADC alignment */
    printf(" module %2d :  send lower channel align\n", addr_mod);

    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_l_adc_align, 0x0);
    usleep(1000);

    /* controller data go to ADC input section */
    chip = sp_adc_input_sub;

    for (ic=0; ic<8; ic++) {
        /* set spi address */
        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_spi_add, ic);
        usleep(100);

        /* output offset binary code */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x14, 0x00, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);

        /* unset fix pattern 0x0 for normal data taking --- set to test condition */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x0d, 0x00, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);
    }

    /* test routine */

    /* /1* set spi address; data argument is channel *1/ */
    /* _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_spi_add, 0); */

    /* /1* remove channels H,G,F,E from the selection list *1/ */
    /* pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300); */
    /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x04, 0x00, 0, 0); */
    /* pcie_send(pcie, _M_DMA, 2); */
    /* usleep(100); */

    /* /1* keep only channel A in the selection list *1/ */
    /* pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300); */
    /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x05, 0x01, 0, 0); */
    /* pcie_send(pcie, _M_DMA, 2); */
    /* usleep(100); */

    /* /1* set fix pattern: 0xa = sync pattern *1/ */
    /* pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300); */
    /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x0d, 0x0c, 0, 0); */
    /* pcie_send(pcie, _M_DMA, 2); */
    /* usleep(100); */

    /* /1* restore selection list 1 *1/ */
    /* pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300); */
    /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x04, 0x0f, 0, 0); */
    /* pcie_send(pcie, _M_DMA, 2); */
    /* usleep(100); */

    /* /1* restore selection list 2 *1/ */
    /* pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300); */
    /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x05, 0x3f, 0, 0); */
    /* pcie_send(pcie, _M_DMA, 2); */
    /* usleep(100); */
}

static void adc_load_testram(struct pcie_interface_t* pcie, int addr_mod, int delay, UINT64 cmask, UINT32* data, int silent)
{
    int ic, iclk;
    int chip;
    int offset, width, interval, count;

    UINT32 word;

    /* set data pattern */
    offset = 10;
    interval = 60;
    width = 7;
    count = 6;

    /* set chip */
    /* controller data goes to ADC input section */
    chip = sp_adc_input_sub;

    for (ic=0; ic<64; ic++) {
        /* set channel 0 to 64 */
        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_testram_load_ch, ic ? ic : 64);

        if (!silent) {
            printf(" module %2d :  load testram to channel %2d\r", addr_mod, ic);
            fflush(stdout);
        }

        for (iclk=0; iclk<512; iclk++) {
            word = 0x0000;

            if (cmask & (0x1ULL << ic)) {
                if ((((iclk - offset) % interval) < width) && (((iclk - offset) / interval) < count)) {
                    word = data[ic] & 0x3fff;
                }
            }

            _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_testram_load_data, word);
        }
    }

    if (!silent) {
        printf(" module %2d :  load testram to channels [done]\n", addr_mod);
    }

    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_testram_trig_delay, delay);
}

static void adc_load_lookup_tables(struct pcie_interface_t* pcie, int addr_mod, UINT32* l1_adc_table, UINT32* l1_slewing_table)
{
    int chip;
    int i, ic;

    int trig_rw_delay;

    /* set chip */
    chip = sp_adc_trigproc_sub;

    /* loading the adc correction table for channels 0-63 */
    for (ic=0; ic<64; ic++) {
        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_tbl_chnl, ic);

        printf(" module %2d :  load adc correction table to channel %2d\r", addr_mod, ic);
        fflush(stdout);

        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_lkp_addr, 0);
        _sp_adc_cmd_array(pcie, addr_mod, chip, sp_adc_trig_lkp_data, l1_adc_table, 1024);
    }

    printf(" module %2d :  load adc correction table to channels [done]\n", addr_mod);

    /* loading the slewing correction table */
    for (ic=0; ic<32; ic++) {
        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_tbl_chnl, ic);

        printf(" module %2d :  load slewing table to channel %2d\r", addr_mod, ic);
        fflush(stdout);

        for (i=0; i<4; i++) {
            _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_mbd_tbl_add, i * 1024);
            _sp_adc_cmd_array(pcie, addr_mod, chip, sp_adc_trig_mbd_tbl_data, &l1_slewing_table[i * 1024], 1024);
        }
    }

    printf(" module %2d :  load slewing table to channels [done]\n", addr_mod);

    /* set trigger subtract delay */
    trig_rw_delay = 6;

    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_sub_delay, trig_rw_delay);

    /* set trigger sample phase 5 */
    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_smpl_phase, 0x6);
}

static int pcie_init(struct pcie_interface_t* pcie) {
    DWORD dwStatus;

    DWORD dwAddrSpace;
    DWORD dwOffset;
    UINT32 u32Data;

    DWORD dwOptions;
    DWORD dwDMABufSize;

    /* initialize */
    dwAddrSpace = 2;
    dwOffset = 0x28;
    u32Data = 0xf0000008;
    WDC_WriteAddr32(pcie->dev, dwAddrSpace, dwOffset, u32Data);

    dwOptions = DMA_TO_DEVICE;
    dwDMABufSize = 100000;
    dwStatus = WDC_DMAContigBufLock(pcie->dev, (void**)&(pcie->send.buffer), dwOptions, dwDMABufSize, &(pcie->send.pDMA));
    if (WD_STATUS_SUCCESS != dwStatus) {
        printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return 1;
    }

    dwOptions = DMA_FROM_DEVICE;
    dwDMABufSize = 100000;
    dwStatus = WDC_DMAContigBufLock(pcie->dev, (void**)&(pcie->rec.buffer), dwOptions, dwDMABufSize, &(pcie->rec.pDMA));
    if (WD_STATUS_SUCCESS != dwStatus) {
        printf("Failed locking a receive Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return 1;
    }

    return 0;
}

static int pcie_send(struct pcie_interface_t* pcie, int mode, int nword)
{
    /* imode=0: single word transfer, imode=1: DMA */

    WDC_DEVICE_HANDLE dev; 

    DWORD dwAddrSpace;
    DWORD dwOffset;
    UINT32 u32Data;

    int nbytes;
    int i;

    dev = pcie->dev;

    nbytes = nword * sizeof(UINT32);

    switch (mode) {
        case _M_WORD:
            /* setup transmitter */
            dwAddrSpace = 2;
            dwOffset = 0x20;
            u32Data = 0x20000000;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            dwAddrSpace = 2;
            dwOffset = 0x20;
            u32Data = 0x40000000 + nbytes;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            for (i=0; i<nword; ++i) {
                dwAddrSpace = 4;
                dwOffset = 0x0;
                u32Data = pcie->send.buffer[i];
                WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);
            }

            do {
                dwAddrSpace = 2;
                dwOffset = 0xC;
                WDC_ReadAddr32(dev, dwAddrSpace, dwOffset, &u32Data);
            } while(u32Data & 0x80000000);

            return 0;
        case _M_DMA:
            WDC_DMASyncCpu(pcie->send.pDMA);

            /* setup transmitter */
            dwAddrSpace = 2;
            dwOffset = 0x20;
            u32Data = 0x20000000;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            dwAddrSpace = 2;
            dwOffset = 0x20;
            u32Data = 0x40000000 + nbytes;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            /* set up sending DMA starting address */
            dwAddrSpace = 2;
            dwOffset = 0x0;
            u32Data = pcie->send.pDMA->Page->pPhysicalAddr & 0xffffffff;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            dwAddrSpace = 2;
            dwOffset = 0x4;
            u32Data = (pcie->send.pDMA->Page->pPhysicalAddr >> 32) & 0xffffffff;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            /* byte count */
            dwAddrSpace = 2;
            dwOffset = 0x8;
            u32Data = nbytes;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            /* write this to start DMA */
            dwAddrSpace = 2;
            dwOffset = 0xc;
            u32Data = 0x00200000;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            do {
                dwAddrSpace = 2;
                dwOffset = 0xC;
                WDC_ReadAddr32(dev, dwAddrSpace, dwOffset, &u32Data);
            } while(u32Data & 0x80000000);

            WDC_DMASyncIo(pcie->send.pDMA);

            return 0;
    }

    return 1;
}

static int pcie_rec(struct pcie_interface_t* pcie, int state, int nword, UINT32 *buffer)
{
    /* mode=0: single word transfer, mode=1: DMA */
    /* nword assumed to be number of 16-bit words */

    WDC_DEVICE_HANDLE dev;

    DWORD dwAddrSpace;
    DWORD dwOffset;
    UINT32 u32Data;
    UINT64 u64Data;

    int ndata;
    int i;

    dev = pcie->dev;

    /* set up the receiver */
    switch (state) {
        case _S_INIT:
            /* initialize transmitter mode register... */
            dwAddrSpace = 2;
            u32Data = 0xf0000008;
            dwOffset = tx_mode_reg;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            /* initialize the receiver */
            dwAddrSpace = cs_bar;
            dwOffset = r2_cs_reg;
            u32Data = cs_init;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            /* write byte count */
            dwAddrSpace = cs_bar;
            dwOffset = r2_cs_reg;
            u32Data = cs_start + nword * 4;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            return 0;
        case _S_READ:
            ndata = (nword + 1) / 2;

            for (i=0; i<ndata; i++) {
                dwAddrSpace = t2_tr_bar;
                dwOffset = 0x0;
                WDC_ReadAddr64(dev, dwAddrSpace, dwOffset, &u64Data);

                *buffer++ = u64Data & 0xffffffff;
                *buffer++ = (u64Data >> 32) & 0xffffffff;
            }

            return 0;
    }

    return 1;
}
