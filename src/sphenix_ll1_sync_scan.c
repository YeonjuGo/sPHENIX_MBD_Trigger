/************************************************************************
 *  File: pcie_diag.c
 *
 *  Sample user-mode diagnostics application for accessing JSEB2
 *  devices using WinDriver's API.
 *  Code was generated by DriverWizard v10.21.
 *
 *  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
 *************************************************************************/

#define _POSIX_C_SOURCE 199309L
#define _XOPEN_SOURCE 600

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#include "diag_lib.h"
#include "pci_regs.h"
#include "status_strings.h"
#include "utils.h"
#include "wdc_defs.h"
#include "wdc_diag_lib.h"
#include "wdc_lib.h"

#include "include/jseb2_lib.h"
#include "include/sphenix.h"

#define JSEB2_ERR printf

static CHAR gsInput[256];

static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* main function */
static void ll1_trigger_test(WDC_DEVICE_HANDLE hDev);

#define _DMA_SEND 0
#define _DMA_REC  1

struct wd_dma_buffer_t {
    UINT32* buffer;
    WD_DMA* pDMA;
};

struct pcie_interface_t {
    WDC_DEVICE_HANDLE dev;
    struct wd_dma_buffer_t send;
    struct wd_dma_buffer_t rec;
};

/* pcie data transfer */
static int pcie_init(struct pcie_interface_t* pcie);
static int pcie_send(struct pcie_interface_t* pcie, int mode, int nword);
static int pcie_rec(struct pcie_interface_t* pcie, int state, int nword, UINT32 *buffer);

/* helper functions */
static void ll1_setup(struct pcie_interface_t* pcie, int addr_mod, int fifo_delay, int sync_step, int opt_mask, int thr, int nsample, int delay);
static void adc_setup(struct pcie_interface_t* pcie, int addr_mod);
static void adc_load_testram(struct pcie_interface_t* pcie, int addr_mod, int delay, UINT64 cmask, UINT32* data);
static void adc_load_lookup_tables(struct pcie_interface_t* pcie, int addr_mod, UINT32* l1_adc_table, UINT32* l1_slewing_table);

/* enumeration for pcie_send mode */
#define _M_WORD 0
#define _M_DMA  1

/* enumeration for pcie_rec state */
#define _S_INIT 0
#define _S_READ 1

/* format adc command */
#define _SP_ADC_CMD(mod, chip, cmd) \
    ((mod) << 11) + ((chip) << 8) + ((cmd) << 0)

#define _SP_ADC_CMD_FMT(mod, chip, cmd, data) \
    ((mod) << 11) + ((chip) << 8) + ((cmd) << 0) + ((data) << 16)

/* format ll1 command */
#define _SP_LL1_CMD(mod, chip, cmd) \
    ((mod) << 10) + ((chip) << 8) + ((cmd) << 0)

#define _SP_LL1_CMD_FMT(mod, chip, cmd, data) \
    ((mod) << 10) + ((chip) << 8) + ((cmd) << 0) + ((data) << 16)

/* FIXME: original comment for sp_adc_spi_data command: */
/* 1st next word will be overwritten by the next next word */

/* formats next data word (uint32_t) for sp_adc_spi_data command. argument
 * names are reasonable guesses; last two arguments are always 0. original
 * accompanying comment: */
/* set /w=0, w1,w2=0, a12-a0=cmd, data=data; */
#define _SP_ADC_SPI_FMT(cmd, data, _0, _1) \
    ((cmd) + ((_0) << 13) + ((_1) << 16) + ((data) << 24))

/* formats data buffer in the format: [ data word ] */
static void pack_int16(UINT32* buffer, UINT32 word, UINT32 data) {
    buffer[0] = (word) + (data << 16);
}

/* formats data buffers of packed 16-bit data from a 32-bit array */
/* ignores first element of buffer and packs the rest in the format:
 * [ * * ] [ 2 1 ] [ 4 3 ] ... */
static void pack_array(UINT32* buffer, UINT32 word, UINT32* data, int size) {
    int i;

    buffer[0] = (word) + (data[0] << 16);

    for (i=0; i<(size-1)/2; ++i) {
        buffer[i+1] = (data[(i*2)+1]) + (data[(i+1)*2] << 16);
    }

    if ((i+1)*2 == size) {
        buffer[i+1] = (data[size-1]);
    }
}

/* enumeration for data order */
#define _U_BE 0x10
#define _U_LE 0x00

/* unpacks data buffers of packed 16-bit data from a 32-bit array */
/* each 16-bit word is stored as a 32-bit element in the output array (data) */
static void unpack_array(UINT32* buffer, UINT32* data, int size, int shift) {
    int i;

    for (i=0; i<size; ++i, shift^=0x10) {
        data[i] = (buffer[i/2] >> shift) & 0xffff;
    }
}

static void _sp_adc_cmd_int16(struct pcie_interface_t* pcie, int mod, int chip, int cmd, UINT32 data) {
    pack_int16(pcie->send.buffer, _SP_ADC_CMD(mod, chip, cmd), data);
    pcie_send(pcie, _M_DMA, 1);
    usleep(10);
}

static void _sp_adc_cmd_array(struct pcie_interface_t* pcie, int mod, int chip, int cmd, UINT32* data, int size) {
    pack_array(pcie->send.buffer, _SP_ADC_CMD(mod, chip, cmd), data, size);
    pcie_send(pcie, _M_DMA, size / 2 + 1);
    usleep(1000);
}

static void _sp_ll1_cmd_int16(struct pcie_interface_t* pcie, int mod, int chip, int cmd, UINT32 data) {
    pack_int16(pcie->send.buffer, _SP_LL1_CMD(mod, chip, cmd), data);
    pcie_send(pcie, _M_DMA, 1);
    usleep(10);
}

/* data structure for ll1 mbd algorithm output */
struct sp_ll1_mbd_t {
    int charge[8], nhit, time[8];
};

/* simulation of ll1 mbd algorithm */
static void calculate_mbd_adc_output(struct sp_ll1_mbd_t* output, UINT64 cmask, UINT32* input, UINT32* l1_adc_table, UINT32* l1_slewing_table) {
    int i;

    UINT32 tmp;
    UINT32 qadd[32];

    output->nhit = 0;

    memset(output->time, 0, sizeof(output->time));
    memset(output->charge, 0, sizeof(output->charge));

    /* charge channels */
    for (i=0; i<32; ++i) {
        tmp = l1_adc_table[input[i + 32] >> 4];

        qadd[i] = (tmp & 0x0380) >> 7;

        output->charge[i/4] += tmp & 0x7f;
    }

    /* time channels */
    for (i=0; i<32; ++i) {
        tmp = l1_adc_table[input[i] >> 4];

        output->nhit += (tmp & 0x0200) >> 9;

        tmp = l1_slewing_table[(qadd[i] << 9) + (tmp & 0x1ff)];

        output->time[i/8] += tmp;
    }
}

/* display data array in columnar format */
static void _print_data_array(FILE* f, UINT32* data, int size, int col, int width) {
    int i;

    for (i=0; i<size; ++i) {
        if (i % col == 0) fprintf(f, " %4x", i);
        fprintf(f, " %*x", width, data[i]);
        if (i % col == col - 1) fprintf(f, "\n");
    }
    if (i % col != 0) fprintf(f, "\n");
}

/* main function */
int main(void)
{
    WDC_DEVICE_HANDLE hDev;

    DWORD dwStatus;

    hDev = NULL;

    printf("\n");
    printf("JSEB2 diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the JSEB2 library */
    dwStatus = JSEB2_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("pcie_diag: Failed to initialize the JSEB2 library: %s",
                JSEB2_GetLastErr());
        return dwStatus;
    }

    /* Find and open a JSEB2 device (by default ID) */
    if (JSEB2_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(JSEB2_DEFAULT_VENDOR_ID, JSEB2_DEFAULT_DEVICE_ID);

    ll1_trigger_test(hDev);

    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);

    dwStatus = JSEB2_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        JSEB2_ERR("pcie_diag: Failed to uninit the JSEB2 library: %s", JSEB2_GetLastErr());

    return dwStatus;
}

/* Find and open a JSEB2 device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
    WD_PCI_SLOT slot;

    if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
        return NULL;

    return DeviceOpen(&slot);
}

/* Find a JSEB2 device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if (dwVendorId == 0)
    {
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
                    "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
                    "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("DeviceFind: Failed scanning the PCI bus.\n"
                "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        JSEB2_ERR("No matching device was found for search criteria "
                "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
                dwVendorId, dwDeviceId);

        return FALSE;
    }

    printf("\n");
    printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
            dwNumDevices, dwNumDevices > 1 ? "s" : "",
            dwVendorId, dwVendorId ? "" : " (ALL)",
            dwDeviceId, dwDeviceId ? "" : " (ALL)");

    for (i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
                i + 1,
                scanResult.deviceId[i].dwVendorId,
                scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
    printf("\n");

    if (dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i,
                    gsInput, FALSE, 1, dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

/* Open a handle to a JSEB2 device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;

    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
                "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = JSEB2_DeviceOpen(&deviceInfo);
    if (!hDev)
    {
        JSEB2_ERR("DeviceOpen: Failed opening a handle to the device: %s",
                JSEB2_GetLastErr());
        return NULL;
    }

    return hDev;
}

/* Close handle to a JSEB2 device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if (!hDev)
        return;

    if (!JSEB2_DeviceClose(hDev))
    {
        JSEB2_ERR("DeviceClose: Failed closing JSEB2 device: %s",
                JSEB2_GetLastErr());
    }
}

#define XOR(a, b, mask)     (((a) ^ (b)) & (mask))

static void ll1_trigger_test(WDC_DEVICE_HANDLE hDev)
{
    int addr_mod, chip;

    UINT32 buf_rec[40000], tmp[40000];

    int i,ic,iy,im,ie;

    int iwrite;
    FILE *outf;

    int nsample;
    int mod_start, mod_count;
    int mod_ll1, chip_ll1, addr_ll1;
    int trig_fifo_delay, trig_sync_step, trig_opt_mask, trig_thr;
    int trig_nsample, trig_delay;

    int nword;

    UINT64 cmask;
    UINT32 data[64];
    struct sp_ll1_mbd_t ref;

    UINT32 l1_slewing_table[4096], l1_adc_table[1024];

    int count;

    char buffer[256];

    srand(time(NULL));

    iwrite = 0;

    if (iwrite == 0) {
        printf(" [input] 1st FEM module slot number\n");
        scanf("%d", &mod_start);
        printf(" [input] number of FEM module\n");
        scanf("%d", &mod_count);
        printf(" [input] trigger module address\n");
        scanf("%d", &mod_ll1);
        printf(" [input] enter 0 for lower chip and 1 for upper chip\n");
        scanf("%d", &chip_ll1);
    } else {
        mod_start = 6;
        mod_count = 4;
        mod_ll1 = 18;
        chip_ll1 = 0;
    }

    nsample = 24;

    trig_fifo_delay = 100;
    /* trig_sync_step = 3; /1* default: 3 *1/ */
    trig_sync_step = 0;
    trig_opt_mask = 0;
    trig_thr = 30;
    trig_nsample = 30;
    trig_delay = 20;

    if (iwrite == 0) {
        outf = stdout;
    } else {
        /* snprintf(buffer, 255, "/home/grape/jseb/sPHENIXJSEB/logs/scan_3/scan_sync_step_%02i.log", trig_sync_step); */
        snprintf(buffer, 255, "/home/grape/jseb/sPHENIXJSEB/logs/tmp.log");
        outf = fopen(buffer, "w");
    }

    struct pcie_interface_t pcie;

    pcie.dev = hDev;

    if (pcie_init(&pcie)) {
        printf(" failed to initialise pcie\n");
        return;
    }

    pcie.send.buffer[0] = 0x0;
    pcie_send(&pcie, _M_DMA, 1);

    printf(" set the controller to offline state before reset can be applied\n");

    /* enable offline run on */
    _sp_adc_cmd_int16(&pcie, 0, 0, sp_cntrl_offline, 0x1);

    /* send init to the controller */
    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_init);
    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_init);

    if (iwrite == 0) {
        printf(" [input] type 1 to continue\n");
        scanf("%d", &i);
    } else {
        usleep(400000);
    }

    /* send reset to the controller */
    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_reset);
    usleep(1000);

    printf(" call ll1 setup\n");

    /* take care to shift module address */
    addr_ll1 = (mod_ll1 << 1) + chip_ll1;
    ll1_setup(&pcie, addr_ll1, trig_fifo_delay, trig_sync_step, trig_opt_mask, trig_thr, trig_nsample, trig_delay);

    /* set adc test data */
    /* cmask = 0x1ULL <<  1 */
    /*     |   0x1ULL << 33; */
    cmask = 0xffffffffffffffffULL;

    for (ic=0; ic<64; ++ic) {
        data[ic] = (rand() & 0x3ff) << 4;
        /* data[ic] = 0x3fff; */
    }

    printf( " generated data\n");
    _print_data_array(outf, data, 64, 8, 4);
    printf("\n");

    /* set adc lookup tables */
    for (i=0; i<1024; i++) {
        l1_adc_table[i] = (i) & 0x3ff;
    }

    for (i=0; i<4096; i++) {
        l1_slewing_table[i] = (i) & 0x1ff;
    }

    /* setup adc modules */
    for (im=0; im<mod_count; im++) {
        addr_mod = im + mod_start;
        chip = sp_adc_slowcntl_sub;

        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_evt_sample, nsample - 1);
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_l1_delay, 0x10);
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_rd_link, 0x0);
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_rd_cntrl, 0x1);
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_sel_pulse, 0x0);
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_sel_caltrig, 0x0);

        printf(" module %2d : set test ram state\n", addr_mod);
        usleep(400000);

        /* set data to 0x0 if not loading test data */
        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_test_pulse, 0x1);

        /* set select L1 trigger on */
        printf(" module %2d : select L1 trigger\n", addr_mod);
        usleep(400000);

        _sp_adc_cmd_int16(&pcie, addr_mod, chip, sp_adc_sel_l1, 0x1);

        printf(" module %2d : call adc setup\n", addr_mod);
        usleep(400000);

        adc_setup(&pcie, addr_mod);

        printf(" module %2d : load adc testram and lookup tables\n", addr_mod);
        usleep(400000);

        adc_load_testram(&pcie, addr_mod, /* delay */ 400, cmask, data);
        adc_load_lookup_tables(&pcie, addr_mod, l1_adc_table, l1_slewing_table);

        printf(" ---------------------------------\n");
    }

    /* calculate expected trigger output */
    calculate_mbd_adc_output(&ref, cmask, data, l1_adc_table, l1_slewing_table);

    usleep(400000);

    /* reset system again... */

    /* send init to the controller */
    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_init);
    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_init);

    /* send reset to the controller */
    if (iwrite == 0) {
        printf(" [input] type 1 to send reset\n");
        scanf("%d", &i);
    } else {
        usleep(400000);
    }

    _sp_adc_cmd_int16(&pcie, 0, 2, sp_cntrl_timing, sp_cntrl_reset);
    usleep(1000);

    /* send L1 trigger to the controller */
    for (iy=0; iy<24; iy++) {
        printf(" [#] set sync_step: %2i\n", iy);

        _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_phasen, iy);
        usleep(1000);

        /* readout status */
        /* printf(" [input] send l1 trigger status read command\n"); */
        /* scanf("%d", &i); */

        usleep(200000);

        count = 0;

        for (ie=0; ie<256; ++ie) {
            _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_o_read, 0x0);

            pcie_rec(&pcie, _S_INIT, 2, buf_rec);
            usleep(10);

            _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_o_read, 0x0);

            pcie_rec(&pcie, _S_READ, 2, buf_rec);
            usleep(10);

            /* fprintf(outf, " module number %d, chip %d\n", ((buf_rec[0] & 0x3e00) >> 9), ((buf_rec[0] & 0x100) >> 8)); */
            /* fprintf(outf, " optical cable locked status = %06x\n", ((buf_rec[0] & 0xff) + ((buf_rec[0] & 0xffff0000) >> 8))); */
            /* fprintf(outf, " PLL lock status %d\n", ((buf_rec[1] & 0x100) >> 8)); */
            /* fprintf(outf, "\n"); */

            usleep(5000);

            /* readout header */
            pcie_rec(&pcie, _S_INIT, 14, buf_rec);
            usleep(10);

            _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_h_read, 0x0);

            pcie_rec(&pcie, _S_READ, 14, buf_rec);
            usleep(10);

            /* fprintf(outf, " module number %d, chip %d\n", ((buf_rec[0] & 0xf8) >> 3), ((buf_rec[0] & 0x4) >> 2)); */
            /* fprintf(outf, " ------------------------------------------\n"); */

            unpack_array(buf_rec, tmp, 26, _U_LE);

            /* if (XOR(tmp[1], tmp[2], 0xff) | XOR(tmp[2], tmp[3], 0xff) | XOR(tmp[3], tmp[4], 0xff)) */
            /*     ++count; */

            /* printf("  [ %02x %02x %02x %02x ] [ %4i ]\r", tmp[1] & 0xff, tmp[2] & 0xff, tmp[3] & 0xff, tmp[4] & 0xff, count); */
            /* fflush(stdout); */

            /* for (i=0; i<24; ++i) { */
            /*     fprintf(outf, " fiber %2d, FEM address %3d, beam counter %02x\n", */
            /*             i, ((tmp[i+1] >> 8) & 0xff), (tmp[i+1] & 0xff)); */
            /* } */

            /* fprintf(outf, " trigger board beam counter =            %02x\n", tmp[25] & 0xff); */
            /* fprintf(outf, " ------------------------------------------\n"); */

            usleep(5000);

            _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_m_data_transfer, 0x0);
            usleep(1000);

            /* set nword */
            nword = 2 + (40 * trig_nsample / 2) + 1;

            pcie_rec(&pcie, _S_INIT, nword, buf_rec);

            _sp_ll1_cmd_int16(&pcie, addr_ll1, 0, sp_L1_s10_slow_mbd_m_data_read, 0x0);
            usleep(1000);

            pcie_rec(&pcie, _S_READ, nword, buf_rec);

            /* _print_data_array(outf, buf_rec + 2, nword - 3, 8, 8); */

            if (XOR(tmp[1], tmp[2], 0xff) | XOR(tmp[2], tmp[3], 0xff) | XOR(tmp[3], tmp[4], 0xff) | XOR(tmp[4], buf_rec[1] >> 16, 0xff))
                ++count;

            printf("  [ %02x %02x %02x %02x ] [ %02x ] [ %4i ]\r",
                    tmp[1] & 0xff, tmp[2] & 0xff, tmp[3] & 0xff, tmp[4] & 0xff,
                    (buf_rec[1] >> 16) & 0xff,
                    count);
            fflush(stdout);
        }

        printf("            [ %c ] [ %4i ]\n", count ? 'X' : 'O', count);
    }

    if (iwrite == 1) {
        fclose(outf);
    }

    printf(" event loop finished\n");
}

static void ll1_setup(struct pcie_interface_t* pcie, int addr_mod, int fifo_delay, int sync_step, int opt_mask, int thr, int nsample, int delay)
{
    /* reset the optical parts */
    printf("  reset trigger module optics\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_RESET, 0x0);
    usleep(1000);

    /* disable optical channel */
    printf("  disable optical channel\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_ch_dis1, (opt_mask & 0xffff));
    usleep(1000);

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_ch_dis2, ((opt_mask >> 16) & 0xff));
    usleep(1000);

    printf("  reset trigger module pll reset\n");

    /* pll reset */
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_rst_p, sp_L1_s10_rst_pll);
    usleep(1000);

    printf("  reset trigger module stitch transmitter reset\n");

    /* stitch transmitter reset */
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_rst_p, sp_L1_s10_rst_opt_st_t);
    usleep(1000);

    printf("  reset trigger module stitch receiver reset\n");

    /* stitch receiver reset */
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_rst_p, sp_L1_s10_rst_opt_st_r);
    usleep(1000);

    /* transmitter reset */
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_rst_p, sp_L1_s10_rst_opt_out_t);
    usleep(1000);

    printf("  reset test data register\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_reset, 0x0);
    usleep(1000);

    printf("  set phase number (0-15)\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_phasen, sync_step);
    usleep(1000);

    printf("  set align data delay\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_delay, fifo_delay);
    usleep(1000);

    printf("  set threshold\n");

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_thr, thr);
    usleep(1000);

    printf("  set trigger board m_size\n");
    usleep(400000);

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_m_size, nsample - 1);

    printf("  set trigger board m_delay\n");
    usleep(400000);

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_m_delay, delay);

    /* readout from crate controller */
    printf("  set trigger board rstblk, dat2rbdk, dat2link\n");
    usleep(400000);

    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_rstblk, 0x0);
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_dat2rbdk, 0x1);
    _sp_ll1_cmd_int16(pcie, addr_mod, 0, sp_L1_s10_slow_dat2link, 0x0);
    /* end crate controller readout */

    usleep(400000);
}

static void adc_setup(struct pcie_interface_t* pcie, int addr_mod)
{
    int ic;
    int chip;

    /* controller data goes to ADC input section */
    chip = sp_adc_input_sub;

    for (ic=0; ic<8; ic++) {
        printf(" module %2d :  set spi address to channel %2d\r", addr_mod, ic);
        fflush(stdout);

        /* set spi address */
        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_spi_add, ic);

        /* power reset the ADC */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x08, 0x03, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);

        /* remove power reset */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x08, 0x00, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);

        /* reset ADC */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x00, 0x3c, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);

        /* set LVDS termination - set address 0x15 to 1 for 2x drive */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x15, 0x20, 0, 0); // 100 ohms termination
        /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x15, 0x00, 0, 0); // no termination, 1x drive */
        /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x15, 0x01, 0, 0); // no termination, 2x drive */
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);

        /* set fix pattern: 0xa = sync pattern */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x0d, 0xa, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);
    }

    printf(" module %2d :  set spi address to channels [done]\n", addr_mod);

    usleep(100);

    /* set up for ADC alignment */

    /* controller data go to ADC slow control section */
    chip = sp_adc_slowcntl_sub;

    /* /1* pll reset *1/ */
    /* printf(" module %2d :  send pll reset\n", addr_mod); */

    /* _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_pll_reset, 0x0); */
    /* usleep(1000); */

    /* DPA reset */
    printf(" module %2d :  send ADC DPA reset\n", addr_mod);

    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_dpa_reset, 0x0);
    usleep(1000);

    /* upper ADC alignment */
    printf(" module %2d :  send upper channel align\n", addr_mod);

    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_u_adc_align, 0x0);
    usleep(1000);

    /* lower ADC alignment */
    printf(" module %2d :  send lower channel align\n", addr_mod);

    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_l_adc_align, 0x0);
    usleep(1000);

    /* controller data go to ADC input section */
    chip = sp_adc_input_sub;

    for (ic=0; ic<8; ic++) {
        /* set spi address */
        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_spi_add, ic);
        usleep(100);

        /* output offset binary code */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x14, 0x00, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);

        /* unset fix pattern 0x0 for normal data taking --- set to test condition */
        pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300);
        pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x0d, 0x00, 0, 0);
        pcie_send(pcie, _M_DMA, 2);
        usleep(100);
    }

    /* test routine */

    /* /1* set spi address; data argument is channel *1/ */
    /* _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_spi_add, 0); */

    /* /1* remove channels H,G,F,E from the selection list *1/ */
    /* pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300); */
    /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x04, 0x00, 0, 0); */
    /* pcie_send(pcie, _M_DMA, 2); */
    /* usleep(100); */

    /* /1* keep only channel A in the selection list *1/ */
    /* pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300); */
    /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x05, 0x01, 0, 0); */
    /* pcie_send(pcie, _M_DMA, 2); */
    /* usleep(100); */

    /* /1* set fix pattern: 0xa = sync pattern *1/ */
    /* pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300); */
    /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x0d, 0x0c, 0, 0); */
    /* pcie_send(pcie, _M_DMA, 2); */
    /* usleep(100); */

    /* /1* restore selection list 1 *1/ */
    /* pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300); */
    /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x04, 0x0f, 0, 0); */
    /* pcie_send(pcie, _M_DMA, 2); */
    /* usleep(100); */

    /* /1* restore selection list 2 *1/ */
    /* pcie->send.buffer[0] = _SP_ADC_CMD_FMT(addr_mod, chip, sp_adc_spi_data, 0x0300); */
    /* pcie->send.buffer[1] = _SP_ADC_SPI_FMT(0x05, 0x3f, 0, 0); */
    /* pcie_send(pcie, _M_DMA, 2); */
    /* usleep(100); */
}

static void adc_load_testram(struct pcie_interface_t* pcie, int addr_mod, int delay, UINT64 cmask, UINT32* data)
{
    int ic, iclk;
    int chip;
    int offset, width, interval, count;

    UINT32 word;

    /* set data pattern */
    offset = 10;
    interval = 60;
    width = 7;
    count = 6;

    /* set chip */
    /* controller data goes to ADC input section */
    chip = sp_adc_input_sub;

    for (ic=0; ic<64; ic++) {
        /* set channel 0 to 64 */
        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_testram_load_ch, ic ? ic : 64);

        printf(" module %2d :  load testram to channel %2d\r", addr_mod, ic);
        fflush(stdout);

        for (iclk=0; iclk<512; iclk++) {
            word = 0x0000;

            if (cmask & (0x1ULL << ic)) {
                if ((((iclk - offset) % interval) < width) && (((iclk - offset) / interval) < count)) {
                    word = data[ic] & 0x3fff;
                }
            }

            _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_testram_load_data, word);
        }
    }

    printf(" module %2d :  load testram to channels [done]\n", addr_mod);

    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_testram_trig_delay, delay);
}

static void adc_load_lookup_tables(struct pcie_interface_t* pcie, int addr_mod, UINT32* l1_adc_table, UINT32* l1_slewing_table)
{
    int chip;
    int i, ic;

    int trig_rw_delay;

    /* set chip */
    chip = sp_adc_trigproc_sub;

    /* loading the adc correction table for channels 0-63 */
    for (ic=0; ic<64; ic++) {
        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_tbl_chnl, ic);

        printf(" module %2d :  load adc correction table to channel %2d\r", addr_mod, ic);
        fflush(stdout);

        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_lkp_addr, 0);
        _sp_adc_cmd_array(pcie, addr_mod, chip, sp_adc_trig_lkp_data, l1_adc_table, 1024);
    }

    printf(" module %2d :  load adc correction table to channels [done]\n", addr_mod);

    /* loading the slewing correction table */
    for (ic=0; ic<32; ic++) {
        _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_tbl_chnl, ic);

        printf(" module %2d :  load slewing table to channel %2d\r", addr_mod, ic);
        fflush(stdout);

        for (i=0; i<4; i++) {
            _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_mbd_tbl_add, i * 1024);
            _sp_adc_cmd_array(pcie, addr_mod, chip, sp_adc_trig_mbd_tbl_data, &l1_slewing_table[i * 1024], 1024);
        }
    }

    printf(" module %2d :  load slewing table to channels [done]\n", addr_mod);

    /* set trigger subtract delay */
    trig_rw_delay = 6;

    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_sub_delay, trig_rw_delay);

    /* set trigger sample phase 5 */
    _sp_adc_cmd_int16(pcie, addr_mod, chip, sp_adc_trig_smpl_phase, 0x6);
}

static int pcie_init(struct pcie_interface_t* pcie) {
    DWORD dwStatus;

    DWORD dwAddrSpace;
    DWORD dwOffset;
    UINT32 u32Data;

    DWORD dwOptions;
    DWORD dwDMABufSize;

    /* initialize */
    dwAddrSpace = 2;
    dwOffset = 0x28;
    u32Data = 0xf0000008;
    WDC_WriteAddr32(pcie->dev, dwAddrSpace, dwOffset, u32Data);

    dwOptions = DMA_TO_DEVICE;
    dwDMABufSize = 100000;
    dwStatus = WDC_DMAContigBufLock(pcie->dev, (void**)&(pcie->send.buffer), dwOptions, dwDMABufSize, &(pcie->send.pDMA));
    if (WD_STATUS_SUCCESS != dwStatus) {
        printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return 1;
    }

    dwOptions = DMA_FROM_DEVICE;
    dwDMABufSize = 100000;
    dwStatus = WDC_DMAContigBufLock(pcie->dev, (void**)&(pcie->rec.buffer), dwOptions, dwDMABufSize, &(pcie->rec.pDMA));
    if (WD_STATUS_SUCCESS != dwStatus) {
        printf("Failed locking a receive Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return 1;
    }

    return 0;
}

static int pcie_send(struct pcie_interface_t* pcie, int mode, int nword)
{
    /* imode=0: single word transfer, imode=1: DMA */

    WDC_DEVICE_HANDLE dev; 

    DWORD dwAddrSpace;
    DWORD dwOffset;
    UINT32 u32Data;

    int nbytes;
    int i;

    dev = pcie->dev;

    nbytes = nword * sizeof(UINT32);

    switch (mode) {
        case _M_WORD:
            /* setup transmitter */
            dwAddrSpace = 2;
            dwOffset = 0x20;
            u32Data = 0x20000000;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            dwAddrSpace = 2;
            dwOffset = 0x20;
            u32Data = 0x40000000 + nbytes;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            for (i=0; i<nword; ++i) {
                dwAddrSpace = 4;
                dwOffset = 0x0;
                u32Data = pcie->send.buffer[i];
                WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);
            }

            do {
                dwAddrSpace = 2;
                dwOffset = 0xC;
                WDC_ReadAddr32(dev, dwAddrSpace, dwOffset, &u32Data);
            } while(u32Data & 0x80000000);

            return 0;
        case _M_DMA:
            WDC_DMASyncCpu(pcie->send.pDMA);

            /* setup transmitter */
            dwAddrSpace = 2;
            dwOffset = 0x20;
            u32Data = 0x20000000;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            dwAddrSpace = 2;
            dwOffset = 0x20;
            u32Data = 0x40000000 + nbytes;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            /* set up sending DMA starting address */
            dwAddrSpace = 2;
            dwOffset = 0x0;
            u32Data = pcie->send.pDMA->Page->pPhysicalAddr & 0xffffffff;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            dwAddrSpace = 2;
            dwOffset = 0x4;
            u32Data = (pcie->send.pDMA->Page->pPhysicalAddr >> 32) & 0xffffffff;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            /* byte count */
            dwAddrSpace = 2;
            dwOffset = 0x8;
            u32Data = nbytes;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            /* write this to start DMA */
            dwAddrSpace = 2;
            dwOffset = 0xc;
            u32Data = 0x00200000;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            do {
                dwAddrSpace = 2;
                dwOffset = 0xC;
                WDC_ReadAddr32(dev, dwAddrSpace, dwOffset, &u32Data);
            } while(u32Data & 0x80000000);

            WDC_DMASyncIo(pcie->send.pDMA);

            return 0;
    }

    return 1;
}

static int pcie_rec(struct pcie_interface_t* pcie, int state, int nword, UINT32 *buffer)
{
    /* mode=0: single word transfer, mode=1: DMA */
    /* nword assumed to be number of 16-bit words */

    WDC_DEVICE_HANDLE dev;

    DWORD dwAddrSpace;
    DWORD dwOffset;
    UINT32 u32Data;
    UINT64 u64Data;

    int ndata;
    int i;

    dev = pcie->dev;

    /* set up the receiver */
    switch (state) {
        case _S_INIT:
            /* initialize transmitter mode register... */
            dwAddrSpace = 2;
            u32Data = 0xf0000008;
            dwOffset = tx_mode_reg;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            /* initialize the receiver */
            dwAddrSpace = cs_bar;
            dwOffset = r2_cs_reg;
            u32Data = cs_init;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            /* write byte count */
            dwAddrSpace = cs_bar;
            dwOffset = r2_cs_reg;
            u32Data = cs_start + nword * 4;
            WDC_WriteAddr32(dev, dwAddrSpace, dwOffset, u32Data);

            return 0;
        case _S_READ:
            ndata = (nword + 1) / 2;

            for (i=0; i<ndata; i++) {
                dwAddrSpace = t2_tr_bar;
                dwOffset = 0x0;
                WDC_ReadAddr64(dev, dwAddrSpace, dwOffset, &u64Data);

                *buffer++ = u64Data & 0xffffffff;
                *buffer++ = (u64Data >> 32) & 0xffffffff;
            }

            return 0;
    }

    return 1;
}
