/************************************************************************
*  File: pcie_diag.c
*
*  Sample user-mode diagnostics application for accessing JSEB2
*  devices using WinDriver's API.
*  Code was generated by DriverWizard v10.21.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#define _POSIX_C_SOURCE 199309L

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include "wdc_defs.h"
#include "wdc_lib.h"
#include "utils.h"
#include "status_strings.h"
#include "diag_lib.h"
#include "wdc_diag_lib.h"
#include "pci_regs.h"
#include "include/jseb2_lib.h"

/*************************************************************
  General definitions
 *************************************************************/
/* Error messages display */
#define JSEB2_ERR printf

/*************************************************************
  Global variables
 *************************************************************/
/* User's input command */
static CHAR gsInput[256];

/* --------------------------------------------------
    JSEB2 configuration registers information
   -------------------------------------------------- */
/* Configuration registers information array */
const WDC_REG gJSEB2_CfgRegs[] = {
    { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID", "Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID", "Device ID" },
    { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
    { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
    { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD", "Revision ID & Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC", "Sub Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC", "Base Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN", "Cache Line Size" },
    { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT", "Latency Timer" },
    { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR", "Header Type" },
    { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST", "Built-in Self Test" },
    { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0", "Base Address 0" },
    { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1", "Base Address 1" },
    { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2", "Base Address 2" },
    { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3", "Base Address 3" },
    { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4", "Base Address 4" },
    { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5", "Base Address 5" },
    { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS", "CardBus CIS Pointer" },
    { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID", "Sub-system Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID", "Sub-system Device ID" },
    { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM", "Expansion ROM Base Address" },
    { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP", "New Capabilities Pointer" },
    { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN", "Interrupt Line" },
    { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN", "Interrupt Pin" },
    { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT", "Minimum Required Burst Period" },
    { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT", "Maximum Latency" },
    };
#define JSEB2_CFG_REGS_NUM sizeof(gJSEB2_CfgRegs) / sizeof(WDC_REG)
/* TODO: For read-only or write-only registers, change the direction field of
         the relevant registers in gJSEB2_CfgRegs to WDC_READ or WDC_WRITE. */
/* NOTE: You can define additional configuration registers in gJSEB2_CfgRegs. */
const WDC_REG *gpJSEB2_CfgRegs = gJSEB2_CfgRegs;

/* -----------------------------------------------
    JSEB2 run-time registers information
   ----------------------------------------------- */
/* Run-time registers information array */
/* const WDC_REG gJSEB2_Regs[]; */
const WDC_REG *gpJSEB2_Regs = NULL;
/* TODO: You can remove the comment from the gJSEB2_Regs array declaration and
         fill the array with run-time registers information for your device,
         in which case be sure to set gpJSEB2_Regs to point to gJSEB2_Regs. */
#define JSEB2_REGS_NUM 0

/*************************************************************
  Static functions prototypes
 *************************************************************/
/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2);

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev);
static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace);

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
/* static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev); */

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev);
//static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, JSEB2_INT_RESULT *pIntResult);
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, JSEB2_INT_RESULT *pIntResult);

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
static void MenuEvents(WDC_DEVICE_HANDLE hDev);
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction);
static void Menujsebii_test(WDC_DEVICE_HANDLE hDev);
static void MenuADCtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev1, WDC_DEVICE_HANDLE hDev2);
static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_send_6_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_send_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_rec_16b(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_6_1(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_6_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit);
static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem);
static int dcm2_fpga_boot(WDC_DEVICE_HANDLE hDev, int imod, int fpga_t);
static int dcm2_fpga_boot_n(WDC_DEVICE_HANDLE hDev, int imod, int fpga_t);
static int adc_setup(WDC_DEVICE_HANDLE hDev, int imod, int iprint);
static int adc_setup_bebug(WDC_DEVICE_HANDLE hDev, int imod, int iprint);
static int adc_testram_load(WDC_DEVICE_HANDLE hDev, int imod, int iprint);
static int eprom_readback(WDC_DEVICE_HANDLE hDev, int imod, int mode, UINT32 *buff_rec);
static int adc_testram_trig_load(WDC_DEVICE_HANDLE hDev, int imod, int idelay);
static int adc_testram_trig_load_1(WDC_DEVICE_HANDLE hDev, int imod, int idelay, int ipattern, int iph);
static int adc_testram_trig_load_mbd(WDC_DEVICE_HANDLE hDev, int imod, int idelay, int ipattern, int iph, int iph1);
static int trigger_board_setup(WDC_DEVICE_HANDLE hDev, int imod, int delay, int sync_step, int opt_mask, int ithr);
static int trigger_sort(int *sum1, int *sum2, int *add1, int *add2, int *out_sum, int *out_add);


/*************************************************************
  Functions implementation
 *************************************************************/
int main(void)
{

  struct timeval start;
  gettimeofday(&start,NULL);

  long seconds, useconds;
  seconds = start.tv_sec;
  useconds = start.tv_usec;
      
  printf("\nStart time of program: %ld sec %ld usec\n",seconds,useconds);


    WDC_DEVICE_HANDLE hDev = NULL;
    WDC_DEVICE_HANDLE hDev1 = NULL;
    WDC_DEVICE_HANDLE hDev2 = NULL;

    DWORD dwStatus;

    printf("\n");
    printf("JSEB2 diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the JSEB2 library */
    dwStatus = JSEB2_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("pcie_diag: Failed to initialize the JSEB2 library: %s",
            JSEB2_GetLastErr());
        return dwStatus;
    }

    /* Find and open a JSEB2 device (by default ID) */
    if (JSEB2_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(JSEB2_DEFAULT_VENDOR_ID, JSEB2_DEFAULT_DEVICE_ID);
    if (JSEB2_DEFAULT_VENDOR_ID)
        hDev1 = DeviceFindAndOpen(JSEB2_DEFAULT_VENDOR_ID, JSEB2_DEFAULT_DEVICE_ID+1);
    if (JSEB2_DEFAULT_VENDOR_ID)
        hDev2 = DeviceFindAndOpen(JSEB2_DEFAULT_VENDOR_ID, JSEB2_DEFAULT_DEVICE_ID+2);

    /* Display main diagnostics menu for communicating with the device */
    MenuMain(&hDev, &hDev1, &hDev2);

    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);
    if (hDev1)
        DeviceClose(hDev1);
    if (hDev2)
        DeviceClose(hDev2);

    dwStatus = JSEB2_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        JSEB2_ERR("pcie_diag: Failed to uninit the JSEB2 library: %s", JSEB2_GetLastErr());
    
    return dwStatus;
}

/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
/* Main menu options */
enum {
    MENU_MAIN_SCAN_PCI_BUS = 1,
    MENU_MAIN_FIND_AND_OPEN,
    MENU_MAIN_RW_ADDR,
    MENU_MAIN_RW_CFG_SPACE,
    MENU_MAIN_RW_REGS,
    MENU_MAIN_ENABLE_DISABLE_INT,
    MENU_MAIN_EVENTS,
    MENU_MAIN_MB_TEST, /* add new route for testing */
    MENU_MAIN_JSEB2_TEST, /* add new route for testing */
    MENU_MAIN_EXIT = DIAG_EXIT_MENU,
};

/* Main diagnostics menu */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1 ,WDC_DEVICE_HANDLE *phDev2)
{
    DWORD option;
    
    do
    {
        printf("\n");
        printf("JSEB2 main menu\n");
        printf("--------------\n");
        printf("%d. Scan PCI bus\n", MENU_MAIN_SCAN_PCI_BUS);
        printf("%d. Find and open a JSEB2 device\n", MENU_MAIN_FIND_AND_OPEN);
        if (*phDev)
        {
            printf("%d. Read/write memory and IO addresses on the device\n",
                MENU_MAIN_RW_ADDR);
            printf("%d. Read/write the device's configuration space\n",
                MENU_MAIN_RW_CFG_SPACE);
            if (JSEB2_REGS_NUM)
            {
                printf("%d. Read/write the run-time registers\n",
                    MENU_MAIN_RW_REGS);
            }
            printf("%d. Enable/disable the device's interrupts\n",
                MENU_MAIN_ENABLE_DISABLE_INT);
            printf("%d. Register/unregister plug-and-play and power management "
                "events\n", MENU_MAIN_EVENTS);
            printf("%d. MicroBoone test\n", MENU_MAIN_MB_TEST);
            printf("%d. Test loop for PCIe\n", MENU_MAIN_JSEB2_TEST);
        }
        printf("%d. Exit\n", MENU_MAIN_EXIT);

	/**        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_EVENTS : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }
	**/

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_JSEB2_TEST : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }

        switch (option)
        {
        case MENU_MAIN_EXIT: /* Exit menu */
            break;
        case MENU_MAIN_SCAN_PCI_BUS: /* Scan PCI bus */
            WDC_DIAG_PciDevicesInfoPrintAll(FALSE);
            break;
        case MENU_MAIN_FIND_AND_OPEN: /* Find and open a JSEB2 device */
            if (*phDev)
                DeviceClose(*phDev);
            *phDev = DeviceFindAndOpen(0, 0);
            break;
        case MENU_MAIN_RW_ADDR: /* Read/write memory and I/O addresses */
            MenuReadWriteAddr(*phDev);
            break;
        case MENU_MAIN_RW_CFG_SPACE: /* Read/Write the JSEB2 configuration space */
            /* MenuReadWriteCfgSpace(*phDev); */
            break;
        case MENU_MAIN_RW_REGS: /* Read/write the run-time registers */
            /* if (JSEB2_REGS_NUM) */
            /*     MenuReadWriteRegs(*phDev); */
            /* else */
            /*     printf("Invalid selection\n"); */
            break;
        case MENU_MAIN_ENABLE_DISABLE_INT: /* Enable/disable interrupts */
            MenuInterrupts(*phDev);
            break;
        case MENU_MAIN_EVENTS: /* Register/unregister plug-and-play and power management events */
            MenuEvents(*phDev);
            break;
        case MENU_MAIN_MB_TEST: /* my test loop DMA */
            MenuADCtest(*phDev, *phDev1, *phDev2);
            break;
        case MENU_MAIN_JSEB2_TEST: /* my test loop DMA */
            Menujsebii_test(*phDev);
            break;
        }
    } while (MENU_MAIN_EXIT != option);
}

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
/* Find and open a JSEB2 device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
    WD_PCI_SLOT slot;
    
    if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
        return NULL;

    return DeviceOpen(&slot);
}

/* Find a JSEB2 device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if (dwVendorId == 0)
    {
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
            "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
            "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("DeviceFind: Failed scanning the PCI bus.\n"
            "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        JSEB2_ERR("No matching device was found for search criteria "
            "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
            dwVendorId, dwDeviceId);

        return FALSE;
    }
    
    printf("\n");
    printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
        dwNumDevices, dwNumDevices > 1 ? "s" : "",
        dwVendorId, dwVendorId ? "" : " (ALL)",
        dwDeviceId, dwDeviceId ? "" : " (ALL)");

    for (i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
            i + 1,
            scanResult.deviceId[i].dwVendorId,
            scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
    printf("\n");

    if (dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i,
            gsInput, FALSE, 1, dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

/* Open a handle to a JSEB2 device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;

    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        JSEB2_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
            "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = JSEB2_DeviceOpen(&deviceInfo);
    if (!hDev)
    {
        JSEB2_ERR("DeviceOpen: Failed opening a handle to the device: %s",
            JSEB2_GetLastErr());
        return NULL;
    }

    return hDev;
}

/* Close handle to a JSEB2 device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if (!hDev)
        return;

    if (!JSEB2_DeviceClose(hDev))
    {
        JSEB2_ERR("DeviceClose: Failed closing JSEB2 device: %s",
            JSEB2_GetLastErr());
    }
}



/* Read/write memory or I/O space address menu */
static void MenuADCtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev1, WDC_DEVICE_HANDLE hDev2)
{

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define dcm2_cal_thresh1_add 55
#define dcm2_cal_thresh2_add 56
#define dcm2_cal_thresh1_data 57
#define dcm2_cal_thresh2_data 58
#define dcm2_cal_thresh1_write 59
#define dcm2_cal_thresh2_write 60
#define dcm2_cal_nfem1 61
#define dcm2_cal_nfem2 62
#define dcm2_cal_nsmpl1 63
#define dcm2_cal_nsmpl2 64
#define dcm2_cal_nfem_pass1 65
#define dcm2_cal_nfem_pass2 66

#define dcm2_n_cal_fst 0x80000000
#define dcm2_n_cal_p_head 0x90000000
#define dcm2_n_cal_fem_head 0xa0000000
#define dcm2_n_cal_smpl 0x30000000
#define dcm2_n_cal_lst 0x20000000
#define dcm2_n_cal_chnl 0x10000000



#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  adc_cntrl_int 0x0
#define  adc_cntrl_loopback_on 0x1
#define  adc_cntrl_loopback_off 0x2
#define  adc_cntrl_offline 0x3
#define  adc_cntrl_online 0x4


#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6
#define  mb_trig_enable             7

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_g1_allow_min      36
#define  mb_trig_g1_allow_max      37
#define  mb_trig_g2_allow_min      38
#define  mb_trig_g2_allow_max      39

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_g1_width          45
#define  mb_trig_g2_width          46

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58
#define  mb_trig_output_select     59

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_trig_frame_trig        63
#define  mb_trig_rd_counter        70

#define  mb_gate_fake_sel          80
#define  mb_fake_gate_width        47
#define  mb_scaler_out_sel_0       81
#define  mb_scaler_out_sel_1       82

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49
#define  mb_feb_pmt_trig_delay     87

#define  mb_feb_pmt_gate1_size     88
#define  mb_feb_pmt_beam1_delay    89
#define  mb_feb_pmt_beam1_size     90
#define  mb_feb_pmt_trig1_delay    91

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  mb_version               254

#define  sp_cntrl_sub               2
#define  sp_cntrl_timing            3 
#define  sp_cntrl_busyrst           4
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22

#define  sp_cntrl_loopback_on       1
#define  sp_cntrl_loopback_off      2
#define  sp_cntrl_offline           3
#define  sp_cntrl_online            4
#define  sp_cntrl_isprst_on         5
#define  sp_cntrl_isprst_off        6
#define  sp_cntrl_seldisc_off       0
#define  sp_cntrl_seldisc_on        7
#define  sp_cntrl_seldisc_add      31

#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#define  sp_adc_readback_trig       4
#
#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1
#define  sp_adc_trigproc_sub        5
#define  sp_adc_trigopt_sub         7

#define  sp_adc_trigopt_fake        1

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_link_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_testram_load_ch     4
#define  sp_adc_testram_load_data   5
#define  sp_adc_testram_trig_delay  7


#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_adc_sel_caltrig        33

#define  sp_adc_calib_dac         100
#define  sp_adc_calib_ch          101
#define  sp_adc_calib_write       102
#define  sp_adc_calib_send        103
#define  sp_adc_calib_gate        104

#define  sp_adc_eprom_addr_l       50
#define  sp_adc_eprom_addr_h       51
#define  sp_adc_eprom_wdata        52
#define  sp_adc_eprom_w_pulse      53
#define  sp_adc_eprom_read_pulse   54
#define  sp_adc_eprom_bulk_erase_p 55
#define  sp_adc_eprom_read_status_p  56
#define  sp_adc_eprom_read_id_p    57
#define  sp_adc_eprom_reset_p      58
#define  sp_adc_eprom_sector_protect_p  59
#define  sp_adc_eprom_erase_sector 68

#define  sp_adc_update_data_in_l   60
#define  sp_adc_update_data_in_h   61
#define  sp_adc_update_reset_timer 62
#define  sp_adc_update_write_param 63
#define  sp_adc_update_reconfig    64
#define  sp_adc_update_param       65
#define  sp_adc_update_reset       66

#define  sp_adc_trig_sub_delay      1
#define  sp_adc_trig_tbl_chnl       2
#define  sp_adc_trig_lkp_addr       3
#define  sp_adc_trig_lkp_data       4
#define  sp_adc_trig_smpl_phase     5
#define  sp_adc_trig_smpl_phase     5
#define  sp_adc_trig_read_delay     6
#define  sp_adc_trig_read_size      7
#define  sp_adc_trig_lkp_write     10
#define  sp_adc_trig_mbd_tbl_add   11
#define  sp_adc_trig_mbd_tbl_data  12      

#define  sp_adc_fake_gtm_init     210
#define  sp_adc_fake_gtm_l1       211
#define  sp_adc_fake_gtm_reset    212


#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1
#define  sp_xmit_rxbytord          15

#define  sp_mbd_disc_led           10
#define  sp_mbd_disc_charge_dac     4
#define  sp_mbd_disc_pulse_even     6
#define  sp_mbd_disc_pulse_odd      5
#define  sp_mbd_disc_disc_dac       1

#define  sp_mbd_clk_pulse           1
#define  sp_mbd_clk_delay_off       0
#define  sp_mbd_clk_delay_on        2
#define  sp_mbd_clk_busy_reset      3
#define  sp_mbd_clk_delay_setting   6
#define  sp_mbd_clk_add            22

#define   sp_L1trig_test_slow        1
#define   sp_L1trig_test_tp1_mask    2
#define   sp_L1trig_test_tp2_mask    3
#define   sp_L1trig_test_status      4

#define   sp_l1trig_test_ic2_wr     22
#define   sp_l1trig_test_i2c_rd     23

#define   sp_L1trig_test_fk_data     0x40


#define  sp_L1trig_test_rst         1
#define  sp_L1trig_test_reset       2
#define  sp_L1trig_test_arst        3
#define  sp_L1trig_test_drst        4
#define  sp_L1trig_test_clr         5
#define  sp_L1trig_test_RESET       6

#define  sp_L1trig_test_tp1_byclk   1
#define  sp_L1trig_test_tp1_rst     2
#define  sp_L1trig_test_tp1_arset   4
#define  sp_L1trig_test_tp1_drst    8
#define  sp_L1trig_test_tp1_clr    16
#define  sp_L1trig_test_tp1_RESET  32

#define  sp_L1_s10_slow_chip_id     0

#define  sp_L1_s10_slow_thr         6
#define  sp_L1_s10_slow_reset       7
#define  sp_L1_s10_slow_en0         8
#define  sp_L1_s10_slow_en1         9
#define  sp_L1_s10_slow_test       12
#define  sp_L1_s10_slow_delay      13
#define  sp_L1_s10_slow_phasen     14
#define  sp_L1_s10_slow_rst_p      15
#define  sp_L1_s10_slow_RESET      16
#define  sp_L1_s10_slow_monitor_p  20
#define  sp_L1_s10_slow_ch_dis1    21
#define  sp_L1_s10_slow_ch_dis2    22

#define  sp_L1_s10_slow_m_size     23
#define  sp_L1_s10_slow_m_delay    24
#define  sp_L1_s10_slow_rstblk     25

#define  sp_L1_s10_slow_dat2link   26
#define  sp_L1_s10_slow_dat2rbdk   27

#define  sp_L1_s10_rst_pll          1
#define  sp_L1_s10_rst_opt_fem      2
#define  sp_L1_s10_rst_opt_st_t     3
#define  sp_L1_s10_rst_opt_st_r     5
#define  sp_L1_s10_rst_opt_out_t    6

#define  sp_L1_s10_slow_mbd_h_read  31
#define  sp_L1_s10_slow_mbd_o_read  32
#define  sp_L1_s10_slow_mbd_data_read  33
#define  sp_L1_s10_slow_mbd_data_sel   29

#define  sp_L1_s10_slow_mbd_m_data_transfer  34
#define  sp_L1_s10_slow_mbd_m_data_read      35

#define  dma_buffer_size        10000000

    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
    static unsigned long long u64Data, u64Data1;
    static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000],read_array[dma_buffer_size],read_array1[40000];
    static UINT32 read_array_c[40000];
    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
    unsigned short idcm_read_array[40000],read_array_s[1600000],send_data_array[10000];
    static UINT32 idcm_read_array32[40000];
    static UINT32 idcm_send_array[400000];
    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff;
    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
    UINT32 *read_array_c_p, *read_array1_p;
    DWORD dwDMABufSize;
    PVOID pbuf;
    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,iframe,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_xmit,idiv,isample, isel_xmit, isel_dcm;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint,ifem_fst,ifem_lst,ifem_loop,imod_fem;
    static int   pmt_deadtime,pmt_mich_window, imod_dcm;
    static int   oframe,osample,odiv,cframe,csample,cdiv;
    static int   idac_shaper, pmt_dac_scan,pmt_precount, ichoice;
    static int   inewcode, p1_delay, p1_width, pulse_trig_delay;
    static int   p2_delay,p2_width,itrig_pulse,p3_delay,p3_width;
    static int   ich, nfem, nsample, adc_data[64][40],l1_delay;
    static int   conf_add,conf_data, iext_trig, igen, ioffset_t;
    static int   imod_start, imod_end, nmod, iparity, itest_ram;
    static int   nstep, nstep_event, ipattern, nstep_dac, idac_shaper_load;
    static int   dac_start, trig_rw_delay;
    static int   trig_lookup[64][1024],itrig_lk_data ;
    static int   fake_data_array[64][512], fake_data_array_sub[64][512];
    static int   fake_data_array_sub_lk[64][512];
    static int   fake_data_array_sub_lk_sum[16][512];
    static int   fake_data_trig_out[16][100], ntrig_w, ntrig_st;
    static int   trig_smp_data[16][100];
    static int   nsector, read_eprom_array[1000], write_eprom_array[1000];
    static int   addr_w;
    static int   mbd_delay_setting, itp_scan, nstep_tp;
    static int   iad,idata,ibin;
    static int   i2c_mod_add,i2c_add,i2c_read,i2c_write;
    static int   itest_pattern, itest_even, itest_odd, test_pulse_d;
    static int   imod_disc, idisc_ch, idisc_dac, idisc_thr,idac_scan;
    static int   nsample_trig, ndelay_trig, ifix_dac;
    static int   fake_pulse[10] = {0x1ff, 0xfff, 0x1fff, 0x2fff, 0x1fff, 0xfff, 0x1ff, 0x0, 0x0, 0x0};
    static int   ifake_start,ifake_width;
    static int   iprint_event, imod_timing;
    static int   ierr_event, event_err_count, data_err_count, error_count;
    static int   locked1, locked2, locked3, locked4a, locked4b;
    static int   err_cor_cnt, err_det_cnt, err_fat_cnt;
    static int   ndisc_mod, ndisc_mod_add[10];
    static int   istart_beg, imod_trg, itrig_chip;
    static int   test_data_array[8][48], test_data_array_1[11][48], test_data_sum[10][47], ks[10][47];
    static int   test_data_sum_1[8][47], test_data_peak_valid[8][48], test_data_peak_sum[8][48];
    static int   peak16_v[8][3][4], peak16_sum[8][3][4],peak16_nhit[8][3];
    static int   peak48_add_out[8][4], peak48_sum_out[8][4], peak48_nhit[8];
    static int   imod_calib, itest_p, npass;
    static int   ntrig_mod, ntrig_chip, trig_fifo_delay, sync_step, opt_mask, ntrig_thr;
    static int   step_size, l1_slewing_table[4096], l1_adc_table[1024];
    static int   out_sum_1[4][8], out_add_1[4][8], out_sum_2[2][8], out_add_2[2][8];
    static int   sort_sum[4][4], sort_add[4][4];
    static int   is1,is2, index1, is2_ch, is2_smpl, is2_mod, mbd_delay_loop;
    static int   module_word, packet_word, xmit_word, frame_word;
    static int   ig, ig_ch, ig_smpl, ig_i, ig_h, ig_lst, adc_ch[100];
    static int   mbd_test_data[24][16];
    static int   L1trig_m_nsample, L1trig_m_delay,nread_trig, L1trig_m_readmethod;
    static int   trig_data_array[4][16][32];
    static int   ja,jb,jc,ka;
    static int   icomp, adc_up[4][64][12],adc_up_clk[4], adc_up_evt[4],error_up;
// 1st arg -- fiber number, 2nd arg position, 3rd arg nsample
    static float temp;

    unsigned char    charchannel;
    unsigned char    carray[40000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
//    tim.tv_nsec =128000;
    tim.tv_nsec =172000;


    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    /* DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE; */
    DWORD dwOptions_send = DMA_TO_DEVICE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;

    static UINT64 *buffp_rec64;
    static UINT32 *buffp_rec32;
    UINT32 *px, *py, *py1;

    FILE *outf,*inpf;




    nread = 4096*2+6; /*16384 32768, 65536+4;  number of byte to be readout */
    ifr=0;
    iwrite =0;
    iprint =0;
    icheck =0;
    istop=0;

    printf("Input the command code for test......\n");
    printf("     (1) controller test...");
    printf("     (2) boot FPGA 1-4 \n");
    printf("     (3) loop back test \n");
    printf("     (4) sphenix ADC test with rev0 fpga code\n");
    printf("     (5) MB controller output test \n");
    printf("     (6) MB FEM booting \n");
    printf("     (7) EPROM testing routine \n");
    printf("     (8) Fake data read - test 2 \n");
    printf("     (9) ADC basic testing \n");
    printf("     (10) controller loopback test \n");
    printf("     (11) new crate controller test code \n");
    printf("     (12) BNL ADC testing \n");
    printf("     (14) MBD indiviual test routine  \n");
    printf("     (15) 2 FEM and XMIT test  \n");
    printf("     (16) MBD single module test routine \n");
    printf("     (17) shapper baord test \n");
    printf("     (18) quick ADC calibration routine \n");
    printf("     (19) sphenix trigger test routine \n");
    printf("     (20) BNL chian test routine \n");
    printf("     (21) multiple discriminator module test routine \n");
    printf("     (22) sphenix trigger test routine --- upper and lower chips \n");
    printf("     (23) clibration module signal injection FEM to LL1 test\n");
    printf("     (24) FEM fake data to LL1 test \n");
    printf("     (25) FEM fake data to LL1 test with pattern\n");
    printf("     (26) multiple ADC module test \n");
    printf("     (29) sphenix calorimeter zero suppression offline test\n");
    printf("     (30) sphenix ADC test with rev1 fpga code and DCM test code\n");
    printf("     (31) Sphenix XMIT reprogram code \n");
    printf("     (32) MBD trigger module test code \n");

    scanf("%d",&newcmd);
    switch(newcmd) {


    case 1:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" type 1 to use xmit module \n");
     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
//
//
//
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     if(ipulse !=0) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     } 
/*
     printf(" enter number of word per packet\n");
     scanf("%d",&nsend);
     printf(" enter 1 for loopback check\n");
     scanf("%d",&ireadback);
     printf(" type 1 to use new PCie FPGA code \n");
     scanf("%d",&inew);
     if(ireadback == 1) {
       printf(" enter 1 for readback in DCM mode\n");
       scanf("%d",&idma_readback);
     }


     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
     printf(" scope loop test \n");
*/
/*
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev, &pbuf, dwOptions, dwDMABufSize, &pDma);
    if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a receive Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
*/

     px = &buf_send;
     py = &read_array;
     imod =6;
     imod_xmit = 7;
     ichip=6;
     nsample = 12;
     if(isel_dcm ==1) {
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev,11,1);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev,11,2);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      imod_dcm=11;
      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
       ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//     for (j=0; j<10000000; j++)  {
//      ichip = sp_adc_slowcntl_sub;
//      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + (0xffff<<16) ;
//      buf_send[1]= 0x5555aaaa;
//      i= 1;
//      k= 2;
//      i = pcie_send_1(hDev, i, k, px);
//      usleep(100);
//     }

//

//#define  sp_cntrl_init           0x30
//#define  sp_cntrl_reset           0x28
//#define  sp_cntrl_l1              0x24
     printf(" type 1 to send init \n");
     scanf("%d",&is);
//
//
//#define  sp_xmit_lastmod            1
//#define  sp_xmit_rxanalogreset      2
//#define  sp_xmit_rxdigitalreset     3
//#define  sp_xmit_init               4

//#define  sp_smit_sub
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);
     }


//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set L1 delay  -- to 100
//
     printf(" type 1 to set L1 delay \n");
     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
     printf(" buf_send = %x\n", buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set select L1 trigger on
//
     printf(" type 1 to select L1 trigger \n");
     scanf("%d",&is);
     if(ipulse != 0 ) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set up complete type 1 to continue \n");
     scanf("%d",&is);

//#define  sp_adc_l1_delay            1
//#define  sp_adc_evt_sample          2

//#define  sp_adc_rd_link             3
//#define  sp_adc_rd_cntrl            4

//#define  sp_adc_sel_l1              5
//#define  sp_adc_sel_pulse           6
//#define  sp_adc_sel_test_trig       7

     for (j=0; j<nloop; j++) {
      ichip = sp_adc_input_sub ;   // controller data go to ADC input section
      for (ich=0; ich<8; ich++) {

//    set spi address

       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       printf(" type 1 to continue ich= %d \n", ich);
//       scanf("%d",&is);

//      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_)+((is & 0xf)<<16); //set spi address
//      i=1;
//        k=1;
//        i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
//        ichip=5;
//
//     reset ADC
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
//
//       if(ich ==7) {
        printf(" type 1 to continue -- send last command ich= %d \n", ich);
//        scanf("%d",&is);
//       }
//
//    set LVDS termination  set addess 0x15  to 0x30 100 ohms termination
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<12)+(0x15))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x15, data =0x1;
//
       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us

//
//    set fix pattern  0xa = sync pattern
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xa;
//

       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
//
//       printf(" type 1 to continue \n");
//       scanf("%d",&is);
      }


      for (k=0; k<1000000; k++) {
       ik=k+1;
       i=ik*ik;
      }
//
//    set up for ADC alignment
//
      ichip = sp_adc_slowcntl_sub ;   // controller data go to ADC input section
//
//       pll reset
//
      printf(" type 1 to send pll reset\n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_pll_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);

//
//       DPA reset
//
      printf(" type 1 to send ADC DPA reset\n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_dpa_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);

//
//       upper ADC alignment
//
      printf(" type 1 to send upper channel align \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_u_adc_align + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//
//       lower ADC alignment
//
      printf(" type 1 to send lower channel align \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l_adc_align + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//
//
//

     ichip = sp_adc_input_sub ;   // controller data go to ADC input section
     for (ich=0; ich<8; ich++) {
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);
//
//    output offset binary code
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<12)+(0x14))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x14, data =0x0;
//

       i=1;
       k=2;

       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us

//
//    unset fix pattern  0x0 for normal data taking   --- set to test condition
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0x0;
//

       i=1;
       k=2;

       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
     }


//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       printf(" header 1 = %x\n", read_array[0]);
       printf(" header 2 = %x\n", read_array[1]);
       printf(" header 3 = %x\n", read_array[2]);
       printf(" header word = %x\n", (read_array[0]& 0xffff));
       printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
       iread = read_array[2] & 0xffff;
       printf(" word count = %x\n", iread);
       printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
       scanf("%d", &i );
//
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        if(i%8 == 0) printf("%3d",i);
        printf(" %9x",u32Data);
        if(i%8 == 7) printf("\n");
       }
       scanf("%d", &i );
       for (is=0; is<nsample; is++) {
        for (k=0; k<32; k++) {
         adc_data[k*2][is] = read_array[7+((k*nsample+is)*2)] & 0xffff;
         adc_data[(k*2)+1][is] = read_array[6+((k*nsample+is)*2)] & 0xffff;
        }
       }
       for (is=0; is<64; is++) {
       printf(" channel %d ", is);
       for (k=0; k<nsample; k++) {
        printf(" %4x", adc_data[is][k]);
       }
        printf("\n");
       }
       scanf("%d", &i );
      }


//
//
      ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
//
      if(iwrite != 1) {
       printf(" type 1 to send the transfer \n");
       scanf("%d",&is);
      }
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
//
      nread =2+(64*nsample/2)+1;
      i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

      if(iwrite != 1) {
       printf(" type 1 to send the read \n");
       scanf("%d",&is);
      }
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
      i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
      if (iwrite == 1) {
       fprintf(outf," %x\n", read_array[0]);
       fprintf(outf," %x\n", read_array[1]);
      }
      else {
       printf(" header 1 = %x\n", read_array[0]);
       printf(" header 2 = %x\n", read_array[1]);
      }

      k=0;
      for (is=0; is< (nread-2); is++) {
       if(iwrite == 1) {
        fprintf(outf," %8X", read_array[is+2]);
       }
       else {
        if(is%8 ==0) printf(" %d ", is);
        printf(" %x", read_array[is+2]);
       }
       k=k+1;
       if(iwrite == 1) {
        if((k%8) ==0) fprintf(outf,"\n");
       }
       else {
        if((k%8) ==0) printf("\n");
       }
      }
      if(iwrite == 1) fprintf(outf,"\n");
      else printf("\n");

      if(iwrite != 1) {
       for (is=0; is< nsample; is++ ) {
        for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
         adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
         adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
        }
       }


       for (is=0; is<64; is++) {
       printf(" channel %d ", is);
       for (k=0; k<nsample; k++) {
        printf(" %4x", adc_data[is][k]);
       }
        printf("\n");
       }
      }


      if(iwrite != 1) {
        printf(" type 1 to continue \n");
        scanf("%d",&is);
      }
     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//

     }
     break;

    case 2:
//     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
//     printf(" type 1 to write data to file \n");
//     scanf("%d",&iwrite);
//     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
     iwrite = 0;
//
//
//
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     if(ipulse !=0) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }
/*
     printf(" enter number of word per packet\n");
     scanf("%d",&nsend);
     printf(" enter 1 for loopback check\n");
     scanf("%d",&ireadback);
     printf(" type 1 to use new PCie FPGA code \n");
     scanf("%d",&inew);
     if(ireadback == 1) {
       printf(" enter 1 for readback in DCM mode\n");
       scanf("%d",&idma_readback);
     }


     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
     printf(" scope loop test \n");
*/
/*
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev, &pbuf, dwOptions, dwDMABufSize, &pDma);
    if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a receive Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
*/
     px = &buf_send;
     py = &read_array;
     imod =18;
     ichip=6;
     nsample = 12;
//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
       ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//     for (j=0; j<10000000; j++)  {
//      ichip = sp_adc_slowcntl_sub;
//      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + (0xffff<<16) ;
//      buf_send[1]= 0x5555aaaa;
//      i= 1;
//      k= 2;
//      i = pcie_send_1(hDev, i, k, px);
//      usleep(100);
//     }

//

//#define  sp_cntrl_init           0x30
//#define  sp_cntrl_reset           0x28
//#define  sp_cntrl_l1              0x24
     printf(" type 1 to send init \n");
     scanf("%d",&is);

//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);

//#define  sp_adc_link_conf_w        27
//#define  sp_adc_link_conf_add     30
//#define  sp_adc_link_conf_data_l    31
//#define  sp_adc_link_conf_data_u    32

     imod = 15;
//
//
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_mgmt_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
     for (ijk=0; ijk <10000; ijk++) {
      printf(" enter configuration address 0 to change module address -- module address %d\n", imod);
      scanf("%d",&conf_add);
      if(conf_add == 0) {
        printf(" enter the new module address \n");
        scanf("%d", &imod);
      }
      else {
       printf(" enter configuration data \n");
       scanf("%d",&conf_data);
       ichip = sp_adc_slowcntl_sub;
       k= conf_data & 0xffff;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_conf_data_l+ (k<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
       k= conf_data >> 16;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_conf_data_u+ (k<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_conf_add+ (conf_add<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_conf_w+ (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
      }
     }






     imod = 17;
//#define  sp_adc_link_mgmt_reset    26
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_mgmt_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10); 
     imod = 18;
//#define  sp_adc_link_mgmt_reset    26
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_link_mgmt_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//
//
     imod_start = 17;
     imod_end =18;

     for (imod=imod_start; imod<(imod_end+1); imod++) {

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" type 1 to set L1 delay, mod = %d \n", imod);
      scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
      if(ipulse != 0 ) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set up complete type 1 to continue \n");
      scanf("%d",&is);
//
//   reset link transmitter interface
//
      printf(" type 1 to reset link tx analog and digital interface module number =%d \n", imod);
      scanf("%d",&is);
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_lnk_tx_areset + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_lnk_tx_dreset + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   reset link receiver interface
//
      printf(" type 1 to reset link tx analog and digital interface  module number =%d \n", imod);
      scanf("%d",&is);
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_lnk_rx_areset + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_lnk_rx_dreset + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);




//#define  sp_adc_lnk_tx_dreset      20
//#define  sp_adc_lnk_tx_areset      21
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
//#define  sp_adc_lnk_tx_dreset      24
//#define  sp_adc_lnk_tx_areset      25

//#define  sp_adc_l1_delay            1
//#define  sp_adc_evt_sample          2

//#define  sp_adc_rd_link             3
//#define  sp_adc_rd_cntrl            4

//#define  sp_adc_sel_l1              5
//#define  sp_adc_sel_pulse           6
//#define  sp_adc_sel_test_trig       7


      ichip = sp_adc_input_sub ;   // controller data go to ADC input section
      for (ich=0; ich<8; ich++) {

//    set spi address

       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       printf(" type 1 to continue ich= %d \n", ich);
//       scanf("%d",&is);

//      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_)+((is & 0xf)<<16); //set spi address
//      i=1;
//        k=1;
//        i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
//        ichip=5;
//
//     reset ADC
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
//
//       if(ich ==7) {
        printf(" type 1 to continue -- send last command ich= %d \n", ich);
//        scanf("%d",&is);
//       }

//
//    set fix pattern  0xa = sync pattern
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xa;
//

       i=1;
       k=2;
//       i = pcie_send(hDev, i, k, px);
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
//
//       printf(" type 1 to continue \n");
//       scanf("%d",&is);
      }


      for (k=0; k<1000000; k++) {
       ik=k+1;
       i=ik*ik;
      }
//
//    set up for ADC alignment
//
      ichip = sp_adc_slowcntl_sub ;   // controller data go to ADC input section
//
//       pll reset
//
      printf(" type 1 to send pll reset\n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_pll_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);

//
//       DPA reset
//
      printf(" type 1 to send ADC DPA reset\n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_dpa_reset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);

//
//       upper ADC alignment
//
      printf(" type 1 to send upper channel align \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_u_adc_align + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//
//       lower ADC alignment
//
      printf(" type 1 to send lower channel align \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l_adc_align + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//
//
//

      ichip = sp_adc_input_sub ;   // controller data go to ADC input section
      for (ich=0; ich<8; ich++) {
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);
//
//    output offset binary code
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<12)+(0x14))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x14, data =0x0;
//

       i=1;
       k=2;

       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us

//
//    unset fix pattern  0x0 for normal data taking
//
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
       buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0x0;
//

       i=1;
       k=2;

       i = pcie_send_1(hDev, i, k, px);
       usleep(100);   // sleep for 100us
      }
     }


//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
      ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
//
      if(iwrite != 1) {
       printf(" type 1 to send the transfer \n");
       scanf("%d",&is);
      }
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
//
      nread =2+(64*nsample/2)+1;
      i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

      if(iwrite != 1) {
       printf(" type 1 to send the read \n");
       scanf("%d",&is);
      }
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//
//
      i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
      if (iwrite == 1) {
       fprintf(outf," %x\n", read_array[0]);
       fprintf(outf," %x\n", read_array[1]);
      }
      else {
       printf(" header 1 = %x\n", read_array[0]);
       printf(" header 2 = %x\n", read_array[1]);
      }

      k=0;
      for (is=0; is< (nread-2); is++) {
       if(iwrite == 1) {
        fprintf(outf," %8X", read_array[is+2]);
       }
       else {
        if(is%8 ==0) printf(" %d ", is);
        printf(" %x", read_array[is+2]);
       }
       k=k+1;
       if(iwrite == 1) {
        if((k%8) ==0) fprintf(outf,"\n");
       }
       else {
        if((k%8) ==0) printf("\n");
       }
      }
      if(iwrite == 1) fprintf(outf,"\n");
      else printf("\n");

      if(iwrite != 1) {
       for (is=0; is< nsample; is++ ) {
        for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
         adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
         adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
        }
       }


       for (is=0; is<64; is++) {
       printf(" channel %d ", is);
       for (k=0; k<nsample; k++) {
        printf(" %4x", adc_data[is][k]);
       }
        printf("\n");
       }
      }


      if(iwrite != 1) {
        printf(" type 1 to continue \n");
        scanf("%d",&is);
      }
     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//

     break;

    case 3:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite == 1) {
       printf(" type 1 to write test.data, otherwise write /dev/null \n");
       scanf("%d",&i);
       if(i ==1) outf = fopen("/home/chi/test.dat","w");
       else outf = fopen("/dev/null","w");
     }  
//
//
//
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
     }
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent); 


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev,imod_dcm,1);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev,imod_dcm,2);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         
/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =3;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x, %x\n", imod, read_array[0], read_array[1], read_array[2]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
      }



//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         idac_shaper = idac_shaper *nstep_dac;    //set up the dac value

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
      else if ((iext_trig != 1) & (igen != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is); 
       }
      }

      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
         printf(" trigger received \n");
         ik=1;
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if(i%8 == 7) fprintf(outf,"\n");
        }
        if((i%8) != 7) fprintf(outf,"\n");
       }

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
       iparity =0;
       for (is=0; is<4+(nsample*64); is++) {
        if(is%2 == 0) u32Data = (read_array1[is+6] & 0xffff) <<16;
        else {
         u32Data = u32Data + (read_array1[is+6] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
         iparity = iparity ^ u32Data;
        }
       }
       i= ((read_array1[778] & 0xffff) <<16) +(read_array1[779] & 0xffff);
       if(i != iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia, i, iparity);
         scanf("%d", &i);
       }
       printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

       if(iwrite != 1) {
        printf(" parity word = %x\n", iparity);
        printf(" packet parity word = %x\n", (((read_array1[778] & 0xffff) <<16) +(read_array1[779] & 0xffff)));
        scanf("%d", &i );
        for (is=0; is<nsample; is++) {
         for (k=0; k<32; k++) {
          adc_data[k*2][is] = read_array1[11+((k*nsample+is)*2)] & 0xffff;
          adc_data[(k*2)+1][is] = read_array1[10+((k*nsample+is)*2)] & 0xffff;
         }
        }
        for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
         printf(" %4x", adc_data[is][k]);
        }
         printf("\n");
        }
        scanf("%d", &i );
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if (iwrite != 1) printf(" parity = %x  \n", iparity);
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write evennt = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;

    case 4:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
     scanf("%d", &nmod);
     printf(" number of sample \n");
     scanf("%d", &nsample);
     printf(" type 1 to use xmit module \n");
     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite ==1) {
       printf(" type 0 to /dev/null \n");
       scanf("%d", &i);
       if(i== 0) outf = fopen("/dev/null","w");
       else outf = fopen("/home/chi/test.dat","w");
     }
//
//
//
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
      printf(" type 1 for fix dac\n");
      scanf("%d", &ifix_dac);
     }
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent); 


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }
     
     printf(" enter 1 to load ADC test data memory\n");
     scanf("%d", &itest_ram);

     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
//     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,1);
      printf(" type 1 to continue \n");
      scanf("%d", &i);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,2);
      printf(" type 1 to continue \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev2,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//

       printf(" set the controller to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x1<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
      buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//     }

//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev2,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev2,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev2,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0x10<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
      printf(" type 1 to set test ram state  \n");
      scanf("%d",&is);
//
//   verilog code issue I don't understand so I flip the test pulse bit
//

//      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
//      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
//      if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
      if(itest_ram == 1) {
       printf(" call adc setup  module %d\n", imod);
       scanf("%d",&is);
       i = adc_testram_load(hDev,imod, 400);
      }
//sp_adc_sel_link_rxoff



     }
//

//
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =3;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x, %x\n", imod, read_array[0], read_array[1], read_array[2]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        printf (" firmware version %d\n", ((read_array[2]>>8) & 0xff));
        printf (" firmware sub version %d\n", ((read_array[2]) & 0xff));
        printf (" firmware version header %x\n", ((read_array[2])>>16));
       }
      }



//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         if(ifix_dac != 1) idac_shaper = idac_shaper *nstep_dac;    //set up the dac value
         else idac_shaper = 4000;

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
//      else if (itest_ram == 1) {
//       printf(" send test pulse trigger \n");
//       scanf("%d", &i);
//       ichip = sp_adc_slowcntl_sub;
//       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
//      }
//      else if ((iext_trig != 1) & (igen != 1) & (itest_ram != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      else if ((iext_trig != 1) & (igen != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }

      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
         printf(" trigger received \n");
         ik=1;
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if((i%8) == 7) fprintf(outf,"\n");
        }
        fprintf(outf,"\n");
//        if((i%8) != 7) fprintf(outf,"\n");
       }
//       fprintf(outf,"\n");

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
//       iparity =0;
       for (ic=0; ic< nmod; ic++ ){
        ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
        iparity =0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));

        for (is=0; is<4+(nsample*64); is++) {
         if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
         else {
          u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
          iparity = iparity ^ u32Data;
         }
        }
        ioffset_t = ioffset + (64*nsample+4)+6;   // 4 words header + 5 event header -1 for array started at 0
        i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff);
        if(i != iparity) {
         printf(" event = %d, module %d Partity error....... = %x %x\n", ia, (imod_start+ic), i, iparity);
         if(iwrite != 1) scanf("%d", &i);
        }
        if(iwrite != 1) printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

        if(iwrite != 1) {
         printf(" parity word = %x\n", iparity);
         printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
         scanf("%d", &i );
         for (is=0; is<nsample; is++) {
          for (k=0; k<32; k++) {
           adc_data[k*2][is] = read_array1[11+ioffset+((k*nsample+is)*2)] & 0xffff;
           adc_data[(k*2)+1][is] = read_array1[10+ioffset+((k*nsample+is)*2)] & 0xffff;
          }
         }
         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
          printf("\n");
         }
         scanf("%d", &i );
        }
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
          if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }

        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write evennt = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;



    case 5:
     nloop=100 ;
     nevent =200;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;

     printf(" number of loop \n");
//    scanf("%d",&nloop);
     printf(" number per event \n");
//     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
//     scanf("%d",&iwrite);
//     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
     if(iwrite ==1) outf = fopen("/dev/null","w");
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" DAC start value \n");
      scanf("%d", &dac_start);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
     }
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent);


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev,imod_dcm,1);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev,imod_dcm,2);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
//    for (j=0; j<nloop; j++) {
     printf(" enter 1 for initialization \n");
     scanf("%d",&i);
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//     printf(" enter 1 for initialization \n");
//     scanf("%d",&i);
//    }
//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
//      printf(" type 1 to send sample size \n");
//      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
//      printf(" type 1 to send sample size");
//      scanf("%d",&is);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =1;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
      }


      printf(" enter trigger loop \n");
//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         idac_shaper = idac_shaper *nstep_dac+dac_start;    //set up the dac value

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
      else if ((iext_trig != 1) & (igen != 1) )
       {
        printf(" send controller trigger \n");
        scanf("%d",&is);
        buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
       }
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }

      if(iext_trig == 1) {
       if(isel_dcm != 1) {
        ik =0;
        while (ik != 1) {
         imod = imod_start;
         nword =1;
         py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
         ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
         buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
//
         i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
         ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         py = &read_array;
         i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         if (((read_array[0] >>21) & 0x1) == 0) {
          printf(" trigger received \n");
          ik=1;
         }
        }
       }
       else {
//        printf(" enter DCM II event wait loop\n");
//
//      reset the busy from the controller
//
        buf_send[0]= (0x2<<8)+sp_cntrl_busyrst+ (0<<16);
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        nword = 2;
        i = pcie_rec(hDev,0,1,nword,iprint,py);       // init receiver
        ichip =5;
        buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_status_read;  /* turn on status read*/
        buf_send[1]=0x5555aaaa;
        ik = pcie_send(hDev, 1, 2, px);  //** for dcm2 status read send 2 words **//
        usleep(10);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//        printf(" DCMII FPGA 5 status word = %x , %x\n", read_array[0], read_array[1]);
//        if((read_array[0] & 0x10000000) == 0) printf(" DCM II buffer has event \n");
        if((read_array[0] & 0x40000000) != 0) printf(" DCM II buffer hold is on \n");
//        printf(" enter DCM status loop, type 1 to continue\n");
        while ( (read_array[0] & 0x10000000) != 0) {
//        for (ik=0; ik<10000; ik++) {
         nword = 2;
         i = pcie_rec(hDev,0,1,nword,iprint,py);       // init receiver
         ichip =5;
         buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_status_read;  /* turn on status read*/
         buf_send[1]=0x5555aaaa;
         ik = pcie_send(hDev, 1, 2, px);  //** for dcm2 status read send 2 words **//
         usleep(10);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//         printf(" DCMII FPGA 5 status word = %x , %x\n", read_array[0], read_array[1]);
//         if((read_array[0] & 0x10000000) == 0) printf(" DCM II buffer has event \n");
//        if((read_array[0] & 0x40000000) != 0) printf(" DCM II buffer hold is on \n");
//         printf(" enter DCM status loop, type 1 to continue\n");
//         scanf("%d", &i);
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if(i%8 == 7) fprintf(outf,"\n");
        }
        if((i%8) != 7) fprintf(outf,"\n");
       }

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
//       iparity =0;
       for (ic=0; ic< nmod; ic++ ){
        ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
        iparity =0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));

        for (is=0; is<4+(nsample*64); is++) {
         if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
         else {
          u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
          iparity = iparity ^ u32Data;
         }
        }
        ioffset_t = ioffset + (64*nsample+4)+6;   // 4 words header + 5 event header -1 for array started at 0
        i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff);
        if(i != iparity) {
         printf(" event = %d, module %d Partity error....... = %x %x\n", ia, (imod_start+ic), i, iparity);
         if(iwrite != 1) scanf("%d", &i);
        }
        if(iwrite != 1) printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

        if(iwrite != 1) {
         printf(" parity word = %x\n", iparity);
         printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
         scanf("%d", &i );
         for (is=0; is<nsample; is++) {
          for (k=0; k<32; k++) {
           adc_data[k*2][is] = read_array1[11+ioffset+((k*nsample+is)*2)] & 0xffff;
           adc_data[(k*2)+1][is] = read_array1[10+ioffset+((k*nsample+is)*2)] & 0xffff;
          }
         }
         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
          printf("\n");
         }
         scanf("%d", &i );
        }
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if (iwrite != 1) printf(" parity = %x  \n", iparity);
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write evennt = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;

    case 6:
     printf(" controller busy taggle test \n");

     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     
     printf(" controller init done \n");
     
     for (is=0; is<10000; is++) {
      printf(" type 1 to rest busy from trigger \n");
      scanf("%d", &ik);
//
//   send init to the controller
//
      buf_send[0]= (0x2<<8)+sp_cntrl_busyrst+ (0<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }

     break;
//
//
//
//
    case 7:
     printf(" eprom test \n");
     printf(" enter module address \n");
     scanf("%d", &imod);
     px = &buf_send;
     py = &read_array;
//     imod =18;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     printf(" controller init done \n");
//
//
//

//     for (is=0; is<10000; is++) {
     printf(" type 1 for eprom testimg routine -- reset \n");
//     scanf("%d", &ik);
//
     ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//    reset eprom
//
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_reset_p + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     printf(" enter operation type \n");
     printf("    1 for reading EPROM ID \n");
     printf("    2 for read EPROM data \n");
     printf("    3 for bulk erase \n");
     printf("    4 for program EPROM \n");
     printf("    5 read eprom status \n");
     printf("    6 write eprom sector protect \n");
     printf("    7 sector erase \n");
     printf("    8 reconfigure the FPGA \n");
     scanf("%d", &itest);
     switch (itest){

//
      case 1:
       printf(" type 1 for eprom testimg routine -- read ID \n");
       scanf("%d", &ik);
//
//    read eprom id
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_id_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       i= eprom_readback(hDev,imod,0, py);
       printf(" eprom readback status %x\n",i);
//
       nword = 2;
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
       break;
//
//
      case 2:
       for (ia=0; ia<79872; ia++) {
        if(ia ==0) {
         printf(" type 1 for eprom testimg routine -- read data word print \n");
         printf(" type 2 for compressed print \n");
         scanf("%d", &ij);
//
//

        }
//
//
        ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + ((ia & 0xffff)<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//        usleep(1);
//       printf(" add low\n");
//       scanf("%d", &ik);
//
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + (((ia>>16) & 0xffff)<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//       printf(" add low\n");
//       scanf("%d", &ik);
//        usleep(1);
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_pulse + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1);
//       printf(" read\n");
//       scanf("%d", &ik);
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        nword = 2;
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//       printf("module %d address %d receive data word = %x, %x \n", imod, ia, read_array[0], read_array[1]);
//        printf(" address = %x, data = %x \n", ia, (read_array[1] & 0xff));
        if(ij == 1) if((ia%16)==0) printf("%7d", ia);
//      printf("%4x",carray[ia]);
        i = ((read_array[1] & 0x1) <<7 |
          (read_array[1] & 0x2) <<5 |
          (read_array[1] & 0x4) <<3 |
          (read_array[1] & 0x8) <<1 |
          (read_array[1] & 0x10) >>1 |
          (read_array[1] & 0x20) >>3 |
          (read_array[1] & 0x40) >>5 |
          (read_array[1] & 0x80) >>7);
//        printf("%4x",(read_array[1] & 0xff));
        if(ij== 1) {
         printf("%4x",(i & 0xff));
         if((ia+1)%16 == 0) printf("\n");
        }
        else read_array_s[ia] = i;
       }
       printf(" end of loop1 \n");
       if(ij != 1) {
        ib=79872/16;
        for (ia=0; ia<ib; ia++) {
         k=0;
         for (ik=0; ik<16; ik++) {
          if(read_array_s[(ia*16)+ik] !=0xff) k=1;
         }
         if(k != 0) {
          printf("%6d", ia*16);
          for (ik=0; ik<16; ik++) {
           printf("%4x", read_array_s[(ia*16)+ik]);
          }
          printf("\n");
         }
        }
       }
       break;
      case 3:
       printf(" type 1 for eprom testimg routine -- bulk erase \n");
       scanf("%d", &ik);
//
//    read eprom id
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_bulk_erase_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       i= eprom_readback(hDev,imod,0,py);
       k=0;
       while ((i & 0x1000000) !=0)  {
        k=k+1;
        i= eprom_readback(hDev,imod,0,py);
        usleep(1000000);
        printf(" counter %d eprom readback status %x\n",k,i);
       }
       printf(" bulk erase done \n");
       break;

      case 4:
       printf(" type 1 for eprom testimg routine -- write RPD file to the EPROM \n");
       scanf("%d", &ik);
       ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//
//
//    reset eprom   - reset address
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_reset_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       printf(" reset done type 1 to continue \n");
       scanf("%d", &ik);
       is=0;
       inpf = fopen("/home/cherry/Downloads/mbd_double_blink.rpd","r");
       //inpf = fopen("/home/grape/Downloads/mbd_double_blink.rpd","r");
       count = 0;
       counta =0;
       addr_w =0;
       while (fread(&charchannel,sizeof(char),1,inpf)==1) {
        carray[counta] = charchannel;
        count++;
        counta++;
        if((count%1000) ==0) printf(" write data to address %d address %x,lower %x, upper %x\n", count, addr_w, (addr_w & 0xffff),((addr_w>>16) & 0xffff));
        if(counta == 64) {
        /* if(counta == 256) { */
retry_:
         ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + ((addr_w & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//          usleep(1);
//       printf(" add low\n");
//       scanf("%d", &ik);
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + (((addr_w>>16) & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
///
//         printf(" set address %x \n", addr_w);
//         scanf("%d", &ik);

//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata;

         for (ia=0; ia< counta; ia++) {
          ik=0;
          ik= ((carray[ia] & 0x80) >>7) + ((carray[ia] & 0x40) >>5) + ((carray[ia] & 0x20) >>3);
          ik = ik + ((carray[ia] & 0x10) >>1) + ((carray[ia] & 0x8) <<1) + ((carray[ia] & 0x4) <<3);
          ik = ik + ((carray[ia] & 0x2) <<5) + ((carray[ia] & 0x1) <<7);
          write_eprom_array[ia] = carray[ia];
          if((ia%2) ==0) {
           ij= ia/2;
           buf_send[ij]= buf_send[ij] + (ik<< 16);
//           buf_send[ij]= buf_send[ij] + (carray[ia]<< 16);
          }
          else buf_send[ij+1] = ik;

//          if((ij%8 == 0) & (ia%2 ==0)) printf("%4d", ij);
//          if((ia%2) == 0) printf ("%8x", buf_send[ij]);
//          if((((ij+1)%8) == 0) & (ia%2 ==0)) printf("\n");
         }
//         printf ("%8x\n", buf_send[ij]);  // last data word
//         printf(" type 1 to send the data packet \n");
//         scanf("%d", &ik);

         i= 1;
         k= 33;
         /* k= 129; */
//         printf(" type 1 to send the write packet \n");
//         scanf("%d", &ik);
         i = pcie_send_1(hDev, i, k, px);
//
//       slow control clock rate is 15 MHz.
//       only use half of 16 bits.
//       16 Mhz per bytes
//       66ns * 256 *2  = 33 us;
//       wait for 1.5 time longer

         /* usleep(1000); */
         usleep(50);

//         printf(" type 1 to send the write pulse \n");
//         scanf("%d", &ik);

//       printf(" add low\n");
//       scanf("%d", &ik);

//
//
/*
          if ((is ==0) & (ia ==0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata + (ik<<16);
          else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata + ((ik+ 0x8000)<<16);
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
*/
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_w_pulse + (ik<<16);
//          if(is ==0) {
//           if((ia%8)==0) printf("%d", ia);
//      printf("%4x",carray[ia]);
//           printf("%4x",ik);
//           if((ia+1)%8 == 0) printf("\n");
 //         }
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//         usleep(1000);
//
//

         i= eprom_readback(hDev,imod,0,py);
         k=0;
         /* if(is <= 20) printf(" status readback %x \n", i); */
         while ((i & 0x1000000) !=0)  {
          k=k+1;
          usleep(1);
          i= eprom_readback(hDev,imod,0,py);
          /* if(k>=2) printf(" status readback %x \n", i); */
         }
         /* if(is <= 10) printf(" wait period %d \n",k); */
/*
         if(is == 1) {
           printf(" first block type 1 to continue \n");
           scanf("%d", &ik);
         }
*/
//
//      readback routine
//
         if(0) {
         /* if(is == 0) { */
         for (ia=0; ia< 256; ia++ ) {
//
          ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
          buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + (((ia+addr_w) & 0xffff)<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
//       printf(" add low\n");
//       scanf("%d", &ik);
//
          buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + ((((ia+addr_w)>>16) & 0xffff)<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
//       printf(" add low\n");
//          scanf("%d", &ik);
          usleep(10);
          buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_pulse + (0<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
//       printf(" read\n");
//          scanf("%d", &ik);
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
          nword = 2;
          ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
          buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
          i=1;
          k=1;
          i = pcie_send_1(hDev, i, k, px);
//
          i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
          ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
          buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
          i=1;
          k=1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
          py = &read_array;
          i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//       printf("module %d address %d receive data word = %x, %x \n", imod, ia, read_array[0], read_array[1]);
//        printf(" address = %x, data = %x \n", ia, (read_array[1] & 0xff));
//          if((ia%16)==0) printf("%7d", ia);
//      printf("%4x",carray[ia]);
          i = ((read_array[1] & 0x1) <<7 |
          (read_array[1] & 0x2) <<5 |
          (read_array[1] & 0x4) <<3 |
          (read_array[1] & 0x8) <<1 |
          (read_array[1] & 0x10) >>1 |
          (read_array[1] & 0x20) >>3 |
          (read_array[1] & 0x40) >>5 |
          (read_array[1] & 0x80) >>7);
//        printf("%4x",(read_array[1] & 0xff));
//          printf("%4x",(i & 0xff));
//          if((ia+1)%16 == 0) printf("\n");
          read_eprom_array[ia] = i;
         }
//
//
         int chk = 0;
         for (ia=0; ia< 256; ia++) {
          if( read_eprom_array[ia] != write_eprom_array[ia] ) {
		  chk = 1;
          }
         }

	 if (chk) {
           printf(" block %8x\n", addr_w);
	   printf(" write:\n");
	   for (int asdf=0; asdf<256; ++asdf) {
		   printf(" %4x", write_eprom_array[asdf]);
		   if (asdf % 16 == 15)
			   printf("\n");
	   }
	   printf(" readback:\n");
	   for (int asdf=0; asdf<256; ++asdf) {
		   printf(" %4x", read_eprom_array[asdf]);
		   if (asdf % 16 == 15)
			   printf("\n");
	   }
	   goto retry_;
           /* scanf("%d", &ik); */
	 }

         }
         counta =0;
         is=is+1;
         ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
         addr_w = addr_w+256;
        }
       }
       if(feof(inpf)) {
        is =0;
        ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
        printf("You have reached the end-of-file word count= %d %d\n", counta, count);
        if(counta != 0) {
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + ((addr_w & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//          usleep(1);
         printf(" add %x\n", addr_w);
         printf(" counta = %d\n", counta);
//       scanf("%d", &ik);
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + (((addr_w>>16) & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata;

         for (ia=0; ia< counta; ia++) {
          ik=0;
          ik= ((carray[ia] & 0x80) >>7) + ((carray[ia] & 0x40) >>5) + ((carray[ia] & 0x20) >>3);
          ik = ik + ((carray[ia] & 0x10) >>1) + ((carray[ia] & 0x8) <<1) + ((carray[ia] & 0x4) <<3);
          ik = ik + ((carray[ia] & 0x2) <<5) + ((carray[ia] & 0x1) <<7);
          if((ia%2) ==0) {
           ij= ia/2;
           buf_send[ij]= buf_send[ij] + (ik<< 16);
//           buf_send[ij]= buf_send[ij] + (carray[ia]<< 16);
          }
          else buf_send[ij+1] = ik;

          if((ij%8) == 0) printf("%4d", ij);
          if((ia%2) == 0) printf ("%8x", buf_send[ij]);
          if(((ij+1)%8) == 0) printf("\n");
         }
         printf ("%8x\n", buf_send[ij]);  // last data word
         printf(" type 1 to send the data packet\n");
         scanf("%d", &ik);

         i= 1;
         k= (counta/2)+1;
         i = pcie_send_1(hDev, i, k, px);

         usleep(50);

//       printf(" type 1 to send the write pulse");
//       scanf("%d", &ik);

         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_w_pulse + (ik<<16);

         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
//
         i= eprom_readback(hDev,imod,0,py);
         k=0;
         while ((i & 0x1000000) !=0)  {
          k=k+1;
          i= eprom_readback(hDev,imod,0,py);
         }
        }
//
       }
       printf(" write is done \n");
       break;
      case 5:
       printf(" type 1 for eprom testimg routine -- read status \n");
       scanf("%d", &ik);
       ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//    read eprom id
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_status_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       i= eprom_readback(hDev,imod,0,py);
       printf(" eprom readback status %x\n",i);
       printf("module %d receive data word = %x, %x %x\n", imod, read_array[0], read_array[1], read_array[2]);
//
       nword = 3;
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       printf("module %d receive data word = %x, %x %x\n", imod, read_array[0], read_array[1], read_array[2]);
       break;
//
//
      case 6:
       printf(" eprom testimg routine -- write sector protect \n");
       printf(" enter sector protect bits \n");
       ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
       scanf("%x", &ik);
       ik = (ik & 0xff) <<2;
       printf(" block protector load in data = %x \n",ik);
//
//    load eprom data
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata + (ik<<16);
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" type 1 to continue \n");
       scanf("%d", &ik);

//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_sector_protect_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       i= eprom_readback(hDev,imod,0,py);
       k=0;
       while ((i & 0x1000000) !=0)  {
        k=k+1;
        i= eprom_readback(hDev,imod,0,py);
       }
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_status_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       i= eprom_readback(hDev,imod,0,py);
       printf(" eprom readback status %x\n",i);
       printf("module %d receive data word = %x, %x %x\n", imod, read_array[0], read_array[1], read_array[2]);
//
       break;
//
//
      case 7:
       printf(" type 1 for eprom testimg routine -- sector erase \n");
       scanf("%d", &ik);
       printf(" enter starting address for erasing (in hex) \n");
       scanf("%x", &ik);
       printf(" enter number sector to erase \n");
       scanf("%d", &nsector);
//
//
//
       for (ij=0; ij<nsector; ij++) {
        ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section

//
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + ((ik & 0xffff)<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//      printf(" add low\n");
//      scanf("%d", &ik);
//
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + (((ik>>16) & 0xffff)<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        if(ij == 0) {
         printf(" issue sector erase command \n");
         scanf("%d", &ia);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_erase_sector + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//       printf(" add low\n");
//       scanf("%d", &ik);

//
//    read eprom status
//

        i= eprom_readback(hDev,imod,0,py);
        k=0;
        while ((i & 0x1000000) !=0)  {
         k=k+1;
         i= eprom_readback(hDev,imod,0,py);
         usleep(1000000);
//         printf(" counter %d eprom readback status %x\n",k,i);
        }
        printf(" counter %d eprom readback status %x\n",k,i);
        if(ij%2 ==0) printf(" loop counter %d , address = %x \n", ij, ik);
        ik =ik+0x10000;
       }
       printf(" bulk erase done \n");
       break;
//
//
      case 8:
       printf(" type 1 for eprom reloading testing \n");
       printf(" send the eprom remote update reset \n");
       scanf("%d", &ik);
//
//
//
       ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//    reset remote update ip core
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_reset + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//
//     set remote parameter   -- timeout value
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_param + (0x5<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       printf(" setting the configuration mode \n");
       scanf("%d", &ik);
       ij= 0x1;  // set timer upper 12 bits to 0x100
//
//    time out vale is 29 bits, upper 12 bits is what we are loading.
//    bits 0 is egula to 0x20000, with 15 Mhz clock = 8.65 ms
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_l + ((ij & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//       usleep(10);
//       printf(" load data high %x %x\n", ij, (ij>>16));
//       scanf("%d", &ik);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_h + (((ij>>16) & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" done loading... \n");
       printf(" enter 1 to write configuration mode parameter \n");
       scanf("%d", &ik);
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_write_param + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" finish write configuration mode value \n");
       scanf("%d", &ik);
//
       printf(" set the eprom remote update parameter --- timeout value -- page \n");
       scanf("%d", &ik);
//
//
//
//
//     set remote parameter   -- timeout value
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_param + (0x2<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" set the eprom remote update timeer value \n");
       scanf("%d", &ik);
       ij= 0x400;  // set timer upper 12 bits to 0x100
//
//    time out vale is 29 bits, upper 12 bits is what we are loading.
//    bits 0 is egula to 0x20000, with 15 Mhz clock = 8.65 ms
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_l + ((ij & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//       usleep(10);
//       printf(" load data high %x %x\n", ij, (ij>>16));
//       scanf("%d", &ik);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_h + (((ij>>16) & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" done loading... \n");
       printf(" enter 1 to write timer the parameter \n");
       scanf("%d", &ik);
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_write_param + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" finish write timeout value \n");
       scanf("%d", &ik);
//
//
//
//
//     set remote parameter   --  time out enable
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_param + (0x3<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" finish the eprom remote update timeout enable page \n");
       scanf("%d", &ik);
       ij= 0x1;  // set timer upper 12 bits to 0x100
//
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_l + ((ij & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//       usleep(10);
//       printf(" load data high %x %x\n", ij, (ij>>16));
//       scanf("%d", &ik);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_h + (((ij>>16) & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" done loading... \n");
       printf(" enter 1 to write timeout enable the parameter \n");
       scanf("%d", &ik);
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_write_param + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" finish write timeout enable \n");
       scanf("%d", &ik);
//
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_reset_timer + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" finish reset timer  -- going to set boot address \n");
       scanf("%d", &ik);
//



//
//     set remote parameter   -- page select
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_param + (0x4<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" set the eprom remote update data \n");
       scanf("%d", &ik);
       ij= 0x1000000;  // address of secor 256
//
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_l + ((ij & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" load data %x high order 16 bits %x\n", ij, (ij>>16));
       scanf("%d", &ik);
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_data_in_h + (((ij>>16) & 0xffff)<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" done loading... \n");
       printf(" enter 1 to write the parameter \n");
       scanf("%d", &ik);
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_write_param + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" ready to reconfigure \n");
       scanf("%d", &ik);
//
//         update reset timer again
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_reset_timer + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//       printf(" finish reset timer  -- going to set boot address \n");
 //      scanf("%d", &ik);
//
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_update_reconfig + (1<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" reconfigure done \n");
       break;
//
//

//#define  sp_adc_update_data_in_l   60
//#define  sp_adc_update_data_in_h   61
//#define  sp_adc_update_reset_timer 62
//#define  sp_adc_update_write_param 63
//#define  sp_adc_update_reconfig    64
//#define  sp_adc_update_param       65
//#define  sp_adc_update_reset       66
     }
//#define  sp_adc_eprom_addr_l       50
//#define  sp_adc_eprom_addr_h       51
//#define  sp_adc_eprom_wdata        52
//#define  sp_adc_eprom_w_pulse      53
//#define  sp_adc_eprom_read_pulse   54
//#define  sp_adc_eprom_bulk_erase_p 55
//#define  sp_adc_eprom_read_status_p  56
//#define  sp_adc_eprom_read_id_p    57
//#define  sp_adc_eprom_reset_p      58

     break;




    case 8:
     inpf = fopen("/home/chi/sphenix_adc_eprom.rpd","r");
     count = 0;
     printf(" controller init done \n");
        /* read data as characters (28941) */
     while (fread(&charchannel,sizeof(char),1,inpf)==1) {
     printf(" controller init done \n");
       carray[count] = charchannel;
       count++;
       if(count == 30000) break;
     }
//     if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d\n", count);
//     }

     for (ia=0; ia<1000; ia++) {
      ik=0;
      ik= ((carray[ia] & 0x80) >>7) + ((carray[ia] & 0x40) >>5) + ((carray[ia] & 0x20) >>3);
      ik = ik + ((carray[ia] & 0x10) >>1) + ((carray[ia] & 0x8) <<1) + ((carray[ia] & 0x4) <<3);
      ik = ik + ((carray[ia] & 0x2) <<5) + ((carray[ia] & 0x1) <<7);
      if((ia%8)==0) printf("%d", ia);
//      printf("%4x",carray[ia]);
      printf("%4x",ik);
      if((ia+1)%8 == 0) printf("\n");
     }

     break;


    case 9:
     printf(" ADC trigger testing routine \n");
//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;

     imod = 18;
     nsample_trig = 20;
     ndelay_trig = 14;
     ifake_width = 10;
     ifake_start = 70;
     trig_rw_delay =2;


     px = &buf_send;
     py = &read_array;

//     fake_pulse = {0x1ff, 0xfff, 0x1fff, 0x2fff, 0x1fff, 0xfff, 0x1ff, 0x0, 0x0, 0x0};
/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

/*     printf(" trigger routine test option \n");
     printf("  1) trigger table loading test \n");
     printf("  2) load fake data \n");
     scanf("%d", &itest);
     switch (itest){
*/
/*
#define  sp_adc_trig_sub_delay      1
#define  sp_adc_trig_tbl_chnl       2
#define  sp_adc_trig_lkp_addr       3
#define  sp_adc_trig_lkp_data       4
#define  sp_adc_trig_smpl_phase     5
#define  sp_adc_trig_lkp_write     10
*/
 //     case 1:
       ichip = sp_adc_trigproc_sub;
       for (ia =0; ia <64; ia ++) {
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_tbl_chnl + (ia<<16);  // set channel 0 to 63
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//        printf("type 1 to continue \n");
//        scanf("%d",&i);
        for (ik=0; ik<1023; ik++) {
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_addr + (ik<<16);  // set table write address
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//         printf("load address type 1 to continue \n");
//         scanf("%d",&i);
         itrig_lk_data = ik+ia+1;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_data + ( itrig_lk_data <<16);  // set lookup table data word
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//         printf("load data type 1 to continue \n");
//         scanf("%d",&i);
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_write + (ik<<16);  // just a write pulse
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
 //        printf("issue write type 1 to continue \n");
//         scanf("%d",&i);
         trig_lookup[ia][ik]= itrig_lk_data;
        }
//        printf(" end of channel %d \n", ia);
//        scanf("%d", &i);
       }
//
//
//
/*
       printf(" print fake data after lookup \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6d" , trig_lookup[ich][iad]);
        }
        printf("\n");
       }
*/

       printf(" end of load channel %d \n", ia);
        scanf("%d", &i);

//       break;
//      case 2:
       printf(" fake data loading starting position \n");
       scanf("%d", &ifake_start);

       ichip = sp_adc_input_sub ;   // controller data go to ADC input section

       for (ich=0; ich< 64; ich++) {
        if(ich== 0)  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (64<<16);  // set channel 0 to 64
        else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (ich<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//        usleep(1);
//        printf(" load testram ch = %d, module %d\n", ich, imod);
//        scanf("%d", &i);
        is=0;
//
//
        for (iad =0; iad<512 ; iad++) {
         idata =  ich +1+ iad;
         if((iad > (ifake_start+ich)) & ( iad< ((ifake_start+ifake_width)+ich))) {
          idata = idata+fake_pulse[is];
          is=is+1;
         }
//         if(ich <4 ) idata =0;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_data + (idata<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         fake_data_array[ich][iad] = idata;

//         usleep(1);
//         printf(" load testram ch = %d, address %d, idata %x\n", ich, iad, idata);
//         scanf("%d", &i);
        }
//        scanf("%d", &i);
       }
//
/*
       printf(" print fake data after lookup \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6d" , trig_lookup[ich][iad]);
        }
        printf("\n");
       }
*/
//
       printf(" print fake data array \n");
       scanf("%d", &i);

       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , fake_data_array[ich][iad]);
        }
        printf("\n");
       }
/*
       printf(" print fake data after lookup table \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%5d" , adc_data[is][k]);
        }
        printf("\n");
       }
*/


//
//     set up parameter before the run
//
//#define  sp_adc_trig_read_delay     6
//#define  sp_adc_trig_read_size      7
//#define  sp_adc_trig_sub_delay      1
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_sub_delay + (trig_rw_delay<<16);  // set trigger substract delay to 2
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//

       for (ich =0; ich< 64; ich++) {
        for (iad =0; iad< 512 ; iad++) {
         if (iad < (trig_rw_delay+3)) fake_data_array_sub[ich][iad] = fake_data_array[ich][iad];
         else {
          if (fake_data_array[ich][iad] >= fake_data_array[ich][iad-trig_rw_delay-3] )
          i=  fake_data_array[ich][iad]- fake_data_array[ich][iad-trig_rw_delay-3];
          else i =0;
          fake_data_array_sub[ich][iad] = i;
         }
        }
       }
//
//
       printf(" print fake data after substraction \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , fake_data_array_sub[ich][iad]);
        }
        printf("\n");
       }

       for (ich =0; ich< 64; ich++) {
        for (iad =0; iad< 512 ; iad++) {
          fake_data_array_sub_lk[ich][iad] = fake_data_array_sub[ich][iad] >>4;
        }
       }
//
//
//
       printf(" print fake data before lookup \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , fake_data_array_sub_lk[ich][iad]);
        }
        printf("\n");
       }
//
//
//
       printf(" print fake data after lookup \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         i= fake_data_array_sub_lk[ich][iad];
         printf("%6x" , trig_lookup[ich][i]);
        }
        printf("\n");
       }

       for (ia=0; ia<16; ia++) {
        ich = ia*4;
        for (iad=0; iad<512; iad++) {
          i = fake_data_array_sub_lk[ich][iad];
          fake_data_array_sub_lk_sum[ia][iad] = trig_lookup[ich][i];
          i = fake_data_array_sub_lk[ich+1][iad];
          fake_data_array_sub_lk_sum[ia][iad] = trig_lookup[ich+1][i] + fake_data_array_sub_lk_sum[ia][iad] ;
          i = fake_data_array_sub_lk[ich+2][iad];
          fake_data_array_sub_lk_sum[ia][iad] = trig_lookup[ich+2][i] + fake_data_array_sub_lk_sum[ia][iad] ;
          i = fake_data_array_sub_lk[ich+3][iad];
          fake_data_array_sub_lk_sum[ia][iad] = trig_lookup[ich+3][i] + fake_data_array_sub_lk_sum[ia][iad] ;
        }
       }
//
//
       printf(" print fake data after sum \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , fake_data_array_sub_lk_sum[ich][iad]);
        }
        printf("\n");
       }

//
//
       printf(" print fake data after sum  4 bits shift \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , (fake_data_array_sub_lk_sum[ich][iad] >>4));
        }
        printf("\n");
       }
//fake_data_trig_out[16,100], ntrig_w, ntrig_st;
//
       ntrig_st =1;
       for (ich =0; ich< 16; ich++) {
        i = ntrig_st;
        ntrig_w = 0;
        for (iad =0; iad< 512 ; iad++) {
         i=i+1;
         if((i%6) == 0) {
           ntrig_w = ntrig_w+1;
           fake_data_trig_out[ich][(ntrig_w -1)] = (fake_data_array_sub_lk_sum[ich][iad] >>4);
         }
        }
       }
//
//
//
       printf(" print fake trigger output \n");
       scanf("%d", &i);
       for (ich =0; ich< 16; ich++) {
        printf("%3d ", ich);
        for (iad =0; iad< 30 ; iad++) {
         printf("%6x" , fake_data_trig_out[ich][iad]);
        }
        printf("\n");
       }



//
//#define  sp_adc_trig_smpl_phase      5
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_smpl_phase + (0x5<<16);  // set trigger sample phase 5
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//#define  sp_adc_trig_smpl_phase      5
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_read_size + ((nsample_trig & 0xff)<<16);  // set trigger read size to 6
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//#define  sp_adc_trig_smpl_phase      5
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_read_delay + ((ndelay_trig & 0xff)<<16);  // set trigger read delay to 7
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//     select test trig generated from the pulse to generate L1 trigger
//
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
       i = pcie_send_1(hDev, i, k, px);
//
//       set readback from the controller
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//
//       printf(" type 1 to set test ram trigger delay \n");
//       scanf("%d",&is);
//
//
//     set L1 trigger delay for test pulse
//
       ichip = sp_adc_input_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_trig_delay + (0x60<<16) ;
       i = pcie_send_1(hDev, i, k, px);

//
//   send init to the controller
//
       buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
       printf(" type 1 to send reset \n");
       scanf("%d",&is);

       buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);

//
       printf(" send test pulse trigger \n");
       scanf("%d", &i);
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
       i = pcie_send_1(hDev, i, k, px);
//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_trig       4
//
//
       printf(" send readback signal \n");
       scanf("%d", &i);
       ichip = sp_adc_readback_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_trig + (0x0<<16) ;
       i = pcie_send_1(hDev, i, k, px);
//
//
//       printf(" how many word to readback \n");
//       scanf("%d", &nread);
         nread = ((nsample_trig+1)*4)+3;

//
//
//
//       nread =2+(64*nsample/2)+1;
       i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(100);
//
//
       i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words

       printf(" header 1 = %x\n", read_array[0]);
       printf(" header 2 = %x\n", read_array[1]);

/*
       k=0;
       for (is=0; is< (nread-2); is++) {
        if(is%8 ==0) printf(" %d ", is);
        printf(" %x", (read_array[is+2]));
        k=k+1;
        if((k%8) ==0) printf("\n");
       }
*/



       for (ia=0; ia< 4; ia++) {
        for (is=0; is < (nsample_trig+1) ; is++) {
          i= ia*(nsample_trig+1)+is+2;
          trig_smp_data[(ia*4)+2][is] = (read_array[i] & 0xff);
          trig_smp_data[(ia*4)+3][is] = ((read_array[i]>>8) & 0xff);
          trig_smp_data[(ia*4)+0][is] = ((read_array[i]>>16) & 0xff);
          trig_smp_data[(ia*4)+1][is] = ((read_array[i]>>24) & 0xff);
        }
       }
//
//
//
       for (ia=0; ia<16; ia++) {
        printf(" %3d ", ia);
        for (is=0; is< (nsample_trig+1); is++) {
         printf(" %6x", trig_smp_data[ia][is]);
        }
        printf("\n");
       }
/*
         printf(" %d ", is);
         printf(" %4x", (read_array[is+2] & 0xff));

       for (is=0; is< (nread-2); is++) {
        if(is%8 ==0) printf(" %d ", is);
        printf(" %x", (read_array[is+2] & 0xff));
        printf(" %x", ((read_array[is+2] >>8) & 0xff));
        printf(" %x", ((read_array[is+2] >>16) & 0xff));
        printf(" %x", ((read_array[is+2] >>24) & 0xff));
        printf(" \n");
//        k=k+1;
//        if((k%8) ==0) printf("\n");
       }
*/
       scanf("%d", &i);
//      break;
//     }

    break;

    case 10:
     printf(" controllerf lopp back test \n");
     nsend=500;

     px = &buf_send;
     py = &read_array;
// 
//   reset controller with first data word equal to zero
//
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     printf(" reset controller \n");
     printf(" enter 1 to tune loopback on \n");
     scanf("%d", &i);
     buf_send[0]=0x1;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
     printf(" nword to lopback \n");
     scanf("%d", &nread);
     printf(" number of time to run the loopback test \n");
     scanf("%d", &nloop);
     printf (" enter 1 for random number \n");
     scanf("%d", &irand);
     printf (" enter 1 to compare \n");
     scanf("%d", &icheck);
     printf(" enter 1 for print \n");
     scanf("%d", &iprint);

     for (ia=0; ia<nloop; ia++) {
//
//     nread = 10;
      i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
//
      buf_send[0]=0x1;
//      if((j%10)== 1) printf(" event %d", j);
      for (j=0; j<nread; j++) {
       if(irand == 1) buf_send[j+1] = rand();
       else buf_send[j+1] =j;
      }
      i=1;
      k=nread;
      i = pcie_send_1(hDev, i, k, px);
      if(iprint == 1) {
       printf(" sending data %d \n", nread);
       for (is=0; is< (nread+1); is++) {
        if((is%8) == 0) printf("%6d", is);
        printf(" %8x", buf_send[is]);
        if(((is+1)%8) == 0) printf("\n");
       }
       if(((is)%8) != 0) printf("\n");
      }
      if(iprint ==1 ) {
       printf(" finish sending nprint \n");
       scanf("%d", &i);
      }
//
//
      i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
//      if((j%10)== 1) printf(" event %d", j);
      if(iprint == 1) {
       printf(" read data %d \n", nread);
       for (is=0; is< (nread+1); is++) {
        if((is%8) == 0) printf("%6d", is);
        printf(" %8x", read_array[is]);
        if(((is+1)%8) == 0) printf("\n");
       }
       if(((is)%8) != 0) printf("\n");
      }
      if(iprint ==1 ) {
       printf(" finish reading print \n");
       scanf("%d", &i);
      }
      if(icheck ==1) {
       ierror =0;
       for (is=0; is<nread; is++) {
        if(buf_send[is] != read_array[is]) {
         printf(" loop back error event = %d, seq= ,%d, send array = ,%x, receiver array = ,%x,\n", ia, is, buf_send[is], read_array[is] );
        }
       }
       if(ierror == 1) {
        printf(" error event = %d \n", ia);
        printf(" sending data %d \n", nread);
        for (is=0; is< (nread+1); is++) {
         if((is%8) == 0) printf("%6d", is);
         printf(" %8x", buf_send[is]);
         if(((is+1)%8) == 0) printf("\n");
        }
        if(((is)%8) != 0) printf("\n");
        printf(" read data %d \n", nread);
        for (is=0; is< (nread+1); is++) {
         if((is%8) == 0) printf("%6d", is);
         printf(" %8x", read_array[is]);
         if(((is+1)%8) == 0) printf("\n");
        }
        if(((is)%8) != 0) printf("\n");
       }
      }
      if((ia%10000) ==1 )printf(" event %d \n", ia);
     }

    break;

    case 11:
     px = &buf_send;
     py = &read_array;
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     printf(" enter 1 to continue \n");
     scanf("%d", &itest);
     i = pcie_send_1(hDev, i, k, px);
     printf(" controller init done \n");
//
//
// #define  sp_cntrl_loopback_on       1
// #define  sp_cntrl_loopback_off      2
// #define  sp_cntrl_offline           3
// #define  sp_cntrl_online            4
// #define  sp_cntrl_isprst_on         5
// #define  sp_cntrl_isprst_off        6
// #define  sp_cntrl_seldisc_off       0
// #define  sp_cntrl_seldisc_on        7
//
//
     printf(" controller test routine \n");
     printf("    1 for on/line off line \n");
     printf("    2 for loop backup test \n");
     printf("    3 reset for the lattice clock chip \n");
     printf("    4 set for beam beam data \n");
     printf("    5 for controller status readback\n");
     scanf("%d", &itest);
     switch (itest){
      case 1:
       printf(" enter online/offline testing routine \n");
       for (ik=0; ik<1000; ik++) {
        printf(" enter 1 to set be offline state, 10 to get off the loop\n");
        scanf("%d", &ia);
        if(ia ==10) break;
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
//
        printf(" enter 1 to set be online state \n");
        scanf("%d", &ia);
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
       }
      case 2:
       printf(" enter loopback testing routine \n");
       for (ik=0; ik<1000; ik++) {
        printf(" enter 1 to set be offline state, 10 to get off the loop\n");
        scanf("%d", &ia);
        if(ia ==10) break;
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_loopback_on)+(0x0<<16); //enable loopback on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        printf(" command send \n");
        imod=30;
        nsend=100;
        nread =100;
//
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
        for (ib=0; ib<nsend; ib++) {
         if(ib==0) buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_loopback_on)+(ib<<16);
         else buf_send[ib]=((ib*2)-1)+((ib*2)<<16);
        }
        k=nsend;
        i=1;
        i = pcie_send_1(hDev, i, k, px);
        printf(" data send \n");
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        printf(" read data %d \n", nread);
        for (is=0; is< (nread+1); is++) {
         if((is%8) == 0) printf("%6d", is);
         printf(" %8x", read_array[is]);
         if(((is+1)%8) == 0) printf("\n");
        }
        if(((is)%8) != 0) printf("\n");
//
        printf(" enter 1 to set loop back to off state\n");
        scanf("%d", &ia);
//
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_loopback_off)+(0x0<<16); //enable loopback on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);

       }
      case 3:
       printf(" lattice chip reset study\n");
       printf(" set the device to offline state before reset can be applied \n");
//
       imod=0;
       ichip=0;
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable offline run on
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       for (ik=0; ik<1000; ik++) {
        printf(" enter 1 to ssend reset, 10 to get off the loop\n");
        scanf("%d", &ia);
        if(ia ==10) break;
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable offline run on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
//
        printf(" enter 1 to remove the reset\n");
        scanf("%d", &ia);
        imod=0;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
       }
      case 4:
       printf(" discriminator traffic study\n");
//
//
       for (ik=0; ik<1000; ik++) {
        printf(" enter 1 to set data packet to discriminatir, 10 to get off the loop\n");
        scanf("%d", &ia);
        if(ia ==10) break;
        imod=31;
        ichip=7;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0xffff<<16); // crate alternative bit pattern
        buf_send[1]=(0)+(0xffff<<16);
        i=1;
        k=2;
        i = pcie_send_1(hDev, i, k, px);
//
//
        printf(" enter 1 to remove data packet go to discriminator\n");
        scanf("%d", &ia);
        imod=31;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0xffff<<16); // crate alternative bit pattern
        buf_send[1]=(0)+(0xffff<<16);
        i=1;
        k=2;
        i = pcie_send_1(hDev, i, k, px);
       }
      }
      break;

     break;

    case 12:
//
//
     nloop=100 ;
     nevent =200;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;
     l1_delay=12;
     itest_ram = 0;
//
     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
//     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     printf(" type 1 to write data to file \n");
//     scanf("%d",&iwrite);
//     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
     nsample = 12;

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset, 10 to get off the loop\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
//
     printf(" enter 1 to enter discriminator loop \n");
     scanf("%d",&ia);
     if(ia == 1) {
       for (ib=0; ib< 1000000; ib++) {
         imod =31;
         ichip =7;
         buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         scanf("%d",&ia);
//
//
         printf(" enter discriminator threshold DAC setup loop \n");
         for (ic=0; ic< 8; ic++) {
          imod =14;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+1+ (((ic<<12)+ 0xfff)<<16);   // set channel IC DAC value
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
          printf(" channel %d DAC set \n", ic);
          scanf("%d",&ia);
//
          imod =14;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+1+ (((ic<<12))<<16);   // pulse
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
         }



         printf(" enter the pulse loop \n");
         for (ic=0; ic< 1000000; ic++) {
//          imod =22;  //clock fanout module address
//          ichip =0;
//          buf_send[0]= (imod<<11)+(ichip<<8)+1+ (0<<16);   // pulse
//          i= 1;
//          k= 1;
//          i = pcie_send_1(hDev, i, k, px);
//          usleep(10);
//
          imod =14;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+1+ (0x1fff<<16);   // pulse
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
//
//
          imod =14;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+4+ (0<<16);   // pulse
          i= 1;
          k= 1;
//          i = pcie_send_1(hDev, i, k, px);
//          usleep(10);


         }
         scanf("%d",&ia);
//
         printf(" enter the set delay loop \n");
         for (ic=0; ic< 1000000; ic++) {
          imod =22;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // sel delay off
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
//         scanf("%d",&ia);
//
          imod =22;  //clock fanout module address
          ichip =0;
          buf_send[0]= (imod<<11)+(ichip<<8)+2+ (0<<16);   // sel delay on
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
         }
         scanf("%d",&ia);


//
//
         imod =31;
         ichip =0;
         buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);  // slecdisc off
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         scanf("%d",&ia);
       }
     }

     printf(" enter 1 to reset through ADC\n");
     scanf("%d",&i);
//
//   send reset to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_reset+ (0<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);


//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)



     imod = ik+imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
      printf(" type 1 to set L1 delay \n");
      scanf("%d",&is);
     if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
     printf(" buf_send = %x\n", buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set select L1 trigger on
//
     printf(" type 1 to select L1 trigger \n");
     scanf("%d",&is);
     if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
     if(isel_xmit == 1) {
      if(imod != imod_start) {
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" rx_off called , module %d\n", imod);
      }
     }
     printf(" call adc setup  module %d\n", imod);
     i = adc_setup(hDev,imod, 1);
     scanf("%d",&is);
//sp_adc_sel_link_rxoff


//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
      for (ia=0; ia<nevent; ia++) {
       if(iwrite != 1) {
        printf(" type 1 to send L1 trigger \n");
        scanf("%d",&is);
       }

       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
         printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
         printf (" module address = %d \n" ,(read_array[0] & 0x1f));
         printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
         printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
         printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
         printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
         printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
         printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
         printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
         printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
         printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
         printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
         printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        }
       }



//     for (ijk=0; ijk<1000000000; ijk++) {
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
       printf(" enter 1 to send L1 trigger\n");
       scanf("%d",&i);

       imod = imod_start;
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_l1+ (0<<16);
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
///




//      }
/*
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }
*/


//
//
//

//

       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
         iparity = iparity ^ read_array[is];
        }
        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
         if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }

        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
           printf(" %4x", adc_data[is][k]);
          }
          printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
//     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
       if(iwrite ==1) {
        if((ia%10) == 0) printf(" write evennt = %d \n", ia);
       }
      }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
    break;






    case 14:
//
//
//

     printf(" enter discriminator module address \n");
     scanf("%d",&imod_disc);

     px = &buf_send;
     py = &read_array;

     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
//     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
//     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_on;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set controller slow control go to MBD system \n");
//     scanf("%d",&ia);
//
     printf(" number of loop, 1 for single loop\n");
     scanf("%d",&ia);
     nloop =10000000;
     if(ia == 1) nloop =1;
//
/*
#define  sp_mbd_disc_led           10
#define  sp_mbd_disc_charge_dac     4
#define  sp_mbd_disc_pulse_even     6
#define  sp_mbd_disc_pulse_odd      5
#define  sp_mbd_disc_disc_dac       1

#define  sp_mbd_clk_delay_setting   6

#define  sp_mbd_clk_pulse           1
#define  sp_mbd_clk_delay_off       0
#define  sp_mbd_clk_delay_on        2
#define  sp_mbd_clk_add            22
#define  sp_cntrl_loopback_on       1
#define  sp_cntrl_loopback_off      2
#define  sp_cntrl_offline           3
#define  sp_cntrl_online            4
#define  sp_cntrl_isprst_on         5
#define  sp_cntrl_isprst_off        6
#define  sp_cntrl_seldisc_off       0
#define  sp_cntrl_seldisc_on        7
#define  sp_cntrl_seldisc_add      31
*/
     for (ic=0; ic<100000; ic++ ){
      printf(" MBD sytem test routine \n");
      printf("    1 set the clock fanout delay \n");
      printf("    2 send test pulse from clock module \n");
      printf("    3 set discriminator charge injector DAC \n");
      printf("    4 set discriminator firing pattern \n");
      printf("    5 set discriminator threshold level\n");
      printf("    6 set clock module delay chip \n");
      scanf("%d", &itest);
      switch (itest){
       case 1:
        printf(" set clock fanout delay, 1 for on, 0 for off \n");
        scanf("%d",&ia);
        for (ik=0; ik<nloop; ik++) {
        imod = sp_mbd_clk_add;
        ichip=0;
        if(ia == 0) buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16); //enable delay on
        else buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_on)+(0x0<<16); //enable delay ff
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//        scanf("%d",&ia);
        usleep(10);
        }
        scanf("%d",&ia);
        break;
       case 2:
        printf(" send test pulse from clock module \n");
        for (ik=0; ik<nloop; ik++) {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
        break;
       case 3:
        printf(" set discriminator charge injector DAC \n");
//        printf(" enter channel number \n");
//        scanf("%d",&idisc_ch);
        printf(" enter charge injector DAC value \n");
        scanf("%d",&idisc_dac);
//
         imod = imod_disc;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         break;
       case 4:
        printf(" discrimintaor pulse, 1 for odd, 0 for even \n");
        scanf("%d",&ia);
        if(ia == 0) ijk = sp_mbd_disc_pulse_even;
        else ijk = sp_mbd_disc_pulse_odd;
        for (ik=0; ik<nloop; ik++) {
         imod = imod_disc;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(0x1<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
//
//
         imod = imod_disc;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

        }
        break;
//
//
       case 5:
        printf(" dicriminator threshold DAC setting \n");
        printf(" enter the channel number, 8 for all channel \n");
        scanf("%d", &idisc_ch);
        printf(" enter the DAC value in hex \n");
        scanf("%x", &idisc_thr);

        if(idisc_ch !=8) {
         imod = imod_disc;
         ichip=0;
         ijk = ((idisc_ch & 0x7)<<12) + (idisc_thr &0xfff);
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
        else {
         for (ib=0; ib<8; ib++) {
          imod = imod_disc;
          ichip=0;
          ijk = ((ib & 0x7)<<12) + (idisc_thr &0xfff);
          buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
          i=1;
          k=1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
         }
        }
        break;
       case 6:
        printf(" set MBD clock module delay setting \n");
//        printf(" enter channel number \n");
//        scanf("%d",&idisc_ch);
        printf(" enter delay chip setting \n");
        scanf("%x",&mbd_delay_setting);
//
         imod = sp_mbd_clk_add;
         ichip=0;
//         ic = (mbd_delay_setting & 0xff) << 8;
         ic = mbd_delay_setting;
         printf(" delay setting %x \n", ic);
//        for (ia=0; ia< 100000000; ia++) {
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_setting)+ ((ic & 0xffff)<<16) ;
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
//         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_setting)+((0 & 0xffff)<<16) ;
         i=1;
         k=1;
//         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
//        }
         break;

//
//
       }
      }
     break;


    case 15:
//
//
     nloop=100 ;
     nevent =6000;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;
     l1_delay=12;
     itest_ram = 0;
     imod_disc = 10;
     nsample = 20;
//
     printf(" l1 delay \n");
     scanf("%d",&l1_delay);
     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
//     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite == 1) {
      printf(" type 1 for binary write \n");
      scanf("%d",&ibin);
      if(ibin == 1) outf = fopen("/home/chi/test_binary.dat","w");
      else outf = fopen("/home/chi/test.dat","w");
     }
     printf(" test pulse firing pattern \n");
     printf(" 0 for no test pulse, 1 for odd, 2 for even and 3 for both \n");
     scanf("%d",&itest_pattern);
     printf(" type 1 for alternate delay to test pulse \n");
     scanf("%d",&test_pulse_d);
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;


//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset, 10 to get off the loop\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//   set slow control to discriminator system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_on;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set controller slow control go to MBD system \n");
//     scanf("%d",&ia);
//
//
//
//*************
     idisc_dac = 4000;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the discriminator charge injector \n");
     scanf("%d",&i);
//
//    low true
//
     if(itest_pattern == 0) {
       itest_odd =1;
       itest_even =1;
     }
     else if (itest_pattern == 1) {
       itest_odd =0;
       itest_even =1;
     }
     else if (itest_pattern == 2) {
       itest_odd =1;
       itest_even =0;
     }
     else {
       itest_odd =0;
       itest_even =0;
     }


     ijk = sp_mbd_disc_pulse_odd;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_odd<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

     ijk = sp_mbd_disc_pulse_even;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_even<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the discriminator charge injector  patten \n");
     scanf("%d",&i);
//
//
//
     idisc_thr =20; // set discriminator threshold level
     for (ib=0; ib<8; ib++) {
      imod = imod_disc;
      ichip=0;
      ijk = ((ib & 0x7)<<12) + (idisc_thr &0xfff);
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
     printf(" set the discriminator threshold level \n");
     scanf("%d",&i);



//
//
/*
     for (ik=0; ik<100000000; ik++) {
      imod = sp_mbd_clk_add;
      ichip=0;
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
*/
//
//   set slow control back to ADC system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_off;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
     printf(" enter 1 to reset through ADC\n");
     scanf("%d",&i);
//
//   send reset to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_reset+ (0<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);


//
//   set sample size  -- to 10
//
     printf(" type 1 to send sample size \n");
     scanf("%d",&is);



     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
      printf(" type 1 to set L1 delay \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//    if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
     printf(" buf_send = %x\n", buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set select L1 trigger on
//
     printf(" type 1 to select L1 trigger \n");
     scanf("%d",&is);
     if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
     if(isel_xmit == 1) {
      if(imod != imod_start) {
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" rx_off called , module %d\n", imod);
      }
     }
     printf(" call adc setup  module %d\n", imod);
     i = adc_setup(hDev,imod, 1);
     scanf("%d",&is);
//sp_adc_sel_link_rxoff


//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
      for (ia=0; ia<nevent; ia++) {
       if(iwrite != 1) {
        printf(" type 1 to send L1 trigger \n");
        scanf("%d",&is);
       }

       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
         printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
         printf (" module address = %d \n" ,(read_array[0] & 0x1f));
         printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
         printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
         printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
         printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
         printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
         printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
         printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
         printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
         printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
         printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
         printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        }
       }



//     for (ijk=0; ijk<1000000000; ijk++) {
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212
//
//
//
//   set slow control to discrimeter
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_on;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);
       if(iwrite != 1) {
        printf(" set slow control to discriminator  \n");
        scanf("%d",&is);
       }


//
//#define  sp_mbd_clk_delay_off       0
//#define  sp_mbd_clk_delay_on        2//   send init to the controller
//
       if(iwrite != 1) {
        printf(" enter 1 to send MBD test pulse and L1 trigger\n");
        scanf("%d",&i);
       }
//      for (ik=0; ik<100000000; ik++) {
       if(test_pulse_d == 1) {
        if((ia%2) ==0 ) {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
        else {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_on)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
       }
       else {
        imod = sp_mbd_clk_add;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16);
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
       }
//       printf(" set discriminator pulse  \n");
//       scanf("%d",&is);


       imod = sp_mbd_clk_add;
       ichip=0;
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }
//       printf(" set slow control to discriminator  \n");
//       scanf("%d",&is);


///

//
//   set slow control back to ADC system
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_off;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0x0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);


//      }
/*
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }
*/


//
//
//

//

       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
         iparity = iparity ^ read_array[is];
        }
        if ((iwrite == 1)) {
         if(ibin ==0) fprintf(outf," %x\n", read_array[0]);
         if(ibin ==0) fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if((iwrite == 1)) {
          if(ibin == 0) fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if((iwrite == 1)) {
          if(((k%8) ==0) && (ibin ==0)) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
//         if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }
        if((iwrite ==1) && (ibin == 1)) {
         fwrite(&nread, sizeof(UINT32), 1, outf);
         fwrite(&read_array, sizeof(UINT32), nread, outf);
        }
        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) {
          if(ibin == 0) fprintf(outf,"\n");
        }
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
           printf(" %4x", adc_data[is][k]);
          }
          printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
//     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
       if(iwrite ==1) {
        if((ia%10) == 0) printf(" write evennt = %d \n", ia);
       }
      }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
    break;


    case 16:
//
//
     nloop=100 ;
     nevent =6000;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;
     l1_delay=12;
     itest_ram = 0;
     imod_disc = 10;
     nsample = 20;
//
     printf(" l1 delay \n");
     scanf("%d",&l1_delay);
     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     printf(" discriminator module address \n");
     scanf("%d",&imod_disc);
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite == 1) {
      printf(" type 1 for binary write, 2 for /dev/null \n");
      scanf("%d",&ibin);
      if(ibin == 1) outf = fopen("/home/chi/test_binary.dat","w");
      else if (ibin ==2) outf = fopen("/dev/null","w");
      else outf = fopen("/home/chi/test_l_dac.dat","w");
     }
     printf(" test pulse firing pattern \n");
     printf(" 0 for no test pulse, 1 for odd, 2 for even and 3 for both \n");
     scanf("%d",&itest_pattern);
     printf(" type 1 for alternate delay to test pulse \n");
     scanf("%d",&test_pulse_d);
     printf(" enter delay chip setting \n");
     scanf("%x",&mbd_delay_setting);
     printf(" type 1 for clock delay setting forever\n");
     scanf("%d", &i);
     if(i==0) mbd_delay_loop=1;
     else mbd_delay_loop = 10000000000;

//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to test charge inject DAC \n");
     scanf("%d", &idac_scan);
//     scanf("%d", &igen);
     if(idac_scan == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      nevent = nstep*nstep_event;
//      printf(" enter test pattern %x \n");
//      scanf("%x", &ipattern);
     }
     printf(" enter 1 to test pulse delay scan \n");
     scanf("%d", &itp_scan);
//     scanf("%d", &igen);
     if(itp_scan == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" test pulse increment per step \n");
      scanf("%d", &nstep_tp);
      nevent = nstep*nstep_event;
//      printf(" enter test pattern %x \n");
//      scanf("%x", &ipattern);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;


//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset, 10 to get off the loop\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//   set slow control to discriminator system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_on;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set controller slow control go to MBD system \n");
//     scanf("%d",&ia);
//
//
//
//*************
     idisc_dac = 4000;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the discriminator charge injector \n");
     scanf("%d",&i);
//
//    low true
//
     if(itest_pattern == 0) {
       itest_odd =1;
       itest_even =1;
     }
     else if (itest_pattern == 1) {
       itest_odd =0;
       itest_even =1;
     }
     else if (itest_pattern == 2) {
       itest_odd =1;
       itest_even =0;
     }
     else {
       itest_odd =0;
       itest_even =0;
     }


     ijk = sp_mbd_disc_pulse_odd;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_odd<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

     ijk = sp_mbd_disc_pulse_even;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_even<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the discriminator charge injector  patten \n");
     scanf("%d",&i);
//
//
//
     idisc_thr =10; // set discriminator threshold level
     for (ib=0; ib<8; ib++) {
      imod = imod_disc;
      ichip=0;
      ijk = ((ib & 0x7)<<12) + (idisc_thr &0xfff);
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
     printf(" set the discriminator threshold level \n");
     scanf("%d",&i);
//
//
//
     imod = sp_mbd_clk_add;
     ichip=0;
//         ic = (mbd_delay_setting & 0xff) << 8;
     ic = mbd_delay_setting;
     printf(" delay setting %x \n", ic);
     for (ia=0; ia< mbd_delay_loop; ia++) {
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_setting)+ ((ic & 0xffff)<<16) ;
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
     printf(" set the test pulse delay setting \n");
     scanf("%d",&i);


//
//
//



//
//
/*
     for (ik=0; ik<100000000; ik++) {
      imod = sp_mbd_clk_add;
      ichip=0;
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
*/
//
//   set slow control back to ADC system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_off;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
     printf(" enter 1 to reset through ADC\n");
     scanf("%d",&i);
//
//   send reset to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_reset+ (0<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);


//
//   set sample size  -- to 10
//
     printf(" type 1 to send sample size \n");
     scanf("%d",&is);



     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
      printf(" type 1 to set L1 delay \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//    if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
     printf(" buf_send = %x\n", buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set select L1 trigger on
//
     printf(" type 1 to select L1 trigger \n");
     scanf("%d",&is);
     if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
     if(isel_xmit == 1) {
      if(imod != imod_start) {
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" rx_off called , module %d\n", imod);
      }
     }
     printf(" call adc setup  module %d\n", imod);
     i = adc_setup(hDev,imod, 1);
     scanf("%d",&is);
//sp_adc_sel_link_rxoff


//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
      for (ia=0; ia<nevent; ia++) {
       if(iwrite != 1) {
        printf(" type 1 to send L1 trigger \n");
        scanf("%d",&is);
       }

       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
         printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
         printf (" module address = %d \n" ,(read_array[0] & 0x1f));
         printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
         printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
         printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
         printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
         printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
         printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
         printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
         printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
         printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
         printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
         printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        }
       }



//     for (ijk=0; ijk<1000000000; ijk++) {
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212
//
//
//
//   set slow control to discrimeter
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_on;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);
       if(iwrite != 1) {
        printf(" set slow control to discriminator  \n");
        scanf("%d",&is);
       }
//*************
       if(idac_scan == 1) {
        ijk = ia%nstep_event;
        ib= (ia-ijk)/nstep_event;
        if(ijk ==0) {
         idisc_dac = ib*nstep_dac;
         imod = imod_disc;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
//        printf(" set the discriminator charge injector \n");
//        scanf("%d",&i);
       }
       if((ia ==0) && (iwrite ==1) && (idac_scan ==1)) {
        fprintf(outf," %d\n", nstep);
        fprintf(outf," %d\n", nstep_event);
        fprintf(outf," %d\n", nstep_dac);
       }
//
//
       if(itp_scan == 1) {
        ijk = ia%nstep_event;
        ib= (ia-ijk)/nstep_event;
        if(ijk ==0) {
         mbd_delay_setting = ib*nstep_tp;
         imod = sp_mbd_clk_add;
         ichip=0;
         ic = mbd_delay_setting;
         printf(" delay setting %x \n", ic);
//        for (ia=0; ia< 100000000; ia++) {
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_setting)+ ((ic & 0xffff)<<16) ;
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
//        printf(" set the discriminator charge injector \n");
//        scanf("%d",&i);
       }
       if((ia ==0) && (iwrite ==1) && (itp_scan ==1)) {
        fprintf(outf," %d\n", nstep);
        fprintf(outf," %d\n", nstep_event);
        fprintf(outf," %d\n", nstep_tp);
       }

//
//#define  sp_mbd_clk_delay_off       0
//#define  sp_mbd_clk_delay_on        2//   send init to the controller
//
       if(iwrite != 1) {
        printf(" enter 1 to send MBD test pulse and L1 trigger\n");
        scanf("%d",&i);
       }
//      for (ik=0; ik<100000000; ik++) {
       if(test_pulse_d == 1) {
/*
        if((ia%2) ==0 ) {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
        else {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_on)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
*/

         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_on)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

       }
       else {
        imod = sp_mbd_clk_add;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16);
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
       }
       
       if(iwrite != 1) {
        printf(" set discriminator pulse  \n");
        scanf("%d",&is);
       }


       imod = sp_mbd_clk_add;
       ichip=0;
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }
//       printf(" set slow control to discriminator  \n");
//       scanf("%d",&is);


///

//
//   set slow control back to ADC system
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_off;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0x0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);


//      }
/*
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }
*/


//
//
//

//

       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
         iparity = iparity ^ read_array[is];
        }
        if ((iwrite == 1)) {
         if(ibin ==0) fprintf(outf," %x\n", read_array[0]);
         if(ibin ==0) fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if((iwrite == 1)) {
          if(ibin == 0) fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if((iwrite == 1)) {
          if(((k%8) ==0) && (ibin ==0)) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
//         if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }
        if((iwrite ==1) && (ibin == 1)) {
         fwrite(&nread, sizeof(UINT32), 1, outf);
         fwrite(&read_array, sizeof(UINT32), nread, outf);
        }
        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) {
          if(ibin == 0) fprintf(outf,"\n");
        }
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
           printf(" %4x", adc_data[is][k]);
          }
          printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
//     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
       if(iwrite ==1) {
        if((ia%10) == 0) printf(" write evennt = %d \n", ia);
       }
      }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
    break;

    case 17:
//
//
     nloop=100 ;
     nevent =60000;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;
     l1_delay=12;
     itest_ram = 0;
     imod_disc = 10;
     nsample = 20;
     itest_pattern =0;
     test_pulse_d =0;
//
     printf(" l1 delay \n");
     scanf("%d",&l1_delay);
     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
//     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite == 1) {
      printf(" type 1 for binary write \n");
      scanf("%d",&ibin);
      if(ibin == 1) outf = fopen("/home/chi/test_binary.dat","w");
      else outf = fopen("/home/chi/test.dat","w");
     }
/*
     printf(" test pulse firing pattern \n");
     printf(" 0 for no test pulse, 1 for odd, 2 for even and 3 for both \n");
     scanf("%d",&itest_pattern);
     printf(" type 1 for alternate delay to test pulse \n");
     scanf("%d",&test_pulse_d);
*/
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;


//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset, 10 to get off the loop\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//   set slow control to discriminator system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_on;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set controller slow control go to MBD system \n");
//     scanf("%d",&ia);
//
//
//
//*************
     idisc_dac = 4000;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the discriminator charge injector \n");
     scanf("%d",&i);
//
//    active low
//

     if(itest_pattern == 0) {
       itest_odd =1;
       itest_even =1;
     }
     else if (itest_pattern == 1) {
       itest_odd =0;
       itest_even =1;
     }
     else if (itest_pattern == 2) {
       itest_odd =1;
       itest_even =0;
     }
     else {
       itest_odd =0;
       itest_even =0;
     }


     ijk = sp_mbd_disc_pulse_odd;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_odd<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

     ijk = sp_mbd_disc_pulse_even;
     imod = imod_disc;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_even<<16);
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

     printf(" set the discriminator charge injector  patten \n");
     scanf("%d",&i);
//
//
//
     idisc_thr =20; // set discriminator threshold level
     for (ib=0; ib<8; ib++) {
      imod = imod_disc;
      ichip=0;
      ijk = ((ib & 0x7)<<12) + (idisc_thr &0xfff);
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
     printf(" set the discriminator threshold level \n");
     scanf("%d",&i);



//
//
/*
     for (ik=0; ik<100000000; ik++) {
      imod = sp_mbd_clk_add;
      ichip=0;
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
*/
//
//   set slow control back to ADC system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_off;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
     printf(" enter 1 to reset through ADC\n");
     scanf("%d",&i);
//
//   send reset to the controller
//
     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_reset+ (0<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);


//
//   set sample size  -- to 10
//
     printf(" type 1 to send sample size \n");
     scanf("%d",&is);



     imod = imod_start;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
      printf(" type 1 to set L1 delay \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//    if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
     printf(" buf_send = %x\n", buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
     else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
     if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   set select L1 trigger on
//
     printf(" type 1 to select L1 trigger \n");
     scanf("%d",&is);
     if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
     if(isel_xmit == 1) {
      if(imod != imod_start) {
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" rx_off called , module %d\n", imod);
      }
     }
     printf(" call adc setup  module %d\n", imod);
     i = adc_setup(hDev,imod, 1);
     scanf("%d",&is);
//sp_adc_sel_link_rxoff


//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
      for (ia=0; ia<nevent; ia++) {
       if(iwrite != 1) {
        printf(" type 1 to send L1 trigger \n");
        scanf("%d",&is);
       }
       
//
//   set slow control to discrimeter
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_on;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);
       if(iwrite != 1) {
        printf(" set slow control to discriminator  \n");
        scanf("%d",&is);
       }
//
//     reset discriminator busy
//
       imod = sp_mbd_clk_add;
       ichip=0;
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_busy_reset)+(0x0<<16);
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);


//
//   set slow control back to ADC system
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_off;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0x0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);

       for (ik=0; ik<12000000; ik++) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
         printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
         printf (" module address = %d \n" ,(read_array[0] & 0x1f));
         printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
         printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
         printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
         printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
         printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
         printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
         printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
         printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
         printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
         printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
         printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        }
        if(((read_array[0]>>21) & 0x1) == 0) break;
        if(iwrite != 1) {
          printf(" receive trigger type 1 to continue\n");
          scanf("%d", &is);
        }
       }



//     for (ijk=0; ijk<1000000000; ijk++) {
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212
//
//
//


//      }
/*
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }
*/


//
//
//

//

       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
         iparity = iparity ^ read_array[is];
        }
        if ((iwrite == 1)) {
         if(ibin ==0) fprintf(outf," %x\n", read_array[0]);
         if(ibin ==0) fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if((iwrite == 1)) {
          if(ibin == 0) fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if((iwrite == 1)) {
          if(((k%8) ==0) && (ibin ==0)) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
//         if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }
        if((iwrite ==1) && (ibin == 1)) {
         fwrite(&nread, sizeof(UINT32), 1, outf);
         fwrite(&read_array, sizeof(UINT32), nread, outf);
        }
        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) {
          if(ibin == 0) fprintf(outf,"\n");
        }
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
           printf(" %4x", adc_data[is][k]);
          }
          printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
//     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
       if(iwrite ==1) {
        if((ia%10) == 0) printf(" write evennt = %d \n", ia);
       }
      }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
    break;

    case 18:
     nloop=100 ;
     nevent =200;
     imod_start=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;

     printf(" number of loop \n");
//    scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
//     if(iwrite ==1) outf = fopen("/home/chi/test11.dat","w");
     if(iwrite ==1) outf = fopen("/dev/null","w");
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" DAC start value \n");
      scanf("%d", &dac_start);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
     }
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent);


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,1);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,2);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev2,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
//    for (j=0; j<nloop; j++) {
     printf(" enter 1 for initialization \n");
     scanf("%d",&i);
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//     printf(" enter 1 for initialization \n");
//     scanf("%d",&i);
//    }
//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev2,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev2,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev2,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
//      printf(" type 1 to send sample size \n");
//      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
//      printf(" type 1 to send sample size");
//      scanf("%d",&is);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =1;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
      }


      if(ia <= 10) printf(" enter trigger loop \n");
//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         idac_shaper = idac_shaper *nstep_dac+dac_start;    //set up the dac value

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
      else if ((iext_trig != 1) & (igen != 1) )
       {
        if(ia <= 10) printf(" send controller trigger \n");
        if(iwrite != 1) scanf("%d",&is);
        buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
       }
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }

      if(iext_trig == 1) {
       if(isel_dcm != 1) {
        ik =0;
        while (ik != 1) {
         imod = imod_start;
         nword =1;
         py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
         ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
         buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
//
         i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
         ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         py = &read_array;
         i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
         if (((read_array[0] >>21) & 0x1) == 0) {
          printf(" trigger received \n");
          ik=1;
         }
        }
       }
       else {
//        printf(" enter DCM II event wait loop\n");
//
//      reset the busy from the controller
//
        buf_send[0]= (0x2<<8)+sp_cntrl_busyrst+ (0<<16);
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        nword = 2;
        i = pcie_rec(hDev,0,1,nword,iprint,py);       // init receiver
        ichip =5;
        buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_status_read;  /* turn on status read*/
        buf_send[1]=0x5555aaaa;
        ik = pcie_send(hDev, 1, 2, px);  //** for dcm2 status read send 2 words **//
        usleep(10);
        py = &read_array;
        i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//        printf(" DCMII FPGA 5 status word = %x , %x\n", read_array[0], read_array[1]);
//        if((read_array[0] & 0x10000000) == 0) printf(" DCM II buffer has event \n");
        if((read_array[0] & 0x40000000) != 0) printf(" DCM II buffer hold is on \n");
//        printf(" enter DCM status loop, type 1 to continue\n");
        while ( (read_array[0] & 0x10000000) != 0) {
//        for (ik=0; ik<10000; ik++) {
         nword = 2;
         i = pcie_rec(hDev,0,1,nword,iprint,py);       // init receiver
         ichip =5;
         buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_status_read;  /* turn on status read*/
         buf_send[1]=0x5555aaaa;
         ik = pcie_send(hDev, 1, 2, px);  //** for dcm2 status read send 2 words **//
         usleep(10);
         py = &read_array;
         i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//         printf(" DCMII FPGA 5 status word = %x , %x\n", read_array[0], read_array[1]);
//         if((read_array[0] & 0x10000000) == 0) printf(" DCM II buffer has event \n");
//        if((read_array[0] & 0x40000000) != 0) printf(" DCM II buffer hold is on \n");
//         printf(" enter DCM status loop, type 1 to continue\n");
//         scanf("%d", &i);
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if(i%8 == 7) fprintf(outf,"\n");
        }
        if((i%8) != 7) fprintf(outf,"\n");
       }

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
//       iparity =0;
       for (ic=0; ic< nmod; ic++ ){
        ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
        iparity =0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));

        for (is=0; is<4+(nsample*64); is++) {
         if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
         else {
          u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
          iparity = iparity ^ u32Data;
         }
        }
        ioffset_t = ioffset + (64*nsample+4)+6;   // 4 words header + 5 event header -1 for array started at 0
        i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff);
        if(i != iparity) {
         printf(" event = %d, module %d Partity error....... = %x %x\n", ia, (imod_start+ic), i, iparity);
         if(iwrite != 1) scanf("%d", &i);
        }
        if(iwrite != 1) printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

        if(iwrite != 1) {
         printf(" parity word = %x\n", iparity);
         printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
         scanf("%d", &i );
         for (is=0; is<nsample; is++) {
          for (k=0; k<32; k++) {
           adc_data[k*2][is] = read_array1[11+ioffset+((k*nsample+is)*2)] & 0xffff;
           adc_data[(k*2)+1][is] = read_array1[10+ioffset+((k*nsample+is)*2)] & 0xffff;
          }
         }
         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
          printf("\n");
         }
         scanf("%d", &i );
        }
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if (iwrite != 1) printf(" parity = %x  \n", iparity);
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%1000) == 0) printf(" write evennt = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;

    case 19:
    
     printf(" L1 trigger test routine 1\n");
//

/* set tx mode register */
//       u32Data = 0xf0000008;
       u32Data = 0x1000;
       dwOffset = tx_md_reg;
       dwAddrSpace =cs_bar;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//
     px = &buf_send;
     py = &read_array;
     printf(" enter 1 for initialization \n");
     scanf("%d",&i);
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
     printf(" enter the module number \n");
     scanf("%d", &imod);
     printf(" enter operation type \n");
     printf("    1 for send pll reset \n");
     printf("    2 for send reset for the transceiver \n");
     printf("    3 for send arst \n");
     printf("    4 for send drst \n");
     printf("    5 for send clr to the FIFO \n");
     printf("    6 for send RESET \n");
     printf("    7 for sending fake data \n");
     printf("    9 for the FEM to send data to LL1 \n");
     printf("   10 for the loopback \n");
     printf("   11 for the L1 loopback with ECC\n");
     scanf("%d", &itest);
     switch (itest) {

      case 1:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_rst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
       }


      break;

       case 2:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_reset<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
       }


      break;

       case 3:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_arst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px); 
        usleep(100);
       }


      break;

        case 4:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_drst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
       }


      break;

       case 5:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_clr<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px); 
        usleep(100);
       }


      break;

       case 6:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100000);
       }


      break;

/*
#define  sp_L1trig_test_rst         1
#define  sp_L1trig_test_reset       2
#define  sp_L1trig_test_arst        3
#define  sp_L1trig_test_drst        4
#define  sp_L1trig_test_clr         5
#define  sp_L1trig_test_RESET       6


#define   sp_l1trig_test_fk_data    0x40

*/
      case 7:
        printf(" enter channel number \n");
        scanf("%d", &ich);
        printf(" number of word \n");
        scanf("%d", &nword);
        printf(" number of events to run \n");
        scanf("%d", &nevent);
        printf(" data print \n");
        scanf("%d", &iprint_event);
        printf(" data check \n");
        scanf("%d", &icheck);
        printf(" enter 1 for randomize data \n");
        scanf("%d",&irand);
//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_rst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      reset the optical parts
//
        printf(" reset optical module \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

//
//         reset transmitter
//
        printf(" reset transmitter \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_arst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);

//
//      reset the receiver
//
        printf(" reset receiver \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_reset<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

        printf(" type 1 to contunue \n");
        scanf("%d", &i);

//       ichip = sp_L1trig_test_fk_data +10;
        for (ic=0; ic< nevent; ic++) {
         ichip = 0;
         for (ia=0; ia<(nword+1); ia++) {
          if(irand == 0) send_data_array[ia] = ia;
          else send_data_array[ia] = rand() & 0xffff;
//          printf(" rand = %x\n",send_array[ia]);
//          scanf("%d", &i);
         }
         for (ia=0; ia<(nword+1); ia++) {
          k=ia%2;
          ij = ia/2;
//         if((ia == 0) & (k == 0))  buf_send[0]=(imod <<11)+ (ichip << 8) + (0x40 + ich) + (ia<<16) ;
          if((ia == 0) & (k == 0))  buf_send[0]=(imod <<11)+ (ichip << 8) + (0x40 + ich) + (send_data_array[ia]<<16) ;
//         if((ia == 0) )  buf_send[0]=(imod <<11)+ (ichip << 8) + (sp_L1trig_test_fk_data+10); + (ia<<16) ;
          if((ia != 0) & (k == 0)) {
//          printf(" ia= %x, k= %x, ij = %x \n", ia, k, ij);
           buf_send[ij]= send_data_array[ia-1]+ (send_data_array[ia]<<16);
          }
//          printf(" ia= %d \n", send_data_array[ia]);
         }
         nread =nword/2;
//
//      initial the receiver
//
         i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
//
         i= 1;
         k=nword/2;
//         printf(" send array = %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2]);
         i = pcie_send_1(hDev, i, k, px);

//
//   8.3ns*16 per word    asume 200ns per word for safety
//   100 words => 100*200ns = 20 microsec
//
         i = nword;
         usleep(i);
//

//
//
//
         i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words

         ia=0;
         ib=0;

         if(iprint_event == 1) printf(" event = %d\n", ic);


         for (i=0; i<(nword/2); i++) {
          read_array_s[ib]= (read_array[i] & 0xffff);
          ib=ib+1;
          read_array_s[ib]= (read_array[i] >>16) & 0xffff;
          ib=ib+1;
          if(iprint_event == 1) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
         }
         if(iprint_event == 1) printf("\n");

         if(iprint_event == 1) {
          for (i=0; i<nword; i++) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array_s[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
          printf("\n");
         }

         if(icheck == 1) {
          for (i=1; i< nword-1; i++) {
           if(read_array_s[i] != send_data_array[i-1]) printf(" error event %d seq %d send %x, read= %x \n",
           ic, i, read_array_s[i], send_data_array[i-1]);
          }
         }
         if(iprint_event == 1) {
          printf(" type 1 to continue \n");
          scanf("%d",&ib);
         }
         if((ic%10000) == 0) printf(" event = %d\n", ic);
        }


//        printf(" read array = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        break;


//#define   sp_l1trig_test_ic2_wr     22
//#define   sp_l1trig_test_i2c_rd     23
       case 8:
//
//      reset the optical parts
//
        printf(" reset optical module \n");
//        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100000);
        scanf("%d", &i);

        i2c_mod_add = 0x58;
        i2c_write   = 0;
        i2c_read = 1;
        i2c_add     = 168 ;
//        for (is =0; is <10000000; is++) {
         ichip = 0;
         usleep(100000);                  // delay in the mili-second
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_l1trig_test_i2c_rd + ((i2c_mod_add +i2c_write)<<16) ;
         buf_send[1] =i2c_add+ ((i2c_mod_add+i2c_read)<<16);
         i= 1;
         k= 3;
         i = pcie_send_1(hDev, i, k, px);
         printf(" send array data %x, %x\n", buf_send[0], buf_send[1]);
         usleep(1000);
//        }
        break;

       case 9:
        printf(" FEM module number \n");
        scanf("%d", &imod_fem);
        printf(" number of word to send \n");
        scanf("%d", &nword);
        printf(" number of events to run \n");
        scanf("%d", &nevent);
        printf(" data print \n");
        scanf("%d", &iprint_event);
        printf(" data check \n");
        scanf("%d", &icheck);
        printf(" enter 1 for randomize data \n");
        scanf("%d",&irand);


        px = &buf_send;
        py = &read_array;
/** initialize **/
/*      if(j ==0) { */
        buf_send[0]=0x0;
        buf_send[1]=0x0;
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
//   send init to the controller
//
        buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

         buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
// #define  sp_adc_trigopt_sub         7
// #define  sp_adc_trigopt_fake        1
//

//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_rst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      reset the optical parts
//
        printf(" reset optical module \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

//
//         reset transmitter
//
        printf(" reset transmitter \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_arst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);

//
//      reset the receiver
//
        printf(" reset receiver \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_reset<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_clr<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);


//        printf(" type 1 to contunue \n");
//        scanf("%d", &i);

//        iprint_event =1;
//
         istart_beg = 0;
         error_count = 0;

         for (is=0; is<nevent; is++) {
          if(iprint_event == 1) {
           printf(" type 1 to continue \n");
           scanf("%d", &i);
          }
//          imod = imod_fem;
          ichip = sp_adc_trigopt_sub;
          nread =nword/2;
//          nword =100;
//
//      initial the receiver
//
          i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
//
          for (ia=0; ia<(nword+1); ia++) {
//           send_data_array[ia] =ia;
           if(irand == 0) send_data_array[ia] = (ia+istart_beg) & 0xffff;
           else send_data_array[ia] = rand() & 0xffff;

           k=ia%2;
           ij = ia/2;
//         if((ia == 0) & (k == 0))  buf_send[0]=(imod <<11)+ (ichip << 8) + (0x40 + ich) + (ia<<16) ;
           if((ia == 0) & (k == 0))  buf_send[0]=(imod_fem <<11)+ (ichip << 8) + sp_adc_trigopt_fake + (send_data_array[ia]<<16) ;
//         if((ia == 0) )  buf_send[0]=(imod <<11)+ (ichip << 8) + (sp_L1trig_test_fk_data+10); + (ia<<16) ;
           if((ia != 0) & (k == 0)) {
//          printf(" ia= %x, k= %x, ij = %x \n", ia, k, ij);
            buf_send[ij]= send_data_array[ia-1]+ (send_data_array[ia]<<16);
           }
//          printf(" ia= %d \n", send_data_array[ia]);
          }
          istart_beg = istart_beg + nword;
          i= 1;
          k=nword/2;
//         printf(" send array = %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2]);
          i = pcie_send_1(hDev, i, k, px);
//
//
//
//   8.3ns*16 per word    asume 200ns per word for safety
//   100 words => 100*200ns = 20 microsec
//
          i = nword;
          usleep(i);
//
//
          if(iprint_event == 1) {
           printf(" type 1 to send the read \n");
           scanf("%d", &i);
          }
//
          ichip = 0;
          buf_send[0]=(imod <<11)+ (ichip << 8) + 0x6 + (sp_L1trig_test_RESET<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(100);

//
//
//
          i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words

          ia=0;
          ib=0;

          if(iprint_event == 1) printf(" event = %d\n", ic);


          for (i=0; i<(nword/2); i++) {
           read_array_s[ib]= (read_array[i] & 0xffff);
           ib=ib+1;
           read_array_s[ib]= (read_array[i] >>16) & 0xffff;
           ib=ib+1;
           if(iprint_event == 1) {
            if((i%8) == 0) printf("%4d", (i/8));
            printf(" %8x", read_array[i]);
            if(((i+1)%8) == 0) printf("\n");
           }
          }
          if(iprint_event == 1) printf("\n");
//
//
          if(iprint_event == 1) {
           for (i=0; i<nword; i++) {
            if((i%8) == 0) printf("%4d", (i/8));
            printf(" %8x", read_array_s[i]);
            if(((i+1)%8) == 0) printf("\n");
           }
           printf("\n");
          }
//
//
/*       for non ecc checking....
         if(icheck == 1) {
          for (i=1; i< nword-1; i++) {
           if(read_array_s[i] != send_data_array[i-1]) printf(" error event %d seq %d send %x, read= %x \n",
           ic, i, read_array_s[i], send_data_array[i-1]);
          }
         }
*/
/*
          if(icheck == 1) {
           for (i=2; i< nword-10; i++) {
            if(read_array_s[i] != send_data_array[i-2]) printf(" error event %d seq %d read %x, send= %x \n",
           ic, i, read_array_s[i], send_data_array[i-2]);
           }
          }
*/


//          if(icheck == 1) {
//           for (i=0; i< nword-3; i++) {
//            if(read_array_s[i] != send_data_array[i]) printf(" error event %d seq %d read %x, send = %x \n",
//            is, i, read_array_s[i], send_data_array[i]);
//           }
//          }
          if(iprint_event == 1) {
           printf(" type 1 to continue \n");
           scanf("%d",&ib);


          }
//          if((is%10000) == 0) printf(" event = %d\n", is);


//
//      initial the receiver for status
//
          nread =4;
          i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

          if(iprint_event == 1) {
           printf(" read status \n");
           scanf("%d", &i);
          }


          ichip = 0;
          buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_status + (sp_L1trig_test_clr<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(100);
//
//
          i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
          if(iprint_event == 1) printf(" status word %x, %x, %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3]);
          i = read_array[0];
          locked1 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
          i = read_array[0] >> 16;
          locked2 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
          i = read_array[1];
          locked3 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
          i = read_array[1] >> 16;
          locked4a = i & 0x1;
          locked4b = (i & 0x100)>> 8;
          if(iprint_event == 1) printf(" locked status %x, %x, %x, %x, %x\n", locked1, locked2, locked3, locked4a, locked4b);
          err_cor_cnt = read_array[2] & 0xff;
          err_det_cnt = (read_array[2] >> 8) & 0xff;
          err_fat_cnt = (read_array[2] >> 16) & 0xff;
          if(iprint_event == 1) printf(" error correction count %x, error detect count %x, error fatal count %x\n", err_cor_cnt, err_det_cnt, err_fat_cnt);
          temp = (((read_array[3] & 0xffff)*693.0/1024)-265.0);
          if(iprint_event == 1) printf (" temp readback =  %x, %6.1f\n", (read_array[3] & 0xffff), temp);



//sp_L1trig_test_status
          ierror = 0;
          if(icheck == 1) {
           for (i=2; i< nword-21; i++) {
            if(read_array_s[i] != send_data_array[i-2]) {
             printf(" error event %d seq %d read %x, send = %x \n", is, i, read_array_s[i], send_data_array[i-2]);
             ierror =1;
             error_count = error_count+1;
//             printf(" type 1 to continue \n");
//             scanf("%d",&ib);

            }
           }
          }
          if(ierror == 1) printf(" error correction count %x, error detect count %x, error fatal count %x error counter = %d \n", err_cor_cnt, err_det_cnt, err_fat_cnt, error_count);
          if(iprint_event == 1) {
           printf(" type 1 to continue \n");
           scanf("%d",&ib);
          }
          if((is%10000) == 0) {
           printf(" event = %d\n", is);
           printf (" temp readback =  %x, %6.1f\n", (read_array[3] & 0xffff), temp);
           printf(" error correction count %x, error detect count %x, error fatal count %x\n", err_cor_cnt, err_det_cnt, err_fat_cnt);
          }

         }





       break;
       
      case 10:
        printf(" enter channel number \n");
        scanf("%d", &ich);
        printf(" number of word \n");
        scanf("%d", &nword);
        printf(" number of events to run \n");
        scanf("%d", &nevent);
        printf(" data print \n");
        scanf("%d", &iprint_event);
        printf(" data check \n");
        scanf("%d", &icheck);
        printf(" enter 1 for randomize data \n");
        scanf("%d",&irand);
//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_rst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      reset the optical parts
//
        printf(" reset optical module \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

//
//         reset transmitter
//
        printf(" reset transmitter \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_arst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);

//
//      reset the receiver
//
        printf(" reset receiver \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_reset<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

        printf(" type 1 to contunue \n");
        scanf("%d", &i);

//       ichip = sp_L1trig_test_fk_data +10;

        ierr_event =0;
        event_err_count = 0;
        data_err_count = 0;
        for (ic=0; ic< nevent; ic++) {
         ichip = 0;
         for (ia=0; ia<(nword+1); ia++) {
          if(irand == 0) send_data_array[ia] = ia;
          else send_data_array[ia] = rand() & 0xffff;
          if(ia <= (nword-5)) checksum = checksum + send_data_array[ia];
          if(ia == (nword-4)) send_data_array[ia] = checksum & 0xffff;
          if(ia == (nword-3)) send_data_array[ia] = (checksum>>16) & 0xffff;
//          printf(" rand = %x\n",send_array[ia]);
//          scanf("%d", &i);
         }
         for (ia=0; ia<(nword+1); ia++) {
          k=ia%2;
          ij = ia/2;
//         if((ia == 0) & (k == 0))  buf_send[0]=(imod <<11)+ (ichip << 8) + (0x40 + ich) + (ia<<16) ;
          if((ia == 0) & (k == 0))  buf_send[0]=(imod <<11)+ (ichip << 8) + (0x40 + ich) + (send_data_array[ia]<<16) ;
//         if((ia == 0) )  buf_send[0]=(imod <<11)+ (ichip << 8) + (sp_L1trig_test_fk_data+10); + (ia<<16) ;
          if((ia != 0) & (k == 0)) {
//          printf(" ia= %x, k= %x, ij = %x \n", ia, k, ij);
           buf_send[ij]= send_data_array[ia-1]+ (send_data_array[ia]<<16);
          }
//          printf(" ia= %d \n", send_data_array[ia]);
         }
         nread =nword/2;
//
//      initial the receiver
//
         i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
//
         i= 1;
         k=nword/2;
//         printf(" send array = %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2]);
         i = pcie_send_1(hDev, i, k, px);

//
//   8.3ns*16 per word    asume 200ns per word for safety
//   100 words => 100*200ns = 20 microsec
//
         i = nword;
         usleep(i);
//

//
//
//
         i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words

         ia=0;
         ib=0;

         if(iprint_event == 1) printf(" event = %d\n", ic);


         for (i=0; i<(nword/2); i++) {
          read_array_s[ib]= (read_array[i] & 0xffff);
          ib=ib+1;
          read_array_s[ib]= (read_array[i] >>16) & 0xffff;
          ib=ib+1;
          if(iprint_event == 1) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
         }
         if(iprint_event == 1) printf("\n");

         if(iprint_event == 1) {
          for (i=0; i<nword; i++) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array_s[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
          printf("\n");
         }
//        ierr_event =0;
//        event_err_count = 0;
//        data_err_count = 0;

          if(icheck == 1) {
           for (i=0; i< nword-3; i++) {
            if(read_array_s[i] != send_data_array[i]) {
              printf(" error event %d seq %d read %x, send = %x \n", ic, i, read_array_s[i], send_data_array[i]);
              if(ic != ierr_event) {
                ierr_event = ic;
                event_err_count = event_err_count+1;
              }
              data_err_count = data_err_count+1;
            }
           }
          }
//         if(icheck == 1) {
//          for (i=1; i< nword-1; i++) {
//           if(read_array_s[i] != send_data_array[i-1]) printf(" error event %d seq %d send %x, read= %x \n",
//           ic, i, read_array_s[i], send_data_array[i-1]);
//          }
//         }
         if(iprint_event == 1) {
          printf(" type 1 to continue \n");
          scanf("%d",&ib);
         }
         if((ic%10000) == 0) printf(" event = %d, event_error_count =%d, data_error_count = %d\n", ic, event_err_count, data_err_count);
        }


//        printf(" read array = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        break;
//
//
//
      case 11:
        printf(" enter channel number \n");
        scanf("%d", &ich);
        printf(" number of word \n");
        scanf("%d", &nword);
        printf(" number of events to run \n");
        scanf("%d", &nevent);
        printf(" data print \n");
        scanf("%d", &iprint_event);
        printf(" data check \n");
        scanf("%d", &icheck);
        printf(" enter 1 for randomize data \n");
        scanf("%d",&irand);
//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_rst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      reset the optical parts
//
        printf(" reset optical module \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

//
//         reset transmitter
//
        printf(" reset transmitter \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_arst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);

//
//      reset the receiver
//
        printf(" reset receiver \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_reset<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

        printf(" type 1 to send clr fifo\n");
        scanf("%d", &i);
        
        ichip = 0;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_clr<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px); 
        usleep(100);


        printf(" type 1 to contunue \n");
        scanf("%d", &i);

        istart_beg =0;
//       ichip = sp_L1trig_test_fk_data +10;

        error_count =0;
        for (ic=0; ic< nevent; ic++) {
         ichip = 0;
         for (ia=0; ia<(nword+1); ia++) {
          if(irand == 0) send_data_array[ia] = (ia+istart_beg) &0xffff;
          else send_data_array[ia] = rand() & 0xffff;
//          printf(" rand = %x\n",send_array[ia]);
//          scanf("%d", &i);
         }
         istart_beg = istart_beg + nword;
         for (ia=0; ia<(nword+1); ia++) {
          k=ia%2;
          ij = ia/2;
//         if((ia == 0) & (k == 0))  buf_send[0]=(imod <<11)+ (ichip << 8) + (0x40 + ich) + (ia<<16) ;
          if((ia == 0) & (k == 0))  buf_send[0]=(imod <<11)+ (ichip << 8) + (0x40 + ich) + (send_data_array[ia]<<16) ;
//         if((ia == 0) )  buf_send[0]=(imod <<11)+ (ichip << 8) + (sp_L1trig_test_fk_data+10); + (ia<<16) ;
          if((ia != 0) & (k == 0)) {
//          printf(" ia= %x, k= %x, ij = %x \n", ia, k, ij);
           buf_send[ij]= send_data_array[ia-1]+ (send_data_array[ia]<<16);
          }
//          printf(" ia= %d \n", send_data_array[ia]);
         }
         nread =nword/2;
//
//      initial the receiver
//
         i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
//
         i= 1;
         k=nword/2;
//         printf(" send array = %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2]);
         i = pcie_send_1(hDev, i, k, px);

//
//   8.3ns*16 per word    asume 200ns per word for safety
//   100 words => 100*200ns = 20 microsec
//
         i = nword;
         usleep(i);
//

//
//
//
         i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words

         ia=0;
         ib=0;

         if(iprint_event == 1) printf(" event = %d\n", ic);


         for (i=0; i<(nword/2); i++) {
          read_array_s[ib]= (read_array[i] & 0xffff);
          ib=ib+1;
          read_array_s[ib]= (read_array[i] >>16) & 0xffff;
          ib=ib+1;
          if(iprint_event == 1) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
         }
         if(iprint_event == 1) printf("\n");

         if(iprint_event == 1) {
          for (i=0; i<nword; i++) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array_s[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
          printf("\n");
         }

//
//      initial the receiver for status
//
         nread =4;
         i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

         if(iprint_event == 1) {
           printf(" read status \n");
           scanf("%d", &i);
         }


         ichip = 0;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_L1trig_test_status + (sp_L1trig_test_clr<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(100);
//
//
         i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
         if(iprint_event == 1) printf(" status word %x, %x, %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3]);
         i = read_array[0];
         locked1 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
         i = read_array[0] >> 16;
         locked2 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
         i = read_array[1];
         locked3 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
         i = read_array[1] >> 16;
         locked4a = i & 0x1;
         locked4b = (i & 0x100)>> 8;
         if(iprint_event == 1) printf(" locked status %x, %x, %x, %x, %x\n", locked1, locked2, locked3, locked4a, locked4b);
         err_cor_cnt = read_array[2] & 0xff;
         err_det_cnt = (read_array[2] >> 8) & 0xff;
         err_fat_cnt = (read_array[2] >> 16) & 0xff;
         if(iprint_event == 1) printf(" error correction count %x, error detect count %x, error fatal count %x\n", err_cor_cnt, err_det_cnt, err_fat_cnt);
         temp = (((read_array[3] & 0xffff)*693.0/1024)-265.0);
         if(iprint_event == 1) printf (" temp readback =  %x, %6.1f\n", (read_array[3] & 0xffff), temp);



//sp_L1trig_test_status
         ierror = 0;
         if(icheck == 1) {
          for (i=1; i< nword-21; i++) {
           if(read_array_s[i] != send_data_array[i-1]) {
             printf(" error event %d seq %d send %x, read= %x \n", ic, i, read_array_s[i], send_data_array[i-1]);
             ierror =1;
             error_count = error_count+1;
           }
          }
         }
         if(ierror == 1) printf(" error correction count %x, error detect count %x, error fatal count %x error_counter %d\n", err_cor_cnt, err_det_cnt, err_fat_cnt, error_count);
         if(iprint_event == 1) {
          printf(" type 1 to continue \n");
          scanf("%d",&ib);
         }
         if((ic%10000) == 0) {
           printf(" event = %d\n", ic);
           printf (" temp readback =  %x, %6.1f\n", (read_array[3] & 0xffff), temp);
           printf(" error correction count %x, error detect count %x, error fatal count %x\n", err_cor_cnt, err_det_cnt, err_fat_cnt);
         }
        }


//        printf(" read array = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        break;



     }



     break;

    case 20:
     nloop =10;
     nevent= 10;
     imod_start = 18;
     nmod =1;
     isel_xmit =0;
     iwrite =1;
     ipulse = 0;
     iext_trig =0;
     igen=1;
     nstep = 40;
     nstep_event = 100;
     nstep_dac =100;
     ipattern = 0xffff;
     l1_delay = 40;
     itest_ram = 0;

     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
//     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
//     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
//     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
//     scanf("%d",&iwrite);
     if(iwrite ==1) outf = fopen("/home/chi/test.dat","w");
//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
//      scanf("%d", &nstep);
      printf(" event per step \n");
//      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
//      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
//      scanf("%x", &ipattern);
     }
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent); 


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
//      scanf("%d", &l1_delay);
     }
     
     printf(" enter 1 to load ADC test data memory\n");
//     scanf("%d", &itest_ram);

     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,1);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,2);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev2,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev2,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev2,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev2,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
         
/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
      if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
      if(itest_ram == 1) {
       printf(" call adc setup  module %d\n", imod);
       scanf("%d",&is);
       i = adc_testram_load(hDev,imod, 400);
      }
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =1;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
      }



//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         idac_shaper = idac_shaper *nstep_dac;    //set up the dac value

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
      else if (itest_ram == 1) {
       printf(" send test pulse trigger \n");
       scanf("%d", &i);
       ichip = sp_adc_slowcntl_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
      }
      else if ((iext_trig != 1) & (igen != 1) & (itest_ram != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is); 
       }
      }
      
      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
         printf(" trigger received \n");
         ik=1;
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if(i%8 == 7) fprintf(outf,"\n");
        }
        if((i%8) != 7) fprintf(outf,"\n");
       }

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
       iparity =0;
       for (is=0; is<4+(nsample*64); is++) {
        if(is%2 == 0) u32Data = (read_array1[is+6] & 0xffff) <<16;
        else {
         u32Data = u32Data + (read_array1[is+6] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
         iparity = iparity ^ u32Data;
        }
       }
       i= ((read_array1[778] & 0xffff) <<16) +(read_array1[779] & 0xffff);
       if(i != iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia, i, iparity);
         scanf("%d", &i);
       }
       printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

       if(iwrite != 1) {
        printf(" parity word = %x\n", iparity);
        printf(" packet parity word = %x\n", (((read_array1[778] & 0xffff) <<16) +(read_array1[779] & 0xffff)));
        scanf("%d", &i );
        for (is=0; is<nsample; is++) {
         for (k=0; k<32; k++) {
          adc_data[k*2][is] = read_array1[11+((k*nsample+is)*2)] & 0xffff;
          adc_data[(k*2)+1][is] = read_array1[10+((k*nsample+is)*2)] & 0xffff;
         }
        }
        for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
         printf(" %4x", adc_data[is][k]);
        }
         printf("\n");
        }
        scanf("%d", &i );
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
          if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }

        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write evennt = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;



    case 21:
//
//
     nloop=100 ;
     nevent =6000;
     imod_start=18;
     imod_timing=18;
     nmod=1;
     isel_xmit =0;
     iwrite =0;
     ipulse =0;
     iext_trig =0;
     igen = 0;
     l1_delay=12;
     itest_ram = 0;
     imod_disc = 10;
     nsample = 20;



//
     printf(" l1 delay \n");
     scanf("%d",&l1_delay);
     printf(" number of loop \n");
//     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" adc module timing slot number \n");
     scanf("%d",&imod_timing);
     printf(" 1st module slot number \n");
     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
     scanf("%d", &nmod);
     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     printf(" number of discriminator module \n");
     scanf("%d", &ndisc_mod);
     for (i=0; i<ndisc_mod; i++) {
      printf(" discriminator module address \n");
      scanf("%d",&ndisc_mod_add[i]);
     }
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite == 1) {
      printf(" type 1 for binary write, 2 for /dev/null \n");
      scanf("%d",&ibin);
      if(ibin == 1) outf = fopen("/home/chi/test_binary.dat","w");
      else if (ibin ==2) outf = fopen("/dev/null","w");
      else outf = fopen("/home/chi/test_l_dac.dat","w");
     }
     printf(" test pulse firing pattern \n");
     printf(" 0 for no test pulse, 1 for odd, 2 for even and 3 for both \n");
     scanf("%d",&itest_pattern);
     printf(" type 1 for alternate delay to test pulse \n");
     scanf("%d",&test_pulse_d);
     printf(" enter delay chip setting \n");
     scanf("%x",&mbd_delay_setting);

//
//
//
     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     printf(" enter 1 to test charge inject DAC \n");
     scanf("%d", &idac_scan);
//     scanf("%d", &igen);
     if(idac_scan == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      nevent = nstep*nstep_event;
//      printf(" enter test pattern %x \n");
//      scanf("%x", &ipattern);
     }
     printf(" enter 1 to test pulse delay scan \n");
     scanf("%d", &itp_scan);
//     scanf("%d", &igen);
     if(itp_scan == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" test pulse increment per step \n");
      scanf("%d", &nstep_tp);
      nevent = nstep*nstep_event;
//      printf(" enter test pattern %x \n");
//      scanf("%x", &ipattern);
     }


     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;


//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;
///
/// initialize **/
//      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
     printf(" enter 1 to ssend reset, 10 to get off the loop\n");
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_on)+(0x0<<16); //enable reset on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000000);
//
//
     printf(" enter 1 to remove the reset\n");
     scanf("%d", &ia);
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_isprst_off)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);

//      set devicd to online state
//     printf(" enter 1 to set system to online state \n");
//     scanf("%d",&i);

     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_online)+(0x0<<16); //enable online run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//   set slow control to discriminator system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_on;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set controller slow control go to MBD system \n");
//     scanf("%d",&ia);
//
//

//
//*************
     for (il=0; il < ndisc_mod; il++) {
      idisc_dac = 4000;
      imod = ndisc_mod_add[il] ;
      ichip=0;
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set the discriminator charge injector \n");
//      scanf("%d",&i);
//
//    low true
//
      if(itest_pattern == 0) {
       itest_odd =1;
       itest_even =1;
      }
      else if (itest_pattern == 1) {
       itest_odd =0;
       itest_even =1;
      }
      else if (itest_pattern == 2) {
       itest_odd =1;
       itest_even =0;
      }
      else {
       itest_odd =0;
       itest_even =0;
      }


      ijk = sp_mbd_disc_pulse_odd;
      imod = ndisc_mod_add[il];
      ichip=0;
      buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_odd<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      ijk = sp_mbd_disc_pulse_even;
      imod = ndisc_mod_add[il];
      ichip=0;
      buf_send[0]=(imod<<11)+(ichip<<8)+(ijk & 0xff)+(itest_even<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set the discriminator charge injector  patten \n");
//      scanf("%d",&i);
//
//
//
      idisc_thr =10; // set discriminator threshold level
      for (ib=0; ib<8; ib++) {
       imod = ndisc_mod_add[il];
       ichip=0;
       ijk = ((ib & 0x7)<<12) + (idisc_thr &0xfff);
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_disc_dac)+(ijk<<16);
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
      }
      printf(" set the discriminator threshold level \n");
//      scanf("%d",&i);
     }
//
//
//
     imod = sp_mbd_clk_add;
     ichip=0;
//         ic = (mbd_delay_setting & 0xff) << 8;
     ic = mbd_delay_setting;
     printf(" delay setting %x \n", ic);
//        for (ia=0; ia< 100000000; ia++) {
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_setting)+ ((ic & 0xffff)<<16) ;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" set the test pulse delay setting \n");
     scanf("%d",&i);


//
//
//



//
//
/*
     for (ik=0; ik<100000000; ik++) {
      imod = sp_mbd_clk_add;
      ichip=0;
      buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
*/
//
//   set slow control back to ADC system
//
     imod =sp_cntrl_seldisc_add;
     ichip = sp_cntrl_seldisc_off;
     buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);

//
//
     printf(" enter 1 to initial through ADC, module %d\n", imod_start);
     scanf("%d",&i);
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212

//
//   send init to the controller
//
     imod = imod_timing;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_init+ (0<<16);
     printf(" imod = %x, ichip = %x, buf_send[0] = %x\n", imod, ichip, buf_send[0]);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
     printf(" enter 1 to reset through ADC\n");
     scanf("%d",&i);
//
//   send reset to the controller
//
     imod = imod_timing;
     ichip = sp_adc_slowcntl_sub;
     buf_send[0]= (imod<<11)+(ichip<<8)+sp_adc_fake_gtm_reset+ (0<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);


//
//   set sample size  -- to 10
//
     printf(" type 1 to send sample size \n");
     scanf("%d",&is);


     for (ik =0; ik<nmod; ik++) {
      imod = imod_start+ik;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
      printf(" type 1 to set L1 delay \n");
      scanf("%d",&is);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//    if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
//     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0xff<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
      if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
     }
//sp_adc_sel_link_rxoff


//sp_xmit_lastmod
     if(isel_xmit == 1) {
       imod = imod_xmit;
       ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
      for (ia=0; ia<nevent; ia++) {
       if(iwrite != 1) {
        printf(" type 1 to send L1 trigger \n");
        scanf("%d",&is);
       }

       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
         printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
         printf (" module address = %d \n" ,(read_array[0] & 0x1f));
         printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
         printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
         printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
         printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
         printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
         printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
         printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
         printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
         printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
         printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
         printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        }
       }



//     for (ijk=0; ijk<1000000000; ijk++) {
//   #define  sp_adc_fake_gtm_init     210
//   #define  sp_adc_fake_gtm_l1       211
//   #define  sp_adc_fake_gtm_reset    212
//
//
//
//   set slow control to discrimeter
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_on;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);
       if(iwrite != 1) {
        printf(" set slow control to discriminator  \n");
        scanf("%d",&is);
       }

//*************
       if(idac_scan == 1) {
        for (il=0; il < ndisc_mod; il++) {
         ijk = ia%nstep_event;
         ib= (ia-ijk)/nstep_event;
         if(ijk ==0) {
          idisc_dac = ib*nstep_dac;
          imod = ndisc_mod_add[il];
          ichip=0;
          buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_disc_charge_dac)+((idisc_dac & 0xfff)<<16) ;
          i=1;
          k=1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
         }
        }
//        printf(" set the discriminator charge injector \n");
//        scanf("%d",&i);
       }
       if((ia ==0) && (iwrite ==1) && (idac_scan ==1)) {
        fprintf(outf," %d\n", nstep);
        fprintf(outf," %d\n", nstep_event);
        fprintf(outf," %d\n", nstep_dac);
       }
//
//

       if(itp_scan == 1) {
        ijk = ia%nstep_event;
        ib= (ia-ijk)/nstep_event;
        if(ijk ==0) {
         mbd_delay_setting = ib*nstep_tp;
         imod = sp_mbd_clk_add;
         ichip=0;
         ic = mbd_delay_setting;
         printf(" delay setting %x \n", ic);
//        for (ia=0; ia< 100000000; ia++) {
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_setting)+ ((ic & 0xffff)<<16) ;
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
//        printf(" set the discriminator charge injector \n");
//        scanf("%d",&i);
       }
       if((ia ==0) && (iwrite ==1) && (itp_scan ==1)) {
        fprintf(outf," %d\n", nstep);
        fprintf(outf," %d\n", nstep_event);
        fprintf(outf," %d\n", nstep_tp);
       }

//
//#define  sp_mbd_clk_delay_off       0
//#define  sp_mbd_clk_delay_on        2//   send init to the controller
//
       if(iwrite != 1) {
        printf(" enter 1 to send MBD test pulse and L1 trigger\n");
        scanf("%d",&i);
       }
//      for (ik=0; ik<100000000; ik++) {
       if(test_pulse_d == 1) {
/*
        if((ia%2) ==0 ) {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
        else {
         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_on)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
        }
*/

         imod = sp_mbd_clk_add;
         ichip=0;
         buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_on)+(0x0<<16);
         i=1;
         k=1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

       }
       else {
        imod = sp_mbd_clk_add;
        ichip=0;
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_delay_off)+(0x0<<16);
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
       }
//       printf(" set discriminator pulse  \n");
//       scanf("%d",&is);


       imod = sp_mbd_clk_add;
       ichip=0;
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_mbd_clk_pulse)+(0x0<<16);
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }
//       printf(" set slow control to discriminator  \n");
//       scanf("%d",&is);


///

//
//   set slow control back to ADC system
//
       imod =sp_cntrl_seldisc_add;
       ichip = sp_cntrl_seldisc_off;
       buf_send[0]= (imod<<11)+(ichip<<8)+0+ (0x0<<16);   // seldisc on
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(11);


//      }
/*
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }
*/


//
//
//

//

       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
         iparity = iparity ^ read_array[is];
        }
        if ((iwrite == 1)) {
         if(ibin ==0) fprintf(outf," %x\n", read_array[0]);
         if(ibin ==0) fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if((iwrite == 1)) {
          if(ibin == 0) fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if((iwrite == 1)) {
          if(((k%8) ==0) && (ibin ==0)) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
//         if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }
        if((iwrite ==1) && (ibin == 1)) {
         fwrite(&nread, sizeof(UINT32), 1, outf);
         fwrite(&read_array, sizeof(UINT32), nread, outf);
        }
        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) {
          if(ibin == 0) fprintf(outf,"\n");
        }
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
           printf(" %4x", adc_data[is][k]);
          }
          printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
//     }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
       if(iwrite ==1) {
        if((ia%10) == 0) printf(" write evennt = %d \n", ia);
       }
      }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
    break;


    case 22:
     printf(" L1 trigger test routine -- upper and lower chips\n");
     px = &buf_send;
     py = &read_array;
     printf(" enter 1 for initialization \n");
     scanf("%d",&i);
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

       printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//
     printf(" enter the module number \n");
     scanf("%d", &imod_trg);
     printf(" enter 1 for upper chip and 0 for lower chip\n");
     scanf("%d", &itrig_chip);
     imod = imod_trg*2 + itrig_chip;  // take care increse address bit by 2

     printf(" enter operation type \n");
     printf("    1 for send pll reset \n");
     printf("    2 for send reset for the transceiver \n");
     printf("    3 for send arst \n");
     printf("    4 for send drst \n");
     printf("    5 for send clr to the FIFO \n");
     printf("    6 for send RESET \n");
     printf("    7 for sending fake data \n");
     printf("    9 for the FEM to send data to LL1 \n");
     printf("   10 for the loopback \n");
     printf("   11 for the L1 loopback with ECC\n");
     printf("   12 for trigger S10 test routine --- test data \n");
     printf("   14 for trigger s10 test routine --- FEM inout \n");
     scanf("%d", &itest);
     switch (itest) {

      case 1:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_rst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
       }


      break;

       case 2:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_reset<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
       }


      break;

       case 3:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_arst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px); 
        usleep(100);
       }


      break;

        case 4:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_drst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
       }


      break;

       case 5:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_clr<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px); 
        usleep(100);
       }


      break;

       case 6:
       for (j=0; j<10000000; j++) {
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100000);
       }


      break;

/*
#define  sp_L1trig_test_rst         1
#define  sp_L1trig_test_reset       2
#define  sp_L1trig_test_arst        3
#define  sp_L1trig_test_drst        4
#define  sp_L1trig_test_clr         5
#define  sp_L1trig_test_RESET       6


#define   sp_l1trig_test_fk_data    0x40

*/
      case 7:
        printf(" enter channel number \n");
        scanf("%d", &ich);
        printf(" number of word \n");
        scanf("%d", &nword);
        printf(" number of events to run \n");
        scanf("%d", &nevent);
        printf(" data print \n");
        scanf("%d", &iprint_event);
        printf(" data check \n");
        scanf("%d", &icheck);
        printf(" enter 1 for randomize data \n");
        scanf("%d",&irand);
//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_rst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      reset the optical parts
//
        printf(" reset optical module \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

//
//         reset transmitter
//
        printf(" reset transmitter \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_arst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);

//
//      reset the receiver
//
        printf(" reset receiver \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_reset<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

        printf(" type 1 to contunue \n");
        scanf("%d", &i);

//       ichip = sp_L1trig_test_fk_data +10;
        for (ic=0; ic< nevent; ic++) {
         ichip = 0;
         for (ia=0; ia<(nword+1); ia++) {
          if(irand == 0) send_data_array[ia] = ia;
          else send_data_array[ia] = rand() & 0xffff;
//          printf(" rand = %x\n",send_array[ia]);
//          scanf("%d", &i);
         }
         for (ia=0; ia<(nword+1); ia++) {
          k=ia%2;
          ij = ia/2;
//         if((ia == 0) & (k == 0))  buf_send[0]=(imod <<10)+ (ichip << 8) + (0x40 + ich) + (ia<<16) ;
          if((ia == 0) & (k == 0))  buf_send[0]=(imod <<10)+ (ichip << 8) + (0x40 + ich) + (send_data_array[ia]<<16) ;
//         if((ia == 0) )  buf_send[0]=(imod <<10)+ (ichip << 8) + (sp_L1trig_test_fk_data+10); + (ia<<16) ;
          if((ia != 0) & (k == 0)) {
//          printf(" ia= %x, k= %x, ij = %x \n", ia, k, ij);
           buf_send[ij]= send_data_array[ia-1]+ (send_data_array[ia]<<16);
          }
//          printf(" ia= %d \n", send_data_array[ia]);
         }
         nread =nword/2;
//
//      initial the receiver
//
         i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
//
         i= 1;
         k=nword/2;
//         printf(" send array = %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2]);
         i = pcie_send_1(hDev, i, k, px);

//
//   8.3ns*16 per word    asume 200ns per word for safety
//   100 words => 100*200ns = 20 microsec
//
         i = nword;
         usleep(i);
//

//
//
//
         i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words

         ia=0;
         ib=0;

         if(iprint_event == 1) printf(" event = %d\n", ic);


         for (i=0; i<(nword/2); i++) {
          read_array_s[ib]= (read_array[i] & 0xffff);
          ib=ib+1;
          read_array_s[ib]= (read_array[i] >>16) & 0xffff;
          ib=ib+1;
          if(iprint_event == 1) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
         }
         if(iprint_event == 1) printf("\n");

         if(iprint_event == 1) {
          for (i=0; i<nword; i++) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array_s[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
          printf("\n");
         }

         if(icheck == 1) {
          for (i=1; i< nword-1; i++) {
           if(read_array_s[i] != send_data_array[i-1]) printf(" error event %d seq %d send %x, read= %x \n",
           ic, i, read_array_s[i], send_data_array[i-1]);
          }
         }
         if(iprint_event == 1) {
          printf(" type 1 to continue \n");
          scanf("%d",&ib);
         }
         if((ic%10000) == 0) printf(" event = %d\n", ic);
        }


//        printf(" read array = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        break;


//#define   sp_l1trig_test_ic2_wr     22
//#define   sp_l1trig_test_i2c_rd     23
       case 8:
//
//      reset the optical parts
//
        printf(" reset optical module \n");
//        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100000);
        scanf("%d", &i);

        i2c_mod_add = 0x58;
        i2c_write   = 0;
        i2c_read = 1;
        i2c_add     = 168 ;
//        for (is =0; is <10000000; is++) {
         ichip = 0;
         usleep(100000);                  // delay in the mili-second
         buf_send[0]=(imod <<10)+ (ichip << 8) + sp_l1trig_test_i2c_rd + ((i2c_mod_add +i2c_write)<<16) ;
         buf_send[1] =i2c_add+ ((i2c_mod_add+i2c_read)<<16);
         i= 1;
         k= 3;
         i = pcie_send_1(hDev, i, k, px);
         printf(" send array data %x, %x\n", buf_send[0], buf_send[1]);
         usleep(1000);
//        }
        break;

       case 9:
        printf(" FEM module number \n");
        scanf("%d", &imod_fem);
        printf(" number of word to send \n");
        scanf("%d", &nword);
        printf(" number of events to run \n");
        scanf("%d", &nevent);
        printf(" data print \n");
        scanf("%d", &iprint_event);
        printf(" data check \n");
        scanf("%d", &icheck);
        printf(" enter 1 for randomize data \n");
        scanf("%d",&irand);


        px = &buf_send;
        py = &read_array;
/** initialize **/
/*      if(j ==0) { */
        buf_send[0]=0x0;
        buf_send[1]=0x0;
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
//   send init to the controller
//
        buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

         buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
// #define  sp_adc_trigopt_sub         7
// #define  sp_adc_trigopt_fake        1
//

//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_rst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      reset the optical parts
//
        printf(" reset optical module \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

//
//         reset transmitter
//
        printf(" reset transmitter \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_arst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);

//
//      reset the receiver
//
        printf(" reset receiver \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_reset<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_clr<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);


//        printf(" type 1 to contunue \n");
//        scanf("%d", &i);

//        iprint_event =1;
//
         istart_beg = 0;

         for (is=0; is<nevent; is++) {
          if(iprint_event == 1) {
           printf(" type 1 to continue \n");
           scanf("%d", &i);
          }
//          imod = imod_fem;
          ichip = sp_adc_trigopt_sub;
          nread =nword/2;
//          nword =100;
//
//      initial the receiver
//
          i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
//
          for (ia=0; ia<(nword+1); ia++) {
//           send_data_array[ia] =ia;
           if(irand == 0) send_data_array[ia] = (ia+istart_beg) & 0xffff;
           else send_data_array[ia] = rand() & 0xffff;

           k=ia%2;
           ij = ia/2;
//         if((ia == 0) & (k == 0))  buf_send[0]=(imod <<10)+ (ichip << 8) + (0x40 + ich) + (ia<<16) ;
           if((ia == 0) & (k == 0))  buf_send[0]=(imod_fem <<11)+ (ichip << 8) + sp_adc_trigopt_fake + (send_data_array[ia]<<16) ;
//         if((ia == 0) )  buf_send[0]=(imod <<10)+ (ichip << 8) + (sp_L1trig_test_fk_data+10); + (ia<<16) ;
           if((ia != 0) & (k == 0)) {
//          printf(" ia= %x, k= %x, ij = %x \n", ia, k, ij);
            buf_send[ij]= send_data_array[ia-1]+ (send_data_array[ia]<<16);
           }
//          printf(" ia= %d \n", send_data_array[ia]);
          }
          istart_beg = istart_beg + nword;
          i= 1;
          k=nword/2;
//         printf(" send array = %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2]);
          i = pcie_send_1(hDev, i, k, px);
//
//
//
//   8.3ns*16 per word    asume 200ns per word for safety
//   100 words => 100*200ns = 20 microsec
//
          i = nword;
          usleep(i);
//
//
          if(iprint_event == 1) {
           printf(" type 1 to send the read \n");
           scanf("%d", &i);
          }
//
          ichip = 0;
          buf_send[0]=(imod <<10)+ (ichip << 8) + 0x6 + (sp_L1trig_test_RESET<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(1000);

//
//
//
          i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words

          ia=0;
          ib=0;

          if(iprint_event == 1) printf(" event = %d\n", ic);


          for (i=0; i<(nword/2); i++) {
           read_array_s[ib]= (read_array[i] & 0xffff);
           ib=ib+1;
           read_array_s[ib]= (read_array[i] >>16) & 0xffff;
           ib=ib+1;
           if(iprint_event == 1) {
            if((i%8) == 0) printf("%4d", (i/8));
            printf(" %8x", read_array[i]);
            if(((i+1)%8) == 0) printf("\n");
           }
          }
          if(iprint_event == 1) printf("\n");
//
//
          if(iprint_event == 1) {
           for (i=0; i<nword; i++) {
            if((i%8) == 0) printf("%4d", (i/8));
            printf(" %8x", read_array_s[i]);
            if(((i+1)%8) == 0) printf("\n");
           }
           printf("\n");
          }
//
//
/*       for non ecc checking....
         if(icheck == 1) {
          for (i=1; i< nword-1; i++) {
           if(read_array_s[i] != send_data_array[i-1]) printf(" error event %d seq %d send %x, read= %x \n",
           ic, i, read_array_s[i], send_data_array[i-1]);
          }
         }
*/
/*
          if(icheck == 1) {
           for (i=2; i< nword-10; i++) {
            if(read_array_s[i] != send_data_array[i-2]) printf(" error event %d seq %d read %x, send= %x \n",
           ic, i, read_array_s[i], send_data_array[i-2]);
           }
          }
*/


//          if(icheck == 1) {
//           for (i=0; i< nword-3; i++) {
//            if(read_array_s[i] != send_data_array[i]) printf(" error event %d seq %d read %x, send = %x \n",
//            is, i, read_array_s[i], send_data_array[i]);
//           }
//          }
          if(iprint_event == 1) {
           printf(" type 1 to continue \n");
           scanf("%d",&ib);


          }
//          if((is%10000) == 0) printf(" event = %d\n", is);


//
//      initial the receiver for status
//
          nread =4;
          i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

          if(iprint_event == 1) {
           printf(" read status \n");
           scanf("%d", &i);
          }


          ichip = 0;
          buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_status + (sp_L1trig_test_clr<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(100);
//
//
          i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
          if(iprint_event == 1) printf(" status word %x, %x, %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3]);
          i = read_array[0];
          locked1 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
          i = read_array[0] >> 16;
          locked2 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
          i = read_array[1];
          locked3 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
          i = read_array[1] >> 16;
          locked4a = i & 0x1;
          locked4b = (i & 0x100)>> 8;
          if(iprint_event == 1) printf(" locked status %x, %x, %x, %x, %x\n", locked1, locked2, locked3, locked4a, locked4b);
          err_cor_cnt = read_array[2] & 0xff;
          err_det_cnt = (read_array[2] >> 8) & 0xff;
          err_fat_cnt = (read_array[2] >> 16) & 0xff;
          if(iprint_event == 1) printf(" error correction count %x, error detect count %x, error fatal count %x\n", err_cor_cnt, err_det_cnt, err_fat_cnt);
          temp = (((read_array[3] & 0xffff)*693.0/1024)-265.0);
          if(iprint_event == 1) printf (" temp readback =  %x, %6.1f\n", (read_array[3] & 0xffff), temp);



//sp_L1trig_test_status
          ierror = 0;
          if(icheck == 1) {
           for (i=2; i< nword-21; i++) {
            if(read_array_s[i] != send_data_array[i-2]) {
             printf(" error event %d seq %d read %x, send = %x \n", is, i, read_array_s[i], send_data_array[i-2]);
             ierror =1;
//             printf(" type 1 to continue \n");
//             scanf("%d",&ib);

            }
           }
          }
          if(ierror == 1) printf(" error correction count %x, error detect count %x, error fatal count %x\n", err_cor_cnt, err_det_cnt, err_fat_cnt);
          if(iprint_event == 1) {
           printf(" type 1 to continue \n");
           scanf("%d",&ib);
          }
          if((is%10000) == 0) {
           printf(" event = %d\n", is);
           printf (" temp readback =  %x, %6.1f\n", (read_array[3] & 0xffff), temp);
           printf(" error correction count %x, error detect count %x, error fatal count %x\n", err_cor_cnt, err_det_cnt, err_fat_cnt);
          }

         }





       break;
       
      case 10:
        printf(" enter channel number \n");
        scanf("%d", &ich);
        printf(" number of word \n");
        scanf("%d", &nword);
        printf(" number of events to run \n");
        scanf("%d", &nevent);
        printf(" data print \n");
        scanf("%d", &iprint_event);
        printf(" data check \n");
        scanf("%d", &icheck);
        printf(" enter 1 for randomize data \n");
        scanf("%d",&irand);
//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_rst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      reset the optical parts
//
        printf(" reset optical module \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

//
//         reset transmitter
//
        printf(" reset transmitter \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_arst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);

//
//      reset the receiver
//
        printf(" reset receiver \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_reset<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

        printf(" type 1 to contunue \n");
        scanf("%d", &i);

//       ichip = sp_L1trig_test_fk_data +10;

        ierr_event =0;
        event_err_count = 0;
        data_err_count = 0;
        for (ic=0; ic< nevent; ic++) {
         ichip = 0;
         for (ia=0; ia<(nword+1); ia++) {
          if(irand == 0) send_data_array[ia] = ia;
          else send_data_array[ia] = rand() & 0xffff;
          if(ia <= (nword-5)) checksum = checksum + send_data_array[ia];
          if(ia == (nword-4)) send_data_array[ia] = checksum & 0xffff;
          if(ia == (nword-3)) send_data_array[ia] = (checksum>>16) & 0xffff;
//          printf(" rand = %x\n",send_array[ia]);
//          scanf("%d", &i);
         }
         for (ia=0; ia<(nword+1); ia++) {
          k=ia%2;
          ij = ia/2;
//         if((ia == 0) & (k == 0))  buf_send[0]=(imod <<10)+ (ichip << 8) + (0x40 + ich) + (ia<<16) ;
          if((ia == 0) & (k == 0))  buf_send[0]=(imod <<10)+ (ichip << 8) + (0x40 + ich) + (send_data_array[ia]<<16) ;
//         if((ia == 0) )  buf_send[0]=(imod <<10)+ (ichip << 8) + (sp_L1trig_test_fk_data+10); + (ia<<16) ;
          if((ia != 0) & (k == 0)) {
//          printf(" ia= %x, k= %x, ij = %x \n", ia, k, ij);
           buf_send[ij]= send_data_array[ia-1]+ (send_data_array[ia]<<16);
          }
//          printf(" ia= %d \n", send_data_array[ia]);
         }
         nread =nword/2;
//
//      initial the receiver
//
         i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
//
         i= 1;
         k=nword/2;
//         printf(" send array = %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2]);
         i = pcie_send_1(hDev, i, k, px);

//
//   8.3ns*16 per word    asume 200ns per word for safety
//   100 words => 100*200ns = 20 microsec
//
         i = nword;
         usleep(i);
//

//
//
//
         i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words

         ia=0;
         ib=0;

         if(iprint_event == 1) printf(" event = %d\n", ic);


         for (i=0; i<(nword/2); i++) {
          read_array_s[ib]= (read_array[i] & 0xffff);
          ib=ib+1;
          read_array_s[ib]= (read_array[i] >>16) & 0xffff;
          ib=ib+1;
          if(iprint_event == 1) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
         }
         if(iprint_event == 1) printf("\n");

         if(iprint_event == 1) {
          for (i=0; i<nword; i++) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array_s[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
          printf("\n");
         }
//        ierr_event =0;
//        event_err_count = 0;
//        data_err_count = 0;

          if(icheck == 1) {
           for (i=0; i< nword-3; i++) {
            if(read_array_s[i] != send_data_array[i]) {
              printf(" error event %d seq %d read %x, send = %x \n", ic, i, read_array_s[i], send_data_array[i]);
              if(ic != ierr_event) {
                ierr_event = ic;
                event_err_count = event_err_count+1;
              }
              data_err_count = data_err_count+1;
            }
           }
          }
//         if(icheck == 1) {
//          for (i=1; i< nword-1; i++) {
//           if(read_array_s[i] != send_data_array[i-1]) printf(" error event %d seq %d send %x, read= %x \n",
//           ic, i, read_array_s[i], send_data_array[i-1]);
//          }
//         }
         if(iprint_event == 1) {
          printf(" type 1 to continue \n");
          scanf("%d",&ib);
         }
         if((ic%10000) == 0) printf(" event = %d, event_error_count =%d, data_error_count = %d\n", ic, event_err_count, data_err_count);
        }


//        printf(" read array = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        break;
//
//
//
      case 11:
        printf(" enter channel number \n");
        scanf("%d", &ich);
        printf(" number of word \n");
        scanf("%d", &nword);
        printf(" number of events to run \n");
        scanf("%d", &nevent);
        printf(" data print \n");
        scanf("%d", &iprint_event);
        printf(" data check \n");
        scanf("%d", &icheck);
        printf(" enter 1 for randomize data \n");
        scanf("%d",&irand);
//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_rst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      reset the optical parts
//
        printf(" reset optical module \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + 0x5 + (sp_L1trig_test_RESET<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

//
//         reset transmitter
//
        printf(" reset transmitter \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_arst<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);

//
//      reset the receiver
//
        printf(" reset receiver \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_reset<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

        printf(" type 1 to send clr fifo\n");
        scanf("%d", &i);
        
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_slow + (sp_L1trig_test_clr<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px); 
        usleep(100);


        printf(" type 1 to contunue \n");
        scanf("%d", &i);

        istart_beg =0;
//       ichip = sp_L1trig_test_fk_data +10;

        error_count =0;
        for (ic=0; ic< nevent; ic++) {
         ichip = 0;
         for (ia=0; ia<(nword+1); ia++) {
          if(irand == 0) send_data_array[ia] = (ia+istart_beg) &0xffff;
          else send_data_array[ia] = rand() & 0xffff;
//          printf(" rand = %x\n",send_array[ia]);
//          scanf("%d", &i);
         }
         istart_beg = istart_beg + nword;
         for (ia=0; ia<(nword+1); ia++) {
          k=ia%2;
          ij = ia/2;
//         if((ia == 0) & (k == 0))  buf_send[0]=(imod <<10)+ (ichip << 8) + (0x40 + ich) + (ia<<16) ;
          if((ia == 0) & (k == 0))  buf_send[0]=(imod <<10)+ (ichip << 8) + (0x40 + ich) + (send_data_array[ia]<<16) ;
//         if((ia == 0) )  buf_send[0]=(imod <<10)+ (ichip << 8) + (sp_L1trig_test_fk_data+10); + (ia<<16) ;
          if((ia != 0) & (k == 0)) {
//          printf(" ia= %x, k= %x, ij = %x \n", ia, k, ij);
           buf_send[ij]= send_data_array[ia-1]+ (send_data_array[ia]<<16);
          }
//          printf(" ia= %d \n", send_data_array[ia]);
         }
         nread =nword/2;
//
//      initial the receiver
//
         i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
//
//
         i= 1;
         k=nword/2;
//         printf(" send array = %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2]);
         i = pcie_send_1(hDev, i, k, px);

//
//   8.3ns*16 per word    asume 200ns per word for safety
//   100 words => 100*200ns = 20 microsec
//
         i = nword;
         usleep(i);
//

//
//
//
         i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words

         ia=0;
         ib=0;

         if(iprint_event == 1) printf(" event = %d\n", ic);


         for (i=0; i<(nword/2); i++) {
          read_array_s[ib]= (read_array[i] & 0xffff);
          ib=ib+1;
          read_array_s[ib]= (read_array[i] >>16) & 0xffff;
          ib=ib+1;
          if(iprint_event == 1) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
         }
         if(iprint_event == 1) printf("\n");

         if(iprint_event == 1) {
          for (i=0; i<nword; i++) {
           if((i%8) == 0) printf("%4d", (i/8));
           printf(" %8x", read_array_s[i]);
           if(((i+1)%8) == 0) printf("\n");
          }
          printf("\n");
         }

//
//      initial the receiver for status
//
         nread =4;
         i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

         if(iprint_event == 1) {
           printf(" read status \n");
           scanf("%d", &i);
         }


         ichip = 0;
         buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1trig_test_status + (sp_L1trig_test_clr<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//         printf(" buf_send[0] = %x\n", buf_send[0]);
         usleep(100);
//
//
         i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
         if(iprint_event == 1) printf(" status word %x, %x, %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3]);
         i = read_array[0];
         locked1 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
         i = read_array[0] >> 16;
         locked2 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
         i = read_array[1];
         locked3 = (i & 0x3f) + (((i >>8) & 0x3f) << 6);
         i = read_array[1] >> 16;
         locked4a = i & 0x1;
         locked4b = (i & 0x100)>> 8;
         if(iprint_event == 1) printf(" locked status %x, %x, %x, %x, %x\n", locked1, locked2, locked3, locked4a, locked4b);
         err_cor_cnt = read_array[2] & 0xff;
         err_det_cnt = (read_array[2] >> 8) & 0xff;
         err_fat_cnt = (read_array[2] >> 16) & 0xff;
         if(iprint_event == 1) printf(" error correction count %x, error detect count %x, error fatal count %x\n", err_cor_cnt, err_det_cnt, err_fat_cnt);
         temp = (((read_array[3] & 0xffff)*693.0/1024)-265.0);
         if(iprint_event == 1) printf (" temp readback =  %x, %6.1f\n", (read_array[3] & 0xffff), temp);



//sp_L1trig_test_status
         ierror = 0;
         if(icheck == 1) {
          for (i=1; i< nword-21; i++) {
           if(read_array_s[i] != send_data_array[i-1]) {
             printf(" error event %d seq %d send %x, read= %x \n", ic, i, read_array_s[i], send_data_array[i-1]);
             ierror =1;
             error_count = error_count+1;
           }
          }
         }
         if(ierror == 1) printf(" error correction count %x, error detect count %x, error fatal count %x error_counter %d\n", err_cor_cnt, err_det_cnt, err_fat_cnt, error_count);
         if(iprint_event == 1) {
          printf(" type 1 to continue \n");
          scanf("%d",&ib);
         }
         if((ic%10000) == 0) {
           printf(" event = %d\n", ic);
           printf (" temp readback =  %x, %6.1f\n", (read_array[3] & 0xffff), temp);
           printf(" error correction count %x, error detect count %x, error fatal count %x\n", err_cor_cnt, err_det_cnt, err_fat_cnt);
         }
        }


//        printf(" read array = %x, %x, %x, %x, %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4]);
        break;

/*
#define  sp_L1_s10_slow_thr         6
#define  sp_L1_s10_slow_reset       7
#define  sp_L1_s10_slow_en0         8
#define  sp_L1_s10_slow_en1         9
#define  sp_L1_s10_slow_test       12
#define  sp_L1_s10_slow_delay      13
#define  sp_L1_s10_slow_phasen     14
#define  sp_L1_s10_slow_rst_p      15
#define  sp_L1_s10_slow_RESET      16
#define  sp_L1_s10_slow_monitor_p  20
#define  sp_L1_s10_slow_ch_dis1    21
#define  sp_L1_s10_slow_ch_dis2    22


#define  sp_L1_s10_rst_pll          1
#define  sp_L1_s10_rst_opt_fem      2
#define  sp_L1_s10_rst_opt_st_t     3
#define  sp_L1_s10_rst_opt_st_r     5
#define  sp_L1_s10_rst_opt_out_t    6
*/

        case 12:
//
//      reset the optical parts
//
        printf(" reset trigger module optics \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_RESET + (0x0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      disable optucal channel
//
//
//      reset the optical parts
//
        printf(" disable optical channel \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_ch_dis1 + (0xffff<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_ch_dis2 + (0xff<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);


//
//
        printf(" reset trigger module pll rseet \n");
        scanf("%d", &i);

//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_pll<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" reset trigger module stich transmiiter reset \n");
        scanf("%d", &i);

//
//        sttich transmitter reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_opt_st_t<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
        printf(" reset trigger module stich receiver reset \n");
        scanf("%d", &i);

//
//         stich receiver reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_opt_st_r<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
        printf(" reset test data register \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_reset + (0x0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" enter phase number (0-15)\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_phasen  + (i<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" enter align data delay\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_delay  + (i<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" enter threshold\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_thr  + (i<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" enter 0 for sequence loading, 1 for test case\n");
        scanf("%d", &itest_p);
//
//
//
        printf(" set test to 0\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_test  + (0x0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//

//
//       load EN0 set of test data
//       1st word to set command
//       2nd - word 25 is to set 28 resgister
//       last word is to set channel 0 again
//

       if(itest_p == 0) {
// sequence map
        for (ia=0;ia<8; ia++) {
         for (ib=0; ib<48; ib++ ) {
           test_data_array[ia][ib] = ib+ia+10;
         }
        }
       }
       else if (itest_p == 1) {
// flat back ground
        for (ia=0;ia<8; ia++) {
         for (ib=0; ib<48; ib++ ) {
           test_data_array[ia][ib] = ia;
         }
        }
//
//      set up peak
//
        test_data_array[4][12] = 50;
        test_data_array[4][20] = 60;
        test_data_array[4][30] = 70;
       }


        for (ib=0; ib< 48; ib++) {
          if (ib==0) printf("    %4d",ib);
          else printf("%4d",ib);
        }
        printf("\n");
        for (ia=0;ia<8; ia++) {
         printf("%3d ", ia);
         for (ib=0; ib<48; ib++ ) {
//           test_data_array[ia][ib] = ib+ia+10;
           printf("%4x", test_data_array[ia][ib]);
         }
         printf("\n");
        }
        printf("\n");
        printf("\n");
//
//      data array after merge
//
/*        for (ib=0; ib< 48; ib++) {
          if (ib==0) printf("    %3d",ib);
          else printf("%3d",ib);
        }
*/
        for (ia=0;ia<8; ia++) {
         for (ib=0; ib<48; ib++ ) {
          test_data_array_1[ia+1][ib] = test_data_array[ia][ib];
         }
//         printf("\n");
        }
//
//      data array-- top
//
         for (ib=0; ib<48; ib++ ) {
          test_data_array_1[0][ib] = test_data_array[7][ib];
         }
//
//      data array-- bottom
//
         for (ib=0; ib<48; ib++ ) {
          test_data_array_1[9][ib] = test_data_array[1][ib];
         }
         for (ib=0; ib<48; ib++ ) {
          test_data_array_1[10][ib] = test_data_array[0][ib];
         }
//
//      print out map
//
        for (ib=0; ib< 48; ib++) {
          if (ib==0) printf("    %3d",ib);
          else printf("%3d",ib);
        }
        printf("\n");
        for (ia=0;ia<11; ia++) {
         printf("%3d ", ia);
         for (ib=0; ib<48; ib++ ) {
           printf("%3x", test_data_array_1[ia][ib]);
         }
         printf("\n");
        }
        printf("\n");
        printf("\n");
//
//      summer map
//
        for (ib=0; ib< 48; ib++) {
          if (ib==0) printf("    %3d",ib);
          else printf("%3d",ib);
        }
        printf("\n");
        for (ia=0;ia<10; ia++) {
         printf("%3d ", ia);
         for (ib=0; ib<47; ib++ ) {
          test_data_sum[ia][ib] = test_data_array_1[ia][ib]+test_data_array_1[ia][ib+1]+ 
             test_data_array_1[ia+1][ib]+test_data_array_1[ia+1][ib+1];
           printf("%3x", test_data_sum[ia][ib]);
         }
         printf("\n");
        }


        for (ia=0; ia<4; ia++) {
          for (ib=0; ib<48; ib++) {
           if(ib == 0) {
             send_data_array[0] = (imod<<10) + (ichip<<8) + sp_L1_s10_slow_en0;
//             printf(" send data array = %x \n", send_data_array[0]);
           }
           send_data_array[ib+1] = ((ia<<6) +ib) + ( test_data_array[ia][ib]<<8);
          }
          for (ib=0; ib<25; ib++) {
            buf_send[ib] = send_data_array[2*ib]+ (send_data_array[(2*ib)+1]<<16);
          }
          i= 1;
          k= 25;
          i = pcie_send_1(hDev, i, k, px);
//          printf(" send data array = %x, %x, %x, %x \n", send_data_array[0], send_data_array[1], send_data_array[2], send_data_array[3]);
//           printf(" send data array = %x, %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2], buf_send[3]);
          usleep(1000);
          printf(" send test dara array group 0 section %d\n", ia);
//          scanf("%d", &i);
        }
//
        for (ia=0; ia<4; ia++) {
          for (ib=0; ib<48; ib++) {
           if(ib == 0) {
             send_data_array[0] = (imod<<10) + (ichip<<8) + sp_L1_s10_slow_en1;
//             printf(" send data array = %x \n", send_data_array[0]);
           }
           send_data_array[ib+1] = ((ia<<6) +ib) + ( test_data_array[(ia+4)][ib]<<8);
          }
          for (ib=0; ib<25; ib++) {
            buf_send[ib] = send_data_array[2*ib]+ (send_data_array[(2*ib)+1]<<16);
          }
          i= 1;
          k= 25;
          i = pcie_send_1(hDev, i, k, px);
//          printf(" send data array = %x, %x, %x, %x \n", send_data_array[0], send_data_array[1], send_data_array[2], send_data_array[3]);
//           printf(" send data array = %x, %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2], buf_send[3]);
          usleep(1000);
          printf(" send test dara array group 1 section %d\n", ia);
//          scanf("%d", &i);
        }

        printf(" set test to 1\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_test  + (0x1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//

        printf(" type 1 to contine\n");
        scanf("%d", &i);
        break;


         case 14:
//
//      reset the optical parts
//
        printf(" reset trigger module optics \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_RESET + (0x0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
        printf(" reset trigger module pll rseet \n");
        scanf("%d", &i);

//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_pll<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" reset trigger module stich transmiiter reset \n");
        scanf("%d", &i);

//
//        sttich transmitter reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_opt_st_t<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
        printf(" reset trigger module stich receiver reset \n");
        scanf("%d", &i);

//
//         stich receiver reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_opt_st_r<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//        FEM optical reset
//
        printf(" reset trigger module FEM receiver reset \n");
        scanf("%d", &i);

        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_opt_fem<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//

#define  sp_L1_s10_rst_opt_fem      2
//
//
        printf(" reset test data register \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_reset + (0x0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" enter align data delay 1\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_delay  + (i<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
        printf(" set test to 0\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_test  + (0x0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
        printf(" system now reset to receive FEM data\n");
        scanf("%d", &i);

//

//
//       load EN0 set of test data
//       1st word to set command
//       2nd - word 25 is to set 28 resgister
//       last word is to set channel 0 again
//

        for (ib=0; ib< 48; ib++) {
          if (ib==0) printf("    %4d",ib);
          else printf("%4d",ib);
        }
        printf("\n");
        for (ia=0;ia<8; ia++) {
         printf("%3d ", ia);
         for (ib=0; ib<48; ib++ ) {
           test_data_array[ia][ib] = ib+ia+10;
           printf("%4x", test_data_array[ia][ib]);
         }
         printf("\n");
        }
        printf("\n");
        printf("\n");
//
//      data array after merge
//
/*        for (ib=0; ib< 48; ib++) {
          if (ib==0) printf("    %3d",ib);
          else printf("%3d",ib);
        }
*/
        for (ia=0;ia<8; ia++) {
         for (ib=0; ib<48; ib++ ) {
          test_data_array_1[ia+1][ib] = test_data_array[ia][ib];
         }
//         printf("\n");
        }
//
//      data array-- top
//
         for (ib=0; ib<48; ib++ ) {
          test_data_array_1[0][ib] = test_data_array[7][ib];
         }
//
//      data array-- bottom
//
         for (ib=0; ib<48; ib++ ) {
          test_data_array_1[9][ib] = test_data_array[1][ib];
         }
         for (ib=0; ib<48; ib++ ) {
          test_data_array_1[10][ib] = test_data_array[0][ib];
         }
//
//      print out map
//
        for (ib=0; ib< 48; ib++) {
          if (ib==0) printf("    %3d",ib);
          else printf("%3d",ib);
        }
        printf("\n");
        for (ia=0;ia<11; ia++) {
         printf("%3d ", ia);
         for (ib=0; ib<48; ib++ ) {
           printf("%3x", test_data_array_1[ia][ib]);
         }
         printf("\n");
        }
        printf("\n");
        printf("\n");
//
//      summer map
//
        for (ib=0; ib< 48; ib++) {
          if (ib==0) printf("    %3d",ib);
          else printf("%3d",ib);
        }
        printf("\n");
        for (ia=0;ia<10; ia++) {
         printf("%3d ", ia);
         for (ib=0; ib<47; ib++ ) {
          test_data_sum[ia][ib] = test_data_array_1[ia][ib]+test_data_array_1[ia][ib+1]+ 
             test_data_array_1[ia+1][ib]+test_data_array_1[ia+1][ib+1];
           printf("%3x", test_data_sum[ia][ib]);
         }
         printf("\n");
        }





        for (ia=0; ia<4; ia++) {
          for (ib=0; ib<48; ib++) {
           if(ib == 0) {
             send_data_array[0] = (imod<<10) + (ichip<<8) + sp_L1_s10_slow_en0;
//             printf(" send data array = %x \n", send_data_array[0]);
           }
           send_data_array[ib+1] = ((ia<<6) +ib) + ( test_data_array[ia][ib]<<8);
          }
          for (ib=0; ib<25; ib++) {
            buf_send[ib] = send_data_array[2*ib]+ (send_data_array[(2*ib)+1]<<16);
          }
          i= 1;
          k= 25;
          i = pcie_send_1(hDev, i, k, px);
//          printf(" send data array = %x, %x, %x, %x \n", send_data_array[0], send_data_array[1], send_data_array[2], send_data_array[3]);
//           printf(" send data array = %x, %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2], buf_send[3]);
          usleep(1000);
          printf(" send test dara array group 0 section %d\n", ia);
//          scanf("%d", &i);
        }
//
        for (ia=0; ia<4; ia++) {
          for (ib=0; ib<48; ib++) {
           if(ib == 0) {
             send_data_array[0] = (imod<<10) + (ichip<<8) + sp_L1_s10_slow_en1;
//             printf(" send data array = %x \n", send_data_array[0]);
           }
           send_data_array[ib+1] = ((ia<<6) +ib) + ( test_data_array[(ia+4)][ib]<<8);
          }
          for (ib=0; ib<25; ib++) {
            buf_send[ib] = send_data_array[2*ib]+ (send_data_array[(2*ib)+1]<<16);
          }
          i= 1;
          k= 25;
          i = pcie_send_1(hDev, i, k, px);
//          printf(" send data array = %x, %x, %x, %x \n", send_data_array[0], send_data_array[1], send_data_array[2], send_data_array[3]);
//           printf(" send data array = %x, %x, %x, %x \n", buf_send[0], buf_send[1], buf_send[2], buf_send[3]);
          usleep(1000);
          printf(" send test dara array group 1 section %d\n", ia);
//          scanf("%d", &i);
        }

        printf(" set test to 1\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_test  + (0x1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//

        printf(" type 1 to contine\n");
        scanf("%d", &i);
        break;


     }



     break;

    case 23:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" calibration module address \n");
     scanf("%d",&imod_calib);
     printf(" 1st module slot number \n");
     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
     scanf("%d", &nmod);
//     printf(" number of sample \n");
//     scanf("%d", &nsample);
     nsample =12;
//     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     isel_xmit =0;
     isel_dcm =0;
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
//     iwrite = 0;
     if(iwrite ==1) {
       printf(" type 0 to /dev/null \n");
       scanf("%d", &i);
       if(i== 0) outf = fopen("/dev/null","w");
       else outf = fopen("/home/chi/test.dat","w");
     }
//
//
//
//     printf(" enter 1 to use pulse \n");
//     scanf("%d",&ipulse);
     ipulse =0;
//     printf(" enter 1 to use external trigger \n");
//     scanf("%d",&iext_trig);
     iext_trig =0;
//     printf(" enter 1 to use pulse generator module \n");
//     scanf("%d", &igen);
     igen =1;
     ifix_dac = 1;
     nstep = 100;
     nstep_event = 1000;
     nstep_dac =40;
     ipattern = 0xffff;
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
      printf(" type 1 for fix dac\n");
      scanf("%d", &ifix_dac);
     }
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent);


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }

//     printf(" enter 1 to load ADC test data memory\n");
//     scanf("%d", &itest_ram);
     itest_ram = 0;

     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
//     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,1);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,2);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev2,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//

       printf(" set the controller to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x1<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//
//
     if(igen ==1) {
//
// remove analog reset
//
        imod = imod_calib;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = imod_calib;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = imod_calib;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_calib;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_calib;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }


//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
      buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//     }

//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev2,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev2,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev2,1,1,px);
     }
//
//


//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0x10<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
      printf(" type 1 to set test ram state  \n");
      scanf("%d",&is);
//
//   verilog code issue I don't understand so I flip the test pulse bit
//

//      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
//      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
//      if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
//
//
       printf(" call adc setup  module %d\n", imod);
//       scanf("%d",&is);
       i = adc_testram_trig_load(hDev,imod, 400);
///
      scanf("%d",&is);
      if(itest_ram == 1) {
       printf(" call adc setup  module %d\n", imod);
       scanf("%d",&is);
       i = adc_testram_load(hDev,imod, 400);
      }
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =1;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
      }



//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         if(ifix_dac != 1) idac_shaper = idac_shaper *nstep_dac;    //set up the dac value
         else idac_shaper = 4000;

         imod = imod_calib;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_calib;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_calib;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_calib;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
//      else if (itest_ram == 1) {
//       printf(" send test pulse trigger \n");
//       scanf("%d", &i);
//       ichip = sp_adc_slowcntl_sub;
//       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
//      }
//      else if ((iext_trig != 1) & (igen != 1) & (itest_ram != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      else if ((iext_trig != 1) & (igen != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }

      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
         printf(" trigger received \n");
         ik=1;
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if((i%8) == 7) fprintf(outf,"\n");
        }
        fprintf(outf,"\n");
//        if((i%8) != 7) fprintf(outf,"\n");
       }
//       fprintf(outf,"\n");

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
//       iparity =0;
       for (ic=0; ic< nmod; ic++ ){
        ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
        iparity =0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));

        for (is=0; is<4+(nsample*64); is++) {
         if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
         else {
          u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
          iparity = iparity ^ u32Data;
         }
        }
        ioffset_t = ioffset + (64*nsample+4)+6;   // 4 words header + 5 event header -1 for array started at 0
        i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff);
        if(i != iparity) {
         printf(" event = %d, module %d Partity error....... = %x %x\n", ia, (imod_start+ic), i, iparity);
         if(iwrite != 1) scanf("%d", &i);
        }
        if(iwrite != 1) printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

        if(iwrite != 1) {
         printf(" parity word = %x\n", iparity);
         printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
         scanf("%d", &i );
         for (is=0; is<nsample; is++) {
          for (k=0; k<32; k++) {
           adc_data[k*2][is] = read_array1[11+ioffset+((k*nsample+is)*2)] & 0xffff;
           adc_data[(k*2)+1][is] = read_array1[10+ioffset+((k*nsample+is)*2)] & 0xffff;
          }
         }
         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
          printf("\n");
         }
         scanf("%d", &i );
        }
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
          if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }

        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write evennt = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;


    case 24:
//     printf(" number of loop \n");
//     scanf("%d",&nloop);
     nloop = 10;
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
     scanf("%d", &nmod);
     printf(" number of sample \n");
     scanf("%d", &nsample);
//     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     isel_xmit =0;
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     iwrite =0;
/*
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite ==1) {
       printf(" type 0 to /dev/null \n");
       scanf("%d", &i);
       if(i== 0) outf = fopen("/dev/null","w");
       else outf = fopen("/home/chi/test.dat","w");
     }
*/
//
//
//
     ipulse =0;
     iext_trig =0;
     igen =0;
/*
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
      printf(" type 1 for fix dac\n");
      scanf("%d", &ifix_dac);
     }
*/
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent); 


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }
     
     printf(" enter 1 to load ADC test data memory\n");
     scanf("%d", &itest_ram);

     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
//     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,1);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,2);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev2,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//

       printf(" set the controller to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x1<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
      buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//     }

//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev2,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev2,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev2,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0x10<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
      printf(" type 1 to set test ram state  \n");
      scanf("%d",&is);
//
//   verilog code issue I don't understand so I flip the test pulse bit
//

//      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
//      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
//      if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
      if(itest_ram == 1) {
       printf(" call adc setup  module %d\n", imod);
       scanf("%d",&is);
       i = adc_testram_trig_load(hDev,imod, 400);
      }
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }

//
//     reset system again...
//

//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
      buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//     }

//
//   after initial the xmit and controller -- initialize the DCM II
//



     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =1;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
      }



//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         if(ifix_dac != 1) idac_shaper = idac_shaper *nstep_dac;    //set up the dac value
         else idac_shaper = 4000;

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
//      else if (itest_ram == 1) {
//       printf(" send test pulse trigger \n");
//       scanf("%d", &i);
//       ichip = sp_adc_slowcntl_sub;
//       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
//      }
//      else if ((iext_trig != 1) & (igen != 1) & (itest_ram != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      else if ((iext_trig != 1) & (igen != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }

      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
         printf(" trigger received \n");
         ik=1;
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if((i%8) == 7) fprintf(outf,"\n");
        }
        fprintf(outf,"\n");
//        if((i%8) != 7) fprintf(outf,"\n");
       }
//       fprintf(outf,"\n");

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
//       iparity =0;
       for (ic=0; ic< nmod; ic++ ){
        ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
        iparity =0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));

        for (is=0; is<4+(nsample*64); is++) {
         if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
         else {
          u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
          iparity = iparity ^ u32Data;
         }
        }
        ioffset_t = ioffset + (64*nsample+4)+6;   // 4 words header + 5 event header -1 for array started at 0
        i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff);
        if(i != iparity) {
         printf(" event = %d, module %d Partity error....... = %x %x\n", ia, (imod_start+ic), i, iparity);
         if(iwrite != 1) scanf("%d", &i);
        }
        if(iwrite != 1) printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

        if(iwrite != 1) {
         printf(" parity word = %x\n", iparity);
         printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
         scanf("%d", &i );
         for (is=0; is<nsample; is++) {
          for (k=0; k<32; k++) {
           adc_data[k*2][is] = read_array1[11+ioffset+((k*nsample+is)*2)] & 0xffff;
           adc_data[(k*2)+1][is] = read_array1[10+ioffset+((k*nsample+is)*2)] & 0xffff;
          }
         }
         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
          printf("\n");
         }
         scanf("%d", &i );
        }
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
          if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }

        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write evennt = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;


    case 25:
//     printf(" number of loop \n");
//     scanf("%d",&nloop);
     nloop = 10;
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
     scanf("%d", &nmod);
     nsample = 12;
     printf(" number of sample \n");
//     scanf("%d", &nsample);
     printf(" trigger module address \n");
     scanf("%d", &ntrig_mod);
     printf(" enter 0 for lower chip and 1 for uooer chip \n");
     scanf("%d", &ntrig_chip);
     printf(" enter fifo delay size \n");
     scanf("%d", &trig_fifo_delay);
     printf(" enter sync delay step\n");
     scanf("%d", &sync_step);
     printf(" optical disable mask in hex\n");
     scanf("%x", &opt_mask);
     printf(" enter trigger threshold\n");
     scanf("%d", &ntrig_thr);
//static int   ntrig_mod, ntrig_chip, trig_fifo_delay, sync_step, opt_mask, ntrig_thr;


     for (i=0; i<8;  i++) {
      for (j=0; j<48; j++ ){
        test_data_array[i][j] =0;
      }
     }

     test_data_array[4][44] = 0x3f;
     test_data_array[7][46] = 0x3f;
//     test_data_array[5][44] = 0x3f;
//     test_data_array[6][44] = 0x3f;
//     test_data_array[7][44] = 0x3f;
//
//     test_data_array[4][40] = 0x3f;
//     test_data_array[5][40] = 0x3f;
//     test_data_array[6][40] = 0x3f;
//     test_data_array[7][40] = 0x3f;
//
     test_data_array[4][36] = 0x30;
     test_data_array[7][38] = 0x30;
//     test_data_array[5][36] = 0x3f;
//     test_data_array[6][36] = 0x3f;
//     test_data_array[7][36] = 0x3f;
//
     for (ib=0; ib< 48; ib++) {
      if (ib==0) printf("     %3d",ib);
      else printf("%3d",ib);
     }

     printf("\n");
      for (ia=0; ia<8; ia++) {
       printf("%4d ", ia);
       for (ib=0; ib<48; ib++ ) {
//           test_data_array[ia][ib] = ib+ia+10;
         printf("%3x", test_data_array[ia][ib]);
       }
       printf("\n");
      }
      printf("\n");
//
//
      for (ia=0;ia<8; ia++) {
       for (ib=0; ib<48; ib++ ) {
        test_data_array_1[ia+1][ib] = test_data_array[ia][ib];
       }
      }
//
//      data array-- top
//
      for (ib=0; ib<48; ib++ ) {
        test_data_array_1[0][ib] = test_data_array[7][ib];
      }
//
//      data array-- bottom
//
      for (ib=0; ib<48; ib++ ) {
       test_data_array_1[9][ib] = test_data_array[1][ib];
      }
      for (ib=0; ib<48; ib++ ) {
       test_data_array_1[10][ib] = test_data_array[0][ib];
      }

//
//      print out map
//
      for (ib=0; ib< 48; ib++) {
        if (ib==0) printf("    %3d",ib);
        else printf("%3d",ib);
      }
      printf("\n");
      for (ia=0;ia<11; ia++) {
       if(ia == 0) printf("phir", ia);
       else if (ia == 9) printf("ph10", ia);
       else if (ia == 10) printf("ph11", ia);
       else printf("%3d ", (ia-1));
       for (ib=0; ib<48; ib++ ) {
         printf("%3x", test_data_array_1[ia][ib]);
       }
       printf("\n");
      }
      printf("\n");
      printf("\n");


//
//      summer map
//
      for (ib=0; ib< 48; ib++) {
        if (ib==0) printf("    %3d",ib);
        else printf("%3d",ib);
      }
      printf("\n");
      for (ia=0;ia<10; ia++) {
       printf("%3d ", ia);
       for (ib=0; ib<47; ib++ ) {
        test_data_sum[ia][ib] = test_data_array_1[ia][ib]+test_data_array_1[ia][ib+1]+
           test_data_array_1[ia+1][ib]+test_data_array_1[ia+1][ib+1];
        ks[ia][ib] = test_data_sum[ia][ib];
        printf("%3x", test_data_sum[ia][ib]);
       }
       printf("\n");
      }
      printf("\n");
      for (ib=0; ib< 48; ib++) {
        if (ib==0) printf("    %3d",ib);
        else printf("%3d",ib);
      }
      printf("\n");
      for (ia=0;ia<8; ia++) {
       printf("%3d ", ia);
       for (ib=0; ib<47; ib++ ) {
         test_data_sum_1[ia][ib] = test_data_sum[ia+1][ib];
         printf("%3x", test_data_sum_1[ia][ib]);
       }
       printf("\n");
      }
      printf("\n");
//
//
      for (ia=0; ia<8; ia++) {
       for (ib=0; ib<48; ib++) {
        test_data_peak_valid[ia][ib]=0;
        test_data_peak_sum[ia][ib]=0;
       }
      }
      for(ia=1; ia<10; ia++) {
//       for (ib=1; ib<47; ib++) {
       for (ib=1; ib<46; ib++) {
        ic = ks[ia][ib];
        if((ic > ks[ia+1][ib+1]) && (ic > ks[ia][ib+1]) && (ic > ks[ia-1][ib+1]) &&
         (ic > ks[ia+1][ib]) && (ic >= ntrig_thr) && (ic >= ks[ia-1][ib]) &&
         (ic > ks[ia+1][ib-1]) && (ic >= ks[ia][ib-1]) && (ic >= ks[ia-1][ib-1]))
         test_data_peak_valid[ia-1][ib] =1;
/*
        if((ia == 5) && (ib== 36)) {
          printf(" %x %x %x\n", ks[ia-1][ib-1], ks[ia-1][ib], ks[ia-1][ib+1]);
          printf(" %x %x %x\n", ks[ia][ib-1], ks[ia][ib], ks[ia][ib+1]);
          printf(" %x %x %x\n", ks[ia+1][ib-1], ks[ia+1][ib], ks[ia+1][ib+1]);
          scanf("%d", &i);
        }
*/
        if((ic > ks[ia+1][ib+1]) && (ic > ks[ia][ib+1]) && (ic > ks[ia-1][ib+1]) &&
         (ic > ks[ia+1][ib]) && (ic >= ntrig_thr) && (ic >= ks[ia-1][ib]) &&
         (ic > ks[ia+1][ib-1]) && (ic >= ks[ia][ib-1]) && (ic >= ks[ia-1][ib-1]))
         test_data_peak_sum[ia-1][ib] = test_data_sum[ia][ib];
       }
      }

      for (ib=0; ib< 48; ib++) {
        if (ib==0) printf("    %3d",ib);
        else printf("%3d",ib);
      }
      printf("\n");
      for (ia=0; ia<8; ia++) {
       printf("%3d ", ia);
       for (ib=0; ib<47; ib++ ) {
         printf("%3x", test_data_peak_valid[ia][ib]);
//         printf("%3x", ks[ia][ib]);
       }
       printf("\n");
      }
      printf("\n");
      for (ia=0; ia<8; ia++) {
       printf("%3d ", ia);
       for (ib=0; ib<47; ib++ ) {
         printf("%3x", test_data_peak_sum[ia][ib]);
//         printf("%3x", ks[ia][ib]);
       }
       printf("\n");
      }
      printf("\n");
      
//
//    start transfer the hit map to the list
//
//    static int   test_data_sum_1[8][47], test_data_peak_valid[8][48], test_data_peak_sum[8][48];
//    static int   peak16_v[8][3][4], peak16_sum[8][3][4],peak16_nhit[8][3][4];

      for (ia=0; ia<8; ia++) {
       for (ib=0; ib<3; ib++) {
        peak16_nhit[ia][ib] =0;
        for (ic=0; ic<16; ic++) {
         ik = ib*16+ic;
         if (test_data_peak_valid[ia][ik] !=0) {
          j =  peak16_nhit[ia][ib];
          peak16_nhit[ia][ib] = peak16_nhit[ia][ib]+1;
          peak16_v[ia][ib][j] = ik;
          peak16_sum[ia][ib][j] = test_data_peak_sum[ia][ik];
         }
         if (peak16_nhit[ia][ib] == 4) break;
        }
       }
      }
//
//
      for (ia=0; ia<8; ia++) {
       printf(" slice %d, region 1 %d hits, region 2 %d hits, region 3 %d hits\n", ia,
         peak16_nhit[ia][0], peak16_nhit[ia][1], peak16_nhit[ia][2]);
       for (ib=0; ib<3; ib++){
        if( peak16_nhit[ia][ib] !=0) {
         for (ic=0; ic< peak16_nhit[ia][ib]; ic++) {
          printf(" slice %d, region %d, hit %d, address = %x, sum = %x \n",
          ia, ib, ic, peak16_v[ia][ib][ic], peak16_sum[ia][ib][ic] );
         }
        }
       }
      }
      printf("\n");
//
//
//
      for (ia=0; ia<8; ia++) {
       peak48_nhit[0] =0;
       for (ib=0; ib<4; ib++ ){
        peak48_add_out[ia][ib] = 0;
        peak48_sum_out[ia][ib] = 0;
       }
      }  

//    static int   peak48_add_out[8, peak48_sum_out[8];
      for (ia=0; ia<4; ia++ ) {
       peak48_nhit[ia] = 0;
       for (ib=0; ib<3; ib++) {
        if( peak16_nhit[ia][ib] != 0) {
         for (ic=0; ic< peak16_nhit[ia][ib]; ic++) {
          ik = peak48_nhit[ia];
          peak48_nhit[ia] = peak48_nhit[ia]+1;
          peak48_add_out[ia][ik] = (ia <<6) + (ib << 4) + (peak16_v[ia][ib][ic] & 0xf);
          peak48_sum_out[ia][ik] = peak16_v[ia][ib][ic];
          if (peak48_nhit[ia] == 4) break;
         }
        }
        if (peak48_nhit[ia] == 4) break;
       }
      }

//
//
//
      for (ia=4; ia<8; ia++ ) {
       peak48_nhit[ia] = 0;
       for (ib=0; ib<3; ib++) {
        if( peak16_nhit[ia][ib] != 0) {
         for (ic=0; ic< peak16_nhit[ia][ib]; ic++) {
          ik = peak48_nhit[ia];
          peak48_nhit[ia] = peak48_nhit[ia]+1;
          peak48_add_out[ia][ik] = ((ia-4) <<6) + (ib << 4) + (peak16_v[ia][ib][ic] & 0xf);
          peak48_sum_out[ia][ik] = peak16_sum[ia][ib][ic];
          if (peak48_nhit[ia] == 4) break;
         }
        }
        if (peak48_nhit[ia] == 4) break;
       }
      }
//
//
//
      for (ia=0; ia<8; ia++) {
       printf(" slice %d, hits %d \n", ia, peak48_nhit[ia]);
       if( peak48_nhit[ia] !=0) {
         for (ic=0; ic< peak48_nhit[ia]; ic++) {
          printf(" slice %d, hit %d, address = %x, sum = %x \n",
          ia, ic, peak48_add_out[ia][ic],peak48_sum_out[ia][ic]);
         }
       }
      }
      printf("\n");

      for (ia=0; ia<4; ia++) {
       ib= 2*ia;
       ic= 2*ia+1;
       i=trigger_sort(&peak48_sum_out[ib], &peak48_sum_out[ic],&peak48_add_out[ib], &peak48_add_out[ic], &out_sum_1[ia], &out_add_1[ia]);
       printf(" trigger sort between slice %d and %d \n", ib, ic);
       for (i=0; i<8; i++) {
        printf("i= %d, ia = %x, out_sum_1= %x, out_add_1 = %x \n", i, ia, out_sum_1[ia][i], out_add_1[ia][i]);
       }
       printf("\n");
       for (i=0; i<4; i++) {
        sort_sum[ia][i] = out_sum_1[ia][7-i];
        sort_add[ia][i] = out_add_1[ia][7-i];
       }
      }
      printf("\n");
//
//
      for (ia=0; ia<2; ia++) {
       ib= 2*ia;
       ic= 2*ia+1;
       i=trigger_sort(&sort_sum[ib], &sort_sum[ic], &sort_add[ib], &sort_add[ic], &out_sum_2[ia], &out_add_2[ia]);
       if(ia == 0) printf(" trigger sort on slice 1-4 \n");
       else printf(" trigger sort on slice 5-8 \n");
       for (i=0; i<8; i++) {
        printf("i= %d, ia = %x, out_sum_1= %x, out_add_1 = %x \n", i, ia, out_sum_2[ia][i], out_add_2[ia][i]);
       }
       printf("\n");
      }
      printf("\n");


//     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     isel_xmit =0;
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     iwrite =0;
/*
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite ==1) {
       printf(" type 0 to /dev/null \n");
       scanf("%d", &i);
       if(i== 0) outf = fopen("/dev/null","w");
       else outf = fopen("/home/chi/test.dat","w");
     }
*/
//
//
//
     ipulse =0;
     iext_trig =0;
     igen =0;
/*
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
      printf(" type 1 for fix dac\n");
      scanf("%d", &ifix_dac);
     }
*/
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent); 


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }
     
     printf(" enter 1 to load ADC test data memory\n");
     scanf("%d", &itest_ram);

     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
//     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,1);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,2);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev2,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//

       printf(" set the controller to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x1<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
      buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//     }
//    
//static int   ntrig_mod, ntrig_chip, trig_fifo_delay, sync_step, opt_mask, ntrig_thr;
     ik = ntrig_mod*2 + ntrig_chip;  // take care increse address bit by 2
     i = trigger_board_setup(hDev, ik, trig_fifo_delay, sync_step, opt_mask, ntrig_thr);
//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev2,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev2,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev2,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0x10<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
      printf(" type 1 to set test ram state  \n");
      scanf("%d",&is);
//
//   verilog code issue I don't understand so I flip the test pulse bit
//

//      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
//      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
//      if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
      if(itest_ram == 1) {
       printf(" call adc setup  module %d\n", imod);
       scanf("%d",&is);
       if(ik == 0) i = adc_testram_trig_load_1(hDev,imod, 400,1, 0x3000);
       if(ik == 1) i = adc_testram_trig_load_1(hDev,imod, 400,2, 0x3fff);
       if(ik == 2) i = adc_testram_trig_load_1(hDev,imod, 400,1, 0x3fff);
      }
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }

//
//     reset system again...
//

//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
      buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//     }

//
//   after initial the xmit and controller -- initialize the DCM II
//



     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =1;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
      }



//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         if(ifix_dac != 1) idac_shaper = idac_shaper *nstep_dac;    //set up the dac value
         else idac_shaper = 4000;

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
//      else if (itest_ram == 1) {
//       printf(" send test pulse trigger \n");
//       scanf("%d", &i);
//       ichip = sp_adc_slowcntl_sub;
//       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
//      }
//      else if ((iext_trig != 1) & (igen != 1) & (itest_ram != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      else if ((iext_trig != 1) & (igen != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }

      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
         printf(" trigger received \n");
         ik=1;
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if((i%8) == 7) fprintf(outf,"\n");
        }
        fprintf(outf,"\n");
//        if((i%8) != 7) fprintf(outf,"\n");
       }
//       fprintf(outf,"\n");

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
//       iparity =0;
       for (ic=0; ic< nmod; ic++ ){
        ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
        iparity =0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));

        for (is=0; is<4+(nsample*64); is++) {
         if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
         else {
          u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
          iparity = iparity ^ u32Data;
         }
        }
        ioffset_t = ioffset + (64*nsample+4)+6;   // 4 words header + 5 event header -1 for array started at 0
        i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff);
        if(i != iparity) {
         printf(" event = %d, module %d Partity error....... = %x %x\n", ia, (imod_start+ic), i, iparity);
         if(iwrite != 1) scanf("%d", &i);
        }
        if(iwrite != 1) printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

        if(iwrite != 1) {
         printf(" parity word = %x\n", iparity);
         printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
         scanf("%d", &i );
         for (is=0; is<nsample; is++) {
          for (k=0; k<32; k++) {
           adc_data[k*2][is] = read_array1[11+ioffset+((k*nsample+is)*2)] & 0xffff;
           adc_data[(k*2)+1][is] = read_array1[10+ioffset+((k*nsample+is)*2)] & 0xffff;
          }
         }
         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
          printf("\n");
         }
         scanf("%d", &i );
        }
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
          if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }

        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write evennt = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;





    case 26:
//     printf(" number of loop \n");
//     scanf("%d",&nloop);
     nloop = 10;
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
     scanf("%d", &nmod);
     nsample = 12;
     printf(" number of sample \n");
//     scanf("%d", &nsample);
     printf(" trigger module address \n");
     scanf("%d", &ntrig_mod);
     printf(" enter 0 for lower chip and 1 for uooer chip \n");
     scanf("%d", &ntrig_chip);
     printf(" enter fifo delay size \n");
//     scanf("%d", &trig_fifo_delay);
     printf(" enter sync delay step\n");
//     scanf("%d", &sync_step);
     printf(" optical disable mask in hex\n");
//     scanf("%x", &opt_mask);
     printf(" enter trigger threshold\n");
//     scanf("%d", &ntrig_thr);
     ntrig_thr =30;
     trig_fifo_delay =100;
     sync_step = 3;
     opt_mask =0;
     printf(" enter L1 monitor monitor readout delay \n");
//     scanf("%d", &L1trig_m_delay);
     printf(" enter number of sample L1 monitor readout \n");
//     scanf("%d", &L1trig_m_nsample);
     printf(" enter L1 monitor readout method \n");
     printf(" 1 for crate controller readout, 2 for JSEB II readout \n");
     scanf("%d", &L1trig_m_readmethod);
     L1trig_m_delay = 20;
     L1trig_m_nsample = 30;
//static int   ntrig_mod, ntrig_chip, trig_fifo_delay, sync_step, opt_mask, ntrig_thr;



//     printf(" type 1 to use xmit module \n");
//     scanf("%d", &isel_xmit);
     isel_xmit =0;
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     iwrite =0;
/*
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite ==1) {
       printf(" type 0 to /dev/null \n");
       scanf("%d", &i);
       if(i== 0) outf = fopen("/dev/null","w");
       else outf = fopen("/home/chi/test.dat","w");
     }
*/
//
//
//
     ipulse =0;
     iext_trig =0;
     igen =0;
/*
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
      printf(" type 1 for fix dac\n");
      scanf("%d", &ifix_dac);
     }
*/
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent); 


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }
     
     printf(" enter 1 to load ADC test data memory\n");
     scanf("%d", &itest_ram);

     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
//     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,1);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,2);
      printf(" DCM II booting done \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev2,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//

       printf(" set the controller to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x1<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
      buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//     }
//    
//static int   ntrig_mod, ntrig_chip, trig_fifo_delay, sync_step, opt_mask, ntrig_thr;
     imod_trig = ntrig_mod*2 + ntrig_chip;  // take care increse address bit by 2
     i = trigger_board_setup(hDev, imod_trig, trig_fifo_delay, sync_step, opt_mask, ntrig_thr);
//#define  sp_L1_s10_slow_m_size     23
//#define  sp_L1_s10_slow_m_delay    24
//#define  sp_L1_s10_slow_rstblk     25
//#define  sp_L1_s10_slow_dat2link   26
//#define  sp_L1_s10_slow_dat2rbdk   27

     printf(" type 1 to set trigger board m_size \n");
     scanf("%d",&is);

     ichip=0;
     buf_send[0]=(imod_trig <<10)+ (ichip << 8) + sp_L1_s10_slow_m_size  + ((L1trig_m_nsample-1)<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
     printf(" type 1 to set trigger board m_delay \n");
     scanf("%d",&is);

     ichip=0;
     buf_send[0]=(imod_trig <<10)+ (ichip << 8) + sp_L1_s10_slow_m_delay  + (L1trig_m_delay<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
     if (L1trig_m_readmethod == 1) {
      printf(" type 1 to set trigger board m_rstblk \n");
      scanf("%d",&is);

      ichip=0;
      buf_send[0]=(imod_trig <<10)+ (ichip << 8) + sp_L1_s10_slow_rstblk  + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
//
//
     if (L1trig_m_readmethod == 2) {
      printf(" type 1 to set trigger board dat2link \n");
      scanf("%d",&is);

      ichip=0;
      buf_send[0]=(imod_trig <<10)+ (ichip << 8) + sp_L1_s10_slow_dat2link  + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      ichip=0;
      buf_send[0]=(imod_trig <<10)+ (ichip << 8) + sp_L1_s10_slow_dat2rbdk  + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

     }
//
//
     if (L1trig_m_readmethod == 1) {
      printf(" type 1 to set trigger board dat2bdk \n");
      scanf("%d",&is);

      ichip=0;
      buf_send[0]=(imod_trig <<10)+ (ichip << 8) + sp_L1_s10_slow_dat2rbdk  + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
      ichip=0;
      buf_send[0]=(imod_trig <<10)+ (ichip << 8) + sp_L1_s10_slow_dat2link  + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

     }
//
//




//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev2,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev2,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev2,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0x10<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
      printf(" type 1 to set test ram state  \n");
      scanf("%d",&is);
//
//   verilog code issue I don't understand so I flip the test pulse bit
//

//      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
//      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
//      if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
      if(itest_ram == 1) {
       printf(" call adc setup  module %d\n", imod);
       scanf("%d",&is);
       i = adc_testram_trig_load_mbd(hDev,imod, 400,1, 0x3fff, 0x3fff);
//       if(ik == 0) i = adc_testram_trig_load_mbd(hDev,imod, 400,1, 0x3fff, 0x3fff);
//       if(ik == 1) i = adc_testram_trig_load_1(hDev,imod, 400,2, 0x3fff);
//       if(ik == 2) i = adc_testram_trig_load_1(hDev,imod, 400,1, 0x3fff);
      }
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }

//
//     reset system again...
//
     printf(" type 1 to send init \n");
     scanf("%d",&is);

//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
      buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//     }

//
//   after initial the xmit and controller -- initialize the DCM II
//

//
//      readout starus
//
      nword =4;
      py = &read_array;
      ichip =0;
//
//
//
//    command to which module took the readback bus
      buf_send[0]=(imod_trig<<10)+(ichip<<8)+(sp_L1_s10_slow_mbd_o_read) + (0x0<<16);  // read out status
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);

//
      printf(" send l1 trigger status read command \n");
      scanf("%d", &i);
//
//
      nword =2;
      py = &read_array;
      i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
      usleep(10);
      buf_send[0]=(imod_trig<<10)+(ichip<<8)+(sp_L1_s10_slow_mbd_o_read) + (0x0<<16);  // read out status
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
//        printf(" before read data word received = %x %x %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3]);
      usleep(10);
      i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//        usleep(10);
      printf(" after read data word received = %x %x\n", read_array[0], read_array[1]);
      printf(" module number %d, chip %d \n", ((read_array[0] & 0x3e00) >> 9), ((read_array[0] & 0x100) >>8));
      printf(" optical cable locked status = %x\n", ((read_array[0] & 0xff) + (((read_array[0]>>16) & 0xffff) <<8)));
      printf(" PLL lock status %d \n", ((read_array[1] >> 8) & 0x1));
//
      printf(" send l1 trigger header read command \n");
      scanf("%d", &i);
//
      nword =14;
      py = &read_array;
      i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
      usleep(10);
      buf_send[0]=(imod_trig<<10)+(ichip<<8)+(sp_L1_s10_slow_mbd_h_read) + (0x0<<16);  // read out status
      i=1;
      k=1;
      i = pcie_send_1(hDev, i, k, px);
//        printf(" before read data word received = %x %x %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3]);
      usleep(10);
      i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//        usleep(10);
      printf(" ************************************************************\n");
      printf(" optical header word 1 = %x %x %x %x %x %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3], read_array[4], read_array[5], read_array[6]);
      printf(" optical header word 2 = %x %x %x %x %x %x %x\n", read_array[7], read_array[8], read_array[9], read_array[10], read_array[11], read_array[12], read_array[13]);
      printf(" module number %d, chip %d \n", ((read_array[0] & 0xf8)>> 3), ((read_array[0] & 0x4) >>2));
      for (i=0; i<24; i++) {
       k=i+1;
       if ((i%2) == 0) printf(" fiber %d, FEM address %d, beam counter %x \n", i, (read_array[i/2] >> 24), ((read_array[i/2] & 0xff0000) >>16));
       else printf(" fiber %d, FEM address %d, beam counter %x \n", i, ((read_array[k/2] & 0xff00) >> 8), (read_array[k/2] & 0xff));
      }
      printf(" trigger board beam counter = %x\n", ((read_array[12] & 0xff0000) >>16));
      printf(" ************************************************************\n");


     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =1;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x \n", imod, read_array[0], read_array[1]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
       }
      }

      if (L1trig_m_readmethod == 2) {
       nread_trig =(2+(L1trig_m_nsample*40/2)+1);
       i = pcie_rec_2(hDev2,0,1,nread_trig,iprint,py);
      }


//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         if(ifix_dac != 1) idac_shaper = idac_shaper *nstep_dac;    //set up the dac value
         else idac_shaper = 4000;

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
//      else if (itest_ram == 1) {
//       printf(" send test pulse trigger \n");
//       scanf("%d", &i);
//       ichip = sp_adc_slowcntl_sub;
//       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
//      }
//      else if ((iext_trig != 1) & (igen != 1) & (itest_ram != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      else if ((iext_trig != 1) & (igen != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }
//
//
//
//#define  sp_L1_s10_slow_mbd_m_data_transfer  34
//#define  sp_L1_s10_slow_mbd_m_data_read      35
//
      if (L1trig_m_readmethod == 2) {
       printf(" ready to receive L1 trigger monitor data \n");
       scanf("%d", &i);
       i = pcie_rec_2(hDev2,0,2,nread_trig,iprint,py);
       usleep(100);
//      printf(" data received = %x %x %x %x \n", read_array[0], read_array[1], read_array[2], read_array[3]);
//
//
       printf(" header 1 = %x\n", read_array[0]);
       printf(" header 2 = %x\n", read_array[1]);

       k=0;
       for (is=0; is< (nread_trig-2); is++) {
        if(is%8 ==0) printf(" %d ", is);
        printf(" %8X", read_array[is+2]);
        k=k+1;
        if((k%8) ==0) printf("\n");
       }
//
       if((is%8) !=0) printf("\n");
       printf(" data parity = %x \n", read_array[is+1]);
       scanf("%d", &i);
       printf(" header = %x \n", (read_array[0] & 0xffff));
       printf(" module number = %d \n", ((read_array[0]>> 16) & 0x3f));
       printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
       printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
       for (is=0; is< L1trig_m_nsample; is++ ) {
        for (k=0; k< 20; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
         adc_data[(k*2)][is] = read_array[(k*L1trig_m_nsample)+is+2] & 0xffff;
         adc_data[((k*2+1))][is] = (read_array[(k*L1trig_m_nsample)+is+2] >>16) & 0xffff;
        }
       }

       for (is=0; is<40; is++) {
        printf(" channel %2d ", is);
        for (k=0; k<L1trig_m_nsample; k++) {
         printf(" %4x", adc_data[is][k]);
        }
        printf("\n");
       }



      }

//
//
      if (L1trig_m_readmethod == 1) {
       printf(" send L1 trigger data transfer --- \n");
       scanf("%d", &i);
       ichip = 0;
       buf_send[0]=(imod_trig <<10)+ (ichip << 8) + sp_L1_s10_slow_mbd_m_data_transfer + (0x0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(1000);
//
//      initialize the receiver
//
       iprint = 0;
       nread = 2+(32*L1trig_m_nsample/2)+1;
       i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words
 //
 //
       printf(" send L1 trigger monitot data read **** \n");
       scanf("%d", &i);
       ichip = 0;
       buf_send[0]=(imod_trig <<10)+ (ichip << 8) + sp_L1_s10_slow_mbd_m_data_read + (0x0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(1000);
//
//
       i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
//
//
       printf(" header 1 = %x\n", read_array[0]);
       printf(" header 2 = %x\n", read_array[1]);

       k=0;
       for (is=0; is< (nread-2); is++) {
        if(is%8 ==0) printf(" %d ", is);
        printf(" %8X", read_array[is+2]);
        k=k+1;
        if((k%8) ==0) printf("\n");
       }
//
       if((is%8) !=0) printf("\n");
       printf(" data parity = %x \n", read_array[is+1]);

       printf(" header = %x \n", (read_array[0] & 0xffff));
       printf(" module number = %d \n", ((read_array[0]>> 16) & 0x3f));
       printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
       printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
       for (is=0; is< L1trig_m_nsample; is++ ) {
        for (k=0; k< 16; k++) {
         adc_data[(k*2+1)][is] = read_array[(k*L1trig_m_nsample)+is+2] & 0xffff;
         adc_data[((k*2))][is] = (read_array[(k*L1trig_m_nsample)+is+2] >>16) & 0xffff;
        }
       }

       for (is=0; is<32; is++) {
       printf(" channel %2d ", is);
        for (k=0; k<L1trig_m_nsample; k++) {
         printf(" %4x", adc_data[is][k]);
        }
        printf("\n");
       }

       scanf("%d", &i );
      } 


//
//

      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
         printf(" trigger received \n");
         ik=1;
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }

//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if((i%8) == 7) fprintf(outf,"\n");
        }
        fprintf(outf,"\n");
//        if((i%8) != 7) fprintf(outf,"\n");
       }
//       fprintf(outf,"\n");

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
//       iparity =0;
       for (ic=0; ic< nmod; ic++ ){
        ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
        iparity =0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));

        for (is=0; is<4+(nsample*64); is++) {
         if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
         else {
          u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
          iparity = iparity ^ u32Data;
         }
        }
        ioffset_t = ioffset + (64*nsample+4)+6;   // 4 words header + 5 event header -1 for array started at 0
        i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff);
        if(i != iparity) {
         printf(" event = %d, module %d Partity error....... = %x %x\n", ia, (imod_start+ic), i, iparity);
         if(iwrite != 1) scanf("%d", &i);
        }
        if(iwrite != 1) printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

        if(iwrite != 1) {
         printf(" parity word = %x\n", iparity);
         printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
         scanf("%d", &i );
         for (is=0; is<nsample; is++) {
          for (k=0; k<32; k++) {
           adc_data[k*2][is] = read_array1[11+ioffset+((k*nsample+is)*2)] & 0xffff;
           adc_data[(k*2)+1][is] = read_array1[10+ioffset+((k*nsample+is)*2)] & 0xffff;
          }
         }
         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
          printf("\n");
         }
         scanf("%d", &i );
        }
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
          if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }

        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write evennt = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
    break;


    case 27:
     printf(" trigger borad test \n");
     printf(" enable number of loop\n");
     scanf("%d",&nloop);
//     printf(" 1 for checking the event \n");
//     scanf("%d",&icheck);
//     printf(" type 1 to use random number \n");
//     scanf("%d",&irand);
     icheck =0;
     irand = 0;
     islow_read =0;
//     if(icheck != 1) {
//      printf(" 1 for print event\n");
//      scanf("%d",&iprint);
//     }
//     else iprint =0;
//     iprint = 1;
//     printf(" number event \n");
//     scanf("%d",&nevent);

//     printf(" enter number of words per packet \n");
//     scanf("%d",&nsend);
     nsend=500;
     imod_trig=18;
     printf("trigger module address %d\n", imod_trig);

     px = &buf_send;
     py = &read_array;
//
//   controller
//
     imod =0;  /* controller module */
/** initialize **/
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+((0x1)<<16); //set trigger deadtime size
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

//    for (j=1; j<nloop; j++) {
     imod=imod_trig;
     iframe= 255;    //1023
     buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     usleep(5000);
     imod=imod_trig;
//     buf_send[0]=(imod<<11)+(mb_trig_mask8)+((0x2 & 0xffff)<<16); // enable external trigger mask
     buf_send[0]=(imod<<11)+(mb_trig_mask8)+((0x4a & 0xffff)<<16); // enable external trigger mask
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     usleep(5000);
     imod=imod_trig;         //fack module
     buf_send[0]=(imod<<11)+(mb_trig_prescale8)+((0x0 & 0xffff)<<16); // set prescale for mask 8
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);


//     }


     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

      printf(" set up to run \n");
      scanf("%d",&ik);

     imod=imod_trig;
     buf_send[0]=(imod<<11)+(mb_trig_calib_delay)+((0x10)<<16); //set up calibration delay to 0x20
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     for (j=1; j<nloop; j++) {
      imod=imod_trig;
      if(j==2) printf("enter calibration test loop\n");
      buf_send[0]=(imod<<11)+(mb_trig_calib)+((0x0)<<16); //fire up calibration pulse
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(5000);
     }


     for (j=1; j<nloop; j++) {

      iprint=1;
      nread = 5;
      i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // init the receiver

      imod =imod_trig;  /* trigger module */
      buf_send[0]=(imod<<11)+mb_trig_pctrig+((0x0)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);

      printf(" enter 1 to read system status \n");
      scanf("%d",&ik);

      nword = 7;

      i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver


      scanf("%d",&ik);

      imod=imod_trig;
      ichip=3;   // don't care about ichip #
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_trig_rd_param+(0x0<<16);  // read out status
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      py = &read_array;
      i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
      printf("receive data word = %x, %x, %x, %x \n", read_array[0], read_array[1],read_array[2], read_array[3]);
      printf("receive data word = %x, %x, %x\n", read_array[4], read_array[5],read_array[6]);
//
//
//
      py = &read_array;
      i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
      printf("optical receive data word = %x, %x, %x\n", read_array[0], read_array[1],read_array[2]);

      scanf("%d",&ik);

     }

     break;




    case 28:
     printf(" enter module number %d \n");
     scanf("%d", &nmod);
//
     px = &buf_send;
     py = &read_array;
     printf(" enter 1 for initialization \n");
     scanf("%d",&i);
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

      printf(" set the device to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x0<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//#define  sp_adc_trig_sub_delay      1
//#define  sp_adc_trig_tbl_chnl       2
//#define  sp_adc_trig_lkp_addr       3
//#define  sp_adc_trig_lkp_data       4
//#define  sp_adc_trig_smpl_phase     5
//#define  sp_adc_trig_smpl_phase     5
//#define  sp_adc_trig_read_delay     6
//#define  sp_adc_trig_read_size      7
//#define  sp_adc_trig_lkp_write     10
//#define  sp_adc_trig_mbd_tbl_add   11
//#define  sp_adc_trig_mbd_tbl_data  12

//
//      printf(" sending data packet \n");
//      scanf("%d", &i);
      
      imod = nmod;

//
//
//         imod = ik+imod_start;
      ichip = sp_adc_trigproc_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_tbl_chnl + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      printf(" sending data packet \n");
//      scanf("%d", &i);

      ichip = sp_adc_trigproc_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_mbd_tbl_add + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//      printf(" sending data packet \n");
//      scanf("%d", &i);
//

//
//      loading the slewing correction table for channel 0-31
//
      for (ich=0 ; ich< 64; ich++) {
//#define  sp_adc_trig_tbl_chnl       2
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_tbl_chnl + (ia<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" adc table loading channel %d \n", ich);

       for (i=0; i<1024; i++) {
        l1_adc_table[i] = (i+ich) & 0x3ff;
       }
       step_size = 1024;
//       for (is=0; is<5; is++) {
//        ia = is*step_size;
//        ib = (is+1)*step_size+1;
        ia=0;
        ib= 1025;
        ichip = sp_adc_trigproc_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_addr + (ia<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
//
        printf(" sending data packet ADC correction %d\n", is);
        scanf("%d", &i);
        for (i=ia; i<ib; i++) {
         if(i == ia) buf_send[0] = (imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_data + (l1_adc_table[i] & 0x3ff) ;
         else if (((i%2) == 0) &&(i !=ia)) {
          j = (i-ia)/2;
          buf_send[j] = (l1_adc_table[i-1] & 0x3ff) + ((l1_adc_table[i] & 0x3ff) <<16);
//         printf(" %d %x\n", j, buf_send[j]);
         }
        }
        i=1;
        k=(step_size/2)+1;
        i = pcie_send_1(hDev, i, k, px);
        k=(step_size/10)+1;
        usleep(k);
      }


//
//      loading the adc correction table
//
      for (ich=0 ; ich< 32; ich++) {
//#define  sp_adc_trig_tbl_chnl       2
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_tbl_chnl + (ia<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" slewing table loading channel %d \n", ich);

       for (i=0; i<4096; i++) {
        l1_slewing_table[i] = (i+ich) & 0x1ff;
       }
       step_size = 1024;
       for (is=0; is<5; is++) {
        ia = is*step_size;
        ib = (is+1)*step_size+1;
        ichip = sp_adc_trigproc_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) +  + (ia<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
//
        printf(" sending data packet %d\n", is);
        scanf("%d", &i);
        for (i=ia; i<ib; i++) {
         if(i == ia) buf_send[0] = (imod <<11)+ (ichip << 8) + sp_adc_trig_mbd_tbl_data + (l1_slewing_table[i] & 0x1ff) ;
         else if (((i%2) == 0) &&(i !=ia)) {
          j = (i-ia)/2;
          buf_send[j] = (l1_slewing_table[i-1] & 0x1ff) + ((l1_slewing_table[i] & 0x1ff) <<16);
//         printf(" %d %x\n", j, buf_send[j]);
         }
        }
        i=1;
        k=(step_size/2)+1;
        i = pcie_send_1(hDev, i, k, px);
        k=(step_size/10)+1;
        usleep(k);
       }
      }

//
//      loading the slewing correction table for channel 0-31
//
      for (ich=0 ; ich< 64; ich++) {
//#define  sp_adc_trig_tbl_chnl       2
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_tbl_chnl + (ia<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" slewing table loading channel %d \n", ich);

       for (i=0; i<1024; i++) {
        l1_adc_table[i] = (i+ich) & 0x3ff;
       }
       step_size = 1024;
//       for (is=0; is<5; is++) {
//        ia = is*step_size;
//        ib = (is+1)*step_size+1;
        ia=0;
        ib= 1025;
        ichip = sp_adc_trigproc_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_addr + (ia<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
//
        printf(" sending data packet ADC correction %d\n", is);
        scanf("%d", &i);
        for (i=ia; i<ib; i++) {
         if(i == ia) buf_send[0] = (imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_data + (l1_adc_table[i] & 0x3ff) ;
         else if (((i%2) == 0) &&(i !=ia)) {
          j = (i-ia)/2;
          buf_send[j] = (l1_adc_table[i-1] & 0x3ff) + ((l1_adc_table[i] & 0x3ff) <<16);
//         printf(" %d %x\n", j, buf_send[j]);
         }
        }
        i=1;
        k=(step_size/2)+1;
        i = pcie_send_1(hDev, i, k, px);
        k=(step_size/10)+1;
        usleep(k);
      }


     break;

    case 29:

     printf(" boot 5th FPGA \n");
     i=dcm2_fpga_boot_n(hDev2,11,1);
     printf ("boot 5th fpga, enter something to continue\n");
     scanf("%d",&k);
     i=dcm2_fpga_boot_n(hDev2,11,2);
     printf ("boot fpga 1-4, enter something to continue\n");
     scanf("%d",&k);
/*
     printf(" how many loops \n");
     scanf("%d",&nloop);
     printf(" number of words in the event packets < 500\n");
     scanf("%d",&nword);
     printf(" number of events per loop \n");
     scanf("%d",&nevent);
     printf(" set mask \n");
     scanf("%x",&nmask);
     printf(" type 1 to check the data \n");
     scanf("%d",&icheck);
*/
     px = &buf_send;
     py = &read_array;
     imod=11;
     imod_dcm = 11;
     ioffset=4;
     ichip =5;
     nmask = 0x1; /*turn non all channel */
     nword = 391;
     nloop = 100;
     nevent = 1;
     iwrite = 0;

     nfem = 1;
     nsample = 11;

     for (i=15; i< 31; i++) {
      if((i%2) ==0) {
        j= j+ (i<<14);
        printf("%d , %x\n", i, j);
      }
      else j= i;
     }
//
     printf(" enter number of FEM \n");
     scanf("%d", &nfem);
     printf(" neter 1 to turn on the zero suppression pass \n");
     scanf("%d", &npass);

     nword = (5+((4+2)*nfem+nfem*(64*12))+1)/2;
     printf(" nword = %d\n", nword);
//
     printf(" enter 1 turn tun off \n");
     scanf("%d", &i);
     iadd=(imod<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
     buf_send[0]=iadd+dcm2_run_off;
     ik=pcie_send(hDev2,1,1,px);
//
//
//
     printf(" set offline and mask for fpga 1-4 \n");
     for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod<<11)+(ichip<<8);
/* set module to offline mode */
        buf_send[0]=iadd+dcm2_online+(0x0<<16);
        ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev2,1,1,px);
     }
     printf(" set dcm2 offline fake data loading enable 1-4 \n");
     for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod<<11)+(ichip<<8);
// offline fake data read enable
        buf_send[0]=iadd+dcm2_offline_load+(0x2<<16); // bit 1 == 1 (on)
        ik=pcie_send(hDev2,1,1,px);
     }
     printf(" working on 5th fpga, offline and mask \n");
/** work on 5th FPGA **/
     ichip=5;
     iadd=(imod<<11)+(ichip<<8);
/* set module to offline mode */
     buf_send[0]=iadd+dcm2_online+(0x0<<16);
     ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
     buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
     ik=pcie_send(hDev2,1,1,px);
//
//
//
     printf(" set dcm2 to be 1st module and last module in the token passing chain \n");
/* set dcm first module */
     buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
     ik=pcie_send(hDev2,1,1,px);
/* sey mask on for all channel*/
     buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
     ik=pcie_send(hDev2,1,1,px);
//
/*
#define dcm2_cal_thresh1_add 55
#define dcm2_cal_thresh2_add 56
#define dcm2_cal_thresh1_data 57
#define dcm2_cal_thresh2_data 58
#define dcm2_cal_thresh1_write 59
#define dcm2_cal_thresh2_write 60
#define dcm2_cal_nfem1 61
#define dcm2_cal_nfem2 62
#define dcm2_cal_nsmpl1 63
#define dcm2_cal_nsmpl2 64
#define dcm2_cal_nfem_pass1 65
#define dcm2_cal_nfem_pass2 66

#define dcm2_n_cal_fst 0x8
#define dcm2_n_cal_p_head 0x9
#define dcm2_n_cal_fem_head 0xa
#define dcm2_n_cal_smpl 0x3
#define dcm2_n_cal_lst 0x2
#define dcm2_n_cal_chnl 0x1

*/
     ichip=1;
     for (ia=0; ia<nfem; ia++) {
      for (ib=0; ib<63; ib++) {
//set address
        buf_send[0] = (imod<<11) + (ichip<<8) +  dcm2_cal_thresh1_add + (ib<<16);
        ik=pcie_send(hDev2,1,1,px);
        buf_send[0] = (imod<<11) + (ichip<<8) +  dcm2_cal_thresh1_data + (ib<<16);
        ik=pcie_send(hDev2,1,1,px);
        buf_send[0] = (imod<<11) + (ichip<<8) +  dcm2_cal_thresh1_write + (0<<16);
        if((ib==1) | (ib==2)) {
          printf(" ib = %d, threshold memory load \n", ib);
          scanf("%d", &ik);
        }
        ik=pcie_send(hDev2,1,1,px);
      }
     }

     buf_send[0] = (imod<<11) + (ichip<<8) +  dcm2_cal_nfem1 + (nfem<<16);
     ik=pcie_send(hDev2,1,1,px);

     buf_send[0] = (imod<<11) + (ichip<<8) +  dcm2_cal_nsmpl1 + (nsample<<16);
     ik=pcie_send(hDev2,1,1,px);

     if(npass == 1) buf_send[0] = (imod<<11) + (ichip<<8) +  dcm2_cal_nfem_pass1 + (0x1<<16);
     else buf_send[0] = (imod<<11) + (ichip<<8) +  dcm2_cal_nfem_pass1 + (0x0<<16);
     ik=pcie_send(hDev2,1,1,px);


     printf(" set RUN on \n");
     scanf("%d", &ik);
     iadd=(imod<<11)+(ichip<<8);
/* set run =1 */
     buf_send[0]=iadd+dcm2_run_on;
     ik=pcie_send(hDev2,1,1,px);

     for (j=0; j<nloop; j++) {
      idcm_send_p = &idcm_send_array;
      read_array_c_p = &read_array_c;
      read_array1_p = &read_array1;


      nword_tot = 0;
      for (iv=0; iv<nevent; iv++) {
       if(icheck !=1) printf(" enter 1 to go to next event \n");
/*** load fake data ***/
       ioffset =ioffset+1;
       if(ioffset >= 0xf000) ioffset =0;
       for (i=1; i<5; i++) {
        for (is=0; is<2; is++) {
         if(((nmask >> ((i-1)*2+is)) & 0x1) != 0) {
          index=0;
          index1=0;
          ichip=i;
          iadd=(imod<<11)+(ichip<<8);
          il=0x100*((i-1)*2+is);
          for (k=0; k<nword; k++) {
           if(k==0) {
            itmp = il+2*k+1+ioffset;
            if(is == 0) buf_send[k]=iadd+dcm2_load_packet_a+(itmp<<16);
            else buf_send[k]=iadd+dcm2_load_packet_b+(itmp<<16);
            *idcm_send_p++ = 0x40000000 + ((nword*2-3)<<16)+itmp;  // header word
            *idcm_send_p++ = 0x40000000+ (index <<16)+ itmp;
            *read_array1_p++ = itmp;
            printf("k==0 , index = %x\n", itmp);
            index1 = index1 +1;
            index =index+1;
           }
/*
#define dcm2_n_cal_fst 0x80000000
#define dcm2_n_cal_p_head 0x90000000
#define dcm2_n_cal_fem_head 0xa0000000
#define dcm2_n_cal_smpl 0x30000000
#define dcm2_n_cal_lst 0x20000000
#define dcm2_n_cal_chnl 0x10000000

int   is1,is2, index1, is2_ch, is2_smpl;
*/
           else {
            itmp = il+2*k+ioffset;
            buf_send[k]= itmp+((itmp+1)<<16);
            *read_array1_p++ = itmp;
            *read_array1_p++ = itmp+1;

            if( k== nword-1) {
               *idcm_send_p++ =  (index <<16)+ itmp;
               index = index+1;
               *idcm_send_p++ = 0x80000000+(index <<16)+ (itmp+1);
               index = index+1;
            }
            else {
               *idcm_send_p++ =  (index <<16)+ itmp;
               index = index+1;
               *idcm_send_p++ =  (index <<16)+ (itmp+1);
               index = index+1;
            }
           }
          }
          printf(" send packet \n");
          scanf("%d", &ik);
          ik=pcie_send(hDev2,1,nword,px);
          usleep(1000);
          read_array1_p = &read_array1;
          index1=0;
          for (k=0; k<(2*nword-1); k++) {
           if(k <= 4) {
             if(k== 0) {
              *read_array_c_p++ =  dcm2_n_cal_fst + *read_array1_p++;
               index1 = index1 +1;
             }
             else {
              *read_array_c_p++ = dcm2_n_cal_p_head + *read_array1_p++ ;
              index1 = index1+1;
             }
           }
           if (k >= 5) {
            is1 =(k-5)%(64*(nsample+1)+4+2);
            if (is1 <= 3) {
              *read_array_c_p++ =  dcm2_n_cal_fem_head + *read_array1_p++;
              index1 = index1+1;
            }
            if ((is1 >= 4) && (is1 <= ((64*(nsample+1))+3))) {
              is2 = is1-4;
              is2_smpl = is2%(nsample+1);
              if(is2_smpl == 0) is2_ch = is2/(nsample+1);
              if((is2_smpl == 0) && (is2_ch ==0)) is2_mod = (k-5)/(4+2+64*nsample);
              if((is2_smpl%2)== 0) ijk = *read_array1_p++ ;
              else {
                *read_array_c_p++ = ijk + ((*read_array1_p++)<<14) + dcm2_n_cal_smpl;
                index1 = index1+1;
              }
              if (is2_smpl == nsample) {
                *read_array_c_p++ = dcm2_n_cal_chnl + is2_ch +(is2_mod<<6);
                index1 = index1+1;
              }
            }
            if (is1 >= ((64*(nsample+1))+4)) {
              *read_array_c_p++ = dcm2_n_cal_lst + *read_array1_p++;
              index1 = index1+1;
            }
           }
          }
          
          printf(" index1 = %d\n", index1);
          read_array_c_p = &read_array_c;

          for (k=0; k < index1; k++) {
           if ((k%8)==0) printf(" %3d", k);
           printf(" %8x", *read_array_c_p++);
           if (((k+1)%8) == 0) printf("\n");
          }
          if((k+1)%8 !=0) printf("\n");

          nword_tot = nword_tot+nword*2;
         }
        }
       }
      }
//
//
       nread = 2;
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" word count = %x \n", ((((read_array[0])>>16)<<16)+((read_array[1] & 0xffff))));
 //       printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
 //       printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[1] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[1] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       printf(" frame word count = %x, %d \n", iread, iread);
       printf(" source id = %x \n",(read_array[0] & 0xffff0000) + (read_array[1] &0xffff));
       u32Data = (read_array[5] & 0xffff0000) + (read_array[6] &0xffff);
       printf(" event number= %x \n", (u32Data & 0xffff));
       u32Data = (read_array[6] & 0xffff0000) + (read_array[7] &0xffff);
       printf(" clock number= %x \n", (u32Data & 0xffff));
       u32Data = (read_array[7] & 0xffff0000) + (read_array[8] &0xffff);
       printf(" packet word count= %x %d \n", (u32Data & 0xffff), (u32Data & 0xffff));

       for (i=13; i<(nread-2); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        ib=i-13;
        if(iwrite != 1) {
         if(ib%8 == 0) printf("%3d",ib);
         printf(" %9x",u32Data);
         if(ib%8 == 7) printf("\n");
        }
       }
       if(ib%8 !=7) printf("\n");
 //
//
      printf(" loop = %d \n", j);
      scanf("%d", &i);
     }


     break;

     case 30:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
     scanf("%d", &nmod);
     printf(" number of sample \n");
     scanf("%d", &nsample);
     printf(" type 1 to use xmit module \n");
     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite ==1) {
       printf(" type 0 to /dev/null \n");
       scanf("%d", &i);
       if(i== 0) outf = fopen("/dev/null","w");
       else outf = fopen("/home/chi/test.dat","w");
     }
//
//
//
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
      printf(" type 1 for fix dac\n");
      scanf("%d", &ifix_dac);
     }
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent); 


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }
     
     printf(" enter 1 to load ADC test data memory\n");
     scanf("%d", &itest_ram);

     px = &buf_send;
     py = &read_array;
     npass = 1;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
//     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot_n(hDev2,imod_dcm,1);
      printf(" type 1 to continue \n");
      scanf("%d", &i);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot_n(hDev2,imod_dcm,2);
      printf(" type 1 to continue \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev2,1,1,px);
      
      ichip=1;
      for (ia=0; ia<nmod; ia++) {
       for (ib=0; ib<63; ib++) {
//set address
        buf_send[0] = (imod_dcm<<11) + (ichip<<8) +  dcm2_cal_thresh1_add + (ib<<16);
        ik=pcie_send(hDev2,1,1,px);
        buf_send[0] = (imod_dcm<<11) + (ichip<<8) +  dcm2_cal_thresh1_data + (ib<<16);
        ik=pcie_send(hDev2,1,1,px);
        buf_send[0] = (imod_dcm<<11) + (ichip<<8) +  dcm2_cal_thresh1_write + (0<<16);
        if((ib==1) | (ib==2)) {
          printf(" ib = %d, threshold memory load \n", ib);
          scanf("%d", &ik);
        }
        ik=pcie_send(hDev2,1,1,px);
       }
      }
//
//
      buf_send[0] = (imod_dcm<<11) + (ichip<<8) +  dcm2_cal_nfem1 + (nmod<<16);
      ik=pcie_send(hDev2,1,1,px);

      buf_send[0] = (imod_dcm<<11) + (ichip<<8) +  dcm2_cal_nsmpl1 + ((nsample-1)<<16);
      ik=pcie_send(hDev2,1,1,px);

      if(npass == 1) buf_send[0] = (imod_dcm<<11) + (ichip<<8) +  dcm2_cal_nfem_pass1 + (0x1<<16);
      else buf_send[0] = (imod_dcm<<11) + (ichip<<8) +  dcm2_cal_nfem_pass1 + (0x0<<16);
      ik=pcie_send(hDev2,1,1,px);


     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//

       printf(" set the controller to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x1<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
      buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//     }

//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev2,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev2,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev2,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0x10<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
      printf(" type 1 to set test ram state  \n");
      scanf("%d",&is);
//
//   verilog code issue I don't understand so I flip the test pulse bit
//

//      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
//      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
//      if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
      if(itest_ram == 1) {
       printf(" call adc setup  module %d\n", imod);
       scanf("%d",&is);
       i = adc_testram_load(hDev,imod, 400);
      }
//sp_adc_sel_link_rxoff



     }
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =3;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x, %x\n", imod, read_array[0], read_array[1], read_array[2]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        printf (" firmware version %d\n", ((read_array[2]>>8) & 0xff));
        printf (" firmware sub version %d\n", ((read_array[2]) & 0xff));
        printf (" firmware version header %x\n", ((read_array[2])>>16));
       }
      }



//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         if(ifix_dac != 1) idac_shaper = idac_shaper *nstep_dac;    //set up the dac value
         else idac_shaper = 4000;

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
//      else if (itest_ram == 1) {
//       printf(" send test pulse trigger \n");
//       scanf("%d", &i);
//       ichip = sp_adc_slowcntl_sub;
//       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
//      }
//      else if ((iext_trig != 1) & (igen != 1) & (itest_ram != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      else if ((iext_trig != 1) & (igen != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }

      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
         printf(" trigger received \n");
         ik=1;
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 2;
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" word count = %x \n", ((((read_array[0])>>16)<<16)+((read_array[1] & 0xffff))));
//        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
//        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
//       iread = read_array[2] & 0xffff;
       iread = read_array[1] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if((i%8) == 7) fprintf(outf,"\n");
        }
        fprintf(outf,"\n");
//        if((i%8) != 7) fprintf(outf,"\n");
       }
//       fprintf(outf,"\n");

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" ---- frame header ---- \n");
        printf(" event number %d \n", (read_array1[5] & 0xffff));
        printf(" clock number %d \n", (read_array1[6] & 0xffff));
        printf(" ---- packet header ---- \n");
        printf(" event number = %d \n", (read_array1[0] & 0xffff));
        printf(" clock number = %d \n", ((read_array1[0] >>16) & 0xffff));
        printf(" packet word cout = %x %d \n", read_array1[7], read_array1[7]);
/*
        printf(" XMIT header word 1 = %x \n", read_array1[7]);
        printf(" XMIT header word 2 = %x \n", read_array1[8]);
        printf(" XMIT header word 3 = %x \n", read_array1[9]);
        printf(" XMIT header word 4 = %x \n", read_array1[10]);
        printf(" XMIT header word 5 = %x \n", read_array1[11]);

        printf(" XMIT event number %x \n",  (read_array1[7] & 0xffff));
        printf(" XMIT clock number %x \n",  (read_array1[11] & 0xffff));

*/

        printf(" XMIT header word 1 = %x \n", read_array1[13]);
        printf(" XMIT header word 2 = %x \n", read_array1[14]);
        printf(" XMIT header word 3 = %x \n", read_array1[15]);
        printf(" XMIT header word 4 = %x \n", read_array1[16]);
        printf(" XMIT header word 5 = %x \n", read_array1[17]);

        printf(" XMIT event number %x \n",  (read_array1[13] & 0xffff));
        printf(" XMIT clock number %x \n",  (read_array1[17] & 0xffff));


/*

        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
*/
//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
//       iparity =0;
        module_word = 4+ 2+ 64*((12/2) +1);
        packet_word = 7;
        frame_word = 6;
        xmit_word = 5;
       for (ic=0; ic< nmod; ic++ ) {

        ioffset = frame_word + packet_word + xmit_word + module_word*ic;
        iparity = 0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[1+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[2+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[3+ioffset] & 0xffff));

        ig_ch =0;
        ig_smpl =0;
        ig_lst = 0;

        for (ig=0; ig<1000000; ig++) {
         ig_i = 4+ ioffset+ig;
//         printf(" data array %d, %x \n", ig_i, read_array1[ig_i]);
//         scanf("%d", &ia);
         ig_h = (read_array1[ig_i] &  0xf0000000) >>28 ;
         if(ig_h == 0x3){
           adc_data[ig_ch][ig_smpl] = (read_array1[ig_i]>>14) & 0x3fff;
           ig_smpl = ig_smpl+1;
           adc_data[ig_ch][ig_smpl] = read_array1[ig_i] & 0x3fff;
           ig_smpl = ig_smpl+1;
         }
         if(ig_h == 0x1) {
           adc_ch[ig_ch] = read_array1[ig_i] & 0xffff;
//           printf(" channel count = %d\n", adc_ch[ig_ch]);
           ig_ch = ig_ch+1;
           ig_smpl = 0;
         }
         if(ig_h == 2) ig_lst = ig_lst+1;
         if(ig_lst == 2) break;
        }

         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
           printf(" %4x", adc_data[is][k]);
          }
          printf("     %4d", adc_ch[is]);
          printf("\n");
         }
         scanf("%d", &i );
/*
        if(iwrite !=1) printf(" fem data word = %x \n", (read_array1[4+ioffset]);
        if(iwrite !=1) printf(" data = %x %x\n", ((read_array1[4+ioffset]>>14) & 0x3fff), (read_array1[4+ioffset] & 0x3fff));
        scanf("%d", &i );
*/
/*
        ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
        iparity =0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));

        for (is=0; is<4+(nsample*64); is++) {
         if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
         else {
          u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
          iparity = iparity ^ u32Data;
         }
        }

        ioffset_t = ioffset + (64*nsample+4)+6;   // 4 words header + 5 event header -1 for array started at 0
        i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff);
        if(i != iparity) {
         printf(" event = %d, module %d Partity error....... = %x %x\n", ia, (imod_start+ic), i, iparity);
         if(iwrite != 1) scanf("%d", &i);
        }
        if(iwrite != 1) printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

        if(iwrite != 1) {
         printf(" parity word = %x\n", iparity);
         printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
         scanf("%d", &i );
         for (is=0; is<nsample; is++) {
          for (k=0; k<32; k++) {
           adc_data[k*2][is] = read_array1[11+ioffset+((k*nsample+is)*2)] & 0xffff;
           adc_data[(k*2)+1][is] = read_array1[10+ioffset+((k*nsample+is)*2)] & 0xffff;
          }
         }
         for (is=0; is<64; is++) {
          printf(" channel %d ", is);
          for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
          printf("\n");
         }
         scanf("%d", &i );

        }
*/
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
          if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }

        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) printf(" write evennt = %d \n", ia);
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;
     

     case 31:
      printf(" eprom test \n");
      printf(" enter module address \n");
      scanf("%d", &imod);
      px = &buf_send;
      py = &read_array;
//     imod =18;  /* controller module */
/** initialize **/
      buf_send[0]=0x0;
      buf_send[1]=0x0;
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      printf(" controller init done \n");
      
      
           printf(" type 1 for eprom testimg routine -- reset \n");
//     scanf("%d", &ik);
//
      ichip = sp_xmit_sub ;   // controller data go to slow control section
//
//    reset eprom
//
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_reset_p + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      printf(" enter operation type \n");
      printf("    1 for bulk erase \n");
      printf("    2 for program EPROM \n");
      scanf("%d", &itest);
      switch (itest){

      case 1:
       printf(" type 1 for eprom testimg routine -- bulk erase \n");
       scanf("%d", &ik);
//
//    read eprom id
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_bulk_erase_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       printf(" wait for 100 sec \n");
       sleep(100);
       printf(" bulk erase done \n");
       break;
//
//
      case 2:
       printf(" type 1 for eprom testimg routine -- write RPD file to the EPROM \n");
       scanf("%d", &ik);
       ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
//
//
//
//    reset eprom   - reset address
//
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_reset_p + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
//
       printf(" reset done type 1 to continue \n");
       scanf("%d", &ik);
       is=0;
       inpf = fopen("/home/chi/xmit.rpd","r");
       count = 0;
       counta =0;
       addr_w =0;
       while (fread(&charchannel,sizeof(char),1,inpf)==1) {
        carray[counta] = charchannel;
        count++;
        counta++;
        if((count%1000) ==0) printf(" write data to address %d address %x,lower %x, upper %x\n", count, addr_w, (addr_w & 0xffff),((addr_w>>16) & 0xffff));
        if(counta == 256) {
         ichip = sp_xmit_sub ;   // controller data go to slow control section
//
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + ((addr_w & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//          usleep(1);
//       printf(" add low\n");
//       scanf("%d", &ik);
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + (((addr_w>>16) & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
///
//         printf(" set address %x \n", addr_w);
//         scanf("%d", &ik);

//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata;

         for (ia=0; ia< counta; ia++) {
          ik=0;
          ik= ((carray[ia] & 0x80) >>7) + ((carray[ia] & 0x40) >>5) + ((carray[ia] & 0x20) >>3);
          ik = ik + ((carray[ia] & 0x10) >>1) + ((carray[ia] & 0x8) <<1) + ((carray[ia] & 0x4) <<3);
          ik = ik + ((carray[ia] & 0x2) <<5) + ((carray[ia] & 0x1) <<7);
          write_eprom_array[ia] = carray[ia];
          if((ia%2) ==0) {
           ij= ia/2;
           buf_send[ij]= buf_send[ij] + (ik<< 16);
//           buf_send[ij]= buf_send[ij] + (carray[ia]<< 16);
          }
          else buf_send[ij+1] = ik;

//          if((ij%8 == 0) & (ia%2 ==0)) printf("%4d", ij);
//          if((ia%2) == 0) printf ("%8x", buf_send[ij]);
//          if((((ij+1)%8) == 0) & (ia%2 ==0)) printf("\n");
         }
//         printf ("%8x\n", buf_send[ij]);  // last data word
//         printf(" type 1 to send the data packet \n");
//         scanf("%d", &ik);

         i= 1;
         k= 129;
//         printf(" type 1 to send the write packet \n");
//         scanf("%d", &ik);
         i = pcie_send_1(hDev, i, k, px);
//
//       slow control clock rate is 15 MHz.
//       only use half of 16 bits.
//       16 Mhz per bytes
//       66ns * 256 *2  = 33 us;
//       wait for 1.5 time longer

         usleep(50);

//         printf(" type 1 to send the write pulse \n");
//         scanf("%d", &ik);

//       printf(" add low\n");
//       scanf("%d", &ik);

//
//

//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_w_pulse + (ik<<16);

         i= 1;
         k= 1;
//         printf(" type 1 to start the write \n");
//         scanf("%d", &ik);

         i = pcie_send_1(hDev, i, k, px);

//         usleep(1000);
//
//
         usleep(10000);
/*
         i= eprom_readback(hDev,imod,0,py);
         k=0;
         if(is <= 20) printf(" status readback %x \n", i);
         while ((i & 0x1000000) !=0)  {
          k=k+1;
          usleep(1);
          i= eprom_readback(hDev,imod,0,py);
          if(k>=2) printf(" status readback %x \n", i);
         }
         if(is <= 10) printf(" wait period %d \n",k);
*/
         counta =0;
         is=is+1;

//
//      readback routine
//
         if(is == 0) {
/*
         for (ia=0; ia< 256; ia++ ) {
//

          ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
          buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + (((ia+addr_w) & 0xffff)<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
//       printf(" add low\n");
//       scanf("%d", &ik);
//
          buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + ((((ia+addr_w)>>16) & 0xffff)<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
//       printf(" add low\n");
//          scanf("%d", &ik);
          usleep(10);
          buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_pulse + (0<<16) ;
          i= 1;
          k= 1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
//       printf(" read\n");
//          scanf("%d", &ik);
//
//
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
          nword = 2;
          ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
          buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
          i=1;
          k=1;
          i = pcie_send_1(hDev, i, k, px);
//
          i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
          ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
          buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
          i=1;
          k=1;
          i = pcie_send_1(hDev, i, k, px);
          usleep(10);
          py = &read_array;
          i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//       printf("module %d address %d receive data word = %x, %x \n", imod, ia, read_array[0], read_array[1]);
//        printf(" address = %x, data = %x \n", ia, (read_array[1] & 0xff));
//          if((ia%16)==0) printf("%7d", ia);
//      printf("%4x",carray[ia]);
          i = ((read_array[1] & 0x1) <<7 |
          (read_array[1] & 0x2) <<5 |
          (read_array[1] & 0x4) <<3 |
          (read_array[1] & 0x8) <<1 |
          (read_array[1] & 0x10) >>1 |
          (read_array[1] & 0x20) >>3 |
          (read_array[1] & 0x40) >>5 |
          (read_array[1] & 0x80) >>7);
//        printf("%4x",(read_array[1] & 0xff));
//          printf("%4x",(i & 0xff));
//          if((ia+1)%16 == 0) printf("\n");
          read_eprom_array[ia] = i;
         }
*/
//
//
//         for (ia=0; ia< 256; ia++) {
//          if( read_eprom_array[ia] != write_eprom_array[ia] ) {
//           printf(" block %d, ia= %d \n", is, ia);
//           printf(" write = %x, read= %x \n", write_eprom_array[ia], read_eprom_array[ia]);
//           scanf("%d", &ik);
//          }
//         }

         }
         ichip = sp_xmit_sub ;   // controller data go to slow control section
         addr_w = addr_w+256;
        }
       }
       if(feof(inpf)) {
        is =0;
        ichip = sp_xmit_sub ;   // controller data go to slow control section
        printf("You have reached the end-of-file word count= %d %d\n", counta, count);
        if(counta != 0) {
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_l + ((addr_w & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//          usleep(1);
         printf(" add %x\n", addr_w);
         printf(" counta = %d\n", counta);
//       scanf("%d", &ik);
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_addr_h + (((addr_w>>16) & 0xffff)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
//
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_wdata;

         for (ia=0; ia< counta; ia++) {
          ik=0;
          ik= ((carray[ia] & 0x80) >>7) + ((carray[ia] & 0x40) >>5) + ((carray[ia] & 0x20) >>3);
          ik = ik + ((carray[ia] & 0x10) >>1) + ((carray[ia] & 0x8) <<1) + ((carray[ia] & 0x4) <<3);
          ik = ik + ((carray[ia] & 0x2) <<5) + ((carray[ia] & 0x1) <<7);
          if((ia%2) ==0) {
           ij= ia/2;
           buf_send[ij]= buf_send[ij] + (ik<< 16);
//           buf_send[ij]= buf_send[ij] + (carray[ia]<< 16);
          }
          else buf_send[ij+1] = ik;

          if((ij%8) == 0) printf("%4d", ij);
          if((ia%2) == 0) printf ("%8x", buf_send[ij]);
          if(((ij+1)%8) == 0) printf("\n");
         }
         printf ("%8x\n", buf_send[ij]);  // last data word
//         printf(" type 1 to send the data packet\n");
//         scanf("%d", &ik);

         i= 1;
         k= (counta/2)+1;
         i = pcie_send_1(hDev, i, k, px);

         usleep(50);

//       printf(" type 1 to send the write pulse");
//       scanf("%d", &ik);

         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_w_pulse + (ik<<16);

         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
//
//
         usleep(10000);
        }
//
       }
       printf(" write is done \n");
      }
       break;

     case 32:
      printf(" MBD level 1 trigger \n");
//
     printf(" trigger module address \n");
     scanf("%d", &ntrig_mod);
     printf(" enter 0 for lower chip and 1 for uooer chip \n");
     scanf("%d", &ntrig_chip);
     printf(" enter fifo delay size \n");
//     scanf("%d", &trig_fifo_delay);
     printf(" enter sync delay step\n");
//     scanf("%d", &sync_step);
     printf(" optical disable mask in hex\n");
//     scanf("%x", &opt_mask);
     printf(" enter trigger threshold\n");
//     scanf("%d", &ntrig_thr);
//
//      printf(" enter module address \n");
//      scanf("%d", &imod);
      imod = ntrig_mod*2 + ntrig_chip;
      px = &buf_send;
      py = &read_array;
//     imod =18;  /* controller module */
/** initialize **/
      buf_send[0]=0x0;
      buf_send[1]=0x0;
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      printf(" controller init done \n");
//
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//   send reset to the controller
//
     printf(" type 1 to send reset \n");
     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
     buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);
//     }
/*
#define  sp_L1_s10_slow_thr         6
#define  sp_L1_s10_slow_reset       7
#define  sp_L1_s10_slow_en0         8
#define  sp_L1_s10_slow_en1         9
#define  sp_L1_s10_slow_test       12
#define  sp_L1_s10_slow_delay      13
#define  sp_L1_s10_slow_phasen     14
#define  sp_L1_s10_slow_rst_p      15
#define  sp_L1_s10_slow_RESET      16
#define  sp_L1_s10_slow_monitor_p  20
#define  sp_L1_s10_slow_ch_dis1    21
#define  sp_L1_s10_slow_ch_dis2    22
*/

     printf(" reset test register \n");
     ichip = 0;
     buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_reset + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);


     ic=0;
     for (ia=0; ia<24; ia++) {     // ia --> fiber
      for (ib=0; ib<16; ib++) {    // ib --> data index
       ic= ic+1;
       mbd_test_data[ia][ib] = ic & 0xff;
      }
     }

     ic=0;
     for (ia=0; ia<16; ia++) {     // ia --> fiber
      index =0;
      for (ib=0; ib<16; ib++) {    // ib --> data index
       ichip = 0;
       ij = (ia <<4) + ib;          // label to indicate which fiber and index
       ic = ic+1;
       if (index ==0) buf_send[0] = buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_en0 + ((ij + (mbd_test_data[ia][ib]<<8))<<16) ;
       else if ((index%2) == 1) {
        buf_send[(index+1)/2] = ((ij) +  (mbd_test_data[ia][ib]<<8));
//        printf(" %d %d %x \n", index, (index+1)/2 , buf_send[(index+1)/2]);
       }
       else if ((index%2) == 0) {
//        printf(" %d %x \n", index , buf_send[(index)/2]);
        buf_send[(index)/2] = buf_send[(index)/2]+(((ij) +  (mbd_test_data[ia][ib]<<8)) <<16);
//        printf(" %d %x \n", index , buf_send[(index)/2]);
       }
       index = index+1;
      }
      printf(" send fake data fiber %d %x %x %x %x\n", ia, buf_send[0], buf_send[1], buf_send[2], buf_send[3]);
//      scanf("%d", &i);
      i= 1;
      k= (16/2)+1;         //nword
      i = pcie_send_1(hDev, i, k, px);
      usleep(100);
     }
//
//
     ic=0;
     index=0;
     for (ia=16; ia<24; ia++) {     // ia --> fiber
      for (ib=0; ib<16; ib++) {    // ib --> data index
       ichip = 0;
       ij = ((ia-16) <<4) + ib;          // label to indicate which fiber and index
       ic = ic+1;
       if (index ==0) buf_send[0] = buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_en1 + ((ij + (mbd_test_data[ia][ib]<<8))<<16) ;
       else if ((index%2) == 1) {
        buf_send[(index+1)/2] = ((ij) +  (mbd_test_data[ia][ib]<<8));
//        printf(" %d %d %x \n", index, (index+1)/2 , buf_send[(index+1)/2]);
       }
       else if ((index%2) == 0) {
//        printf(" %d %x \n", index , buf_send[(index)/2]);
        buf_send[(index)/2] = buf_send[(index)/2]+(((ij) +  (mbd_test_data[ia][ib]<<8)) <<16);
//        printf(" %d %x \n", index , buf_send[(index)/2]);
       }
       index = index+1;
      }
      printf(" send fake data fiber %d %x %x \n", ia, buf_send[0], buf_send[1]);
//      scanf("%d", &i);
      i= 1;
      k= (16/2)+1;         //nword
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
     }
//
//
//
     printf(" reset optical receiver \n");
     ichip = 0;
     buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_RESET + (0x0<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);
//
//   disable optica; port
//
     printf(" reset optical receiver 1-16 \n");
     ichip = 0;
     buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_ch_dis1 + (0xffff <<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);
//
     printf(" reset optical receiver 1-16 \n");
     ichip = 0;
     buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_ch_dis2 + (0xff <<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);
//
//
//
     printf(" set test register enable \n");
     scanf("%d",&i);
     ichip = 0;
     buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_test + (0x1 <<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1000);
     scanf("%d",&i);




//     imod = ntrig_mod*2 + ntrig_chip;  // take care increse address bit by 2
//     i = trigger_board_setup(hDev, imod, trig_fifo_delay, sync_step, opt_mask, ntrig_thr);
#define  sp_L1_s10_slow_mbd_h_read  31
#define  sp_L1_s10_slow_mbd_o_read  32
#define  sp_L1_s10_slow_mbd_data_read  33
#define  sp_L1_s10_slow_mbd_data_sel   29

//       imod = ik+imod_start;
       nword =2;
       py = &read_array;
       ichip =0;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
//       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
//       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
//
//      reset the optical parts 
//
//      this will set enable trigger module --- take over the slow control read back path
//
        printf(" reset trigger module optics \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_RESET + (0x0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);

       printf(" send read command \n");
       scanf("%d", &i);
//       for (ik=0; ik<100000000; ik++) {
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        usleep(10);
        buf_send[0]=(imod<<10)+(ichip<<8)+(sp_L1_s10_slow_mbd_o_read) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        printf(" data word received = %x %x\n", read_array[0], read_array[1]);
//       }

//       break;



     break;
     
    case 33:
     printf(" number of loop \n");
     scanf("%d",&nloop);
     printf(" number per event \n");
     scanf("%d",&nevent);
     printf(" 1st module slot number \n");
     scanf("%d",&imod_start);
     printf(" number of FEM module \n");
     scanf("%d", &nmod);
     printf(" number of sample \n");
     scanf("%d", &nsample);
     printf(" type 1 to use xmit module \n");
     scanf("%d", &isel_xmit);
     if(isel_xmit == 1) {
      printf(" type 1 to use dcm module \n");
      scanf("%d", &isel_dcm);
     }
     icomp=0;
     printf(" type 1 to write data to file \n");
     scanf("%d",&iwrite);
     if(iwrite ==1) {
       printf(" type 1 for data compare \n");
       scanf("%d", &icomp);
       printf(" type 0 to /dev/null \n");
       scanf("%d", &i);
       if(i== 0) outf = fopen("/dev/null","w");
       else outf = fopen("/home/chi/test.dat","w");
     }
//
//
//
     printf(" enter 1 to use pulse \n");
     scanf("%d",&ipulse);
     printf(" enter 1 to use external trigger \n");
     scanf("%d",&iext_trig);
     printf(" enter 1 to use pulse generator module \n");
     scanf("%d", &igen);
     if(igen == 1) {
      printf(" enter number of steps \n");
      scanf("%d", &nstep);
      printf(" event per step \n");
      scanf("%d", &nstep_event);
      printf(" dac value per step \n");
      scanf("%d", &nstep_dac);
      printf(" enter test pattern %x \n");
      scanf("%x", &ipattern);
      printf(" type 1 for fix dac\n");
      scanf("%d", &ifix_dac);
     }
     if(igen == 1 & iwrite == 1) {
      fprintf(outf," %d\n", nstep);
      fprintf(outf," %d\n", nstep_event);
      fprintf(outf," %d\n", nstep_dac);
     }

     if(igen == 1) nevent = nstep * nstep_event;
     if(igen == 1) printf(" event is going to be %d\n", nevent); 


     if((ipulse !=0) | (igen != 0)) {
      printf(" enter L1 delay number \n");
      scanf("%d", &l1_delay);
     }
     
     printf(" enter 1 to load ADC test data memory\n");
     scanf("%d", &itest_ram);

     px = &buf_send;
     py = &read_array;
//     imod =6;
     imod_xmit = imod_start+nmod;
     ichip=6;
//     nsample = 12;
     if(isel_dcm ==1) {
      imod_dcm=11;
      printf(" boot 5th FPGA \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,1);
      printf(" type 1 to continue \n");
      scanf("%d", &i);
      printf(" boot FPGA 1-4 \n");
      i=dcm2_fpga_boot(hDev2,imod_dcm,2);
      printf(" type 1 to continue \n");
      scanf("%d",&i);

      ioffset=4;
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);  /* don't care about chip number **/
/* set run =0 -- clear everything */
      buf_send[0]=iadd+dcm2_run_off;
      ik=pcie_send(hDev2,1,1,px);
     }

//    for (j=0; j<nloop; j++) {
//       if(inew == 1) {
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//       }
     ifr=0;

/** initialize **/
/*      if(j ==0) { */
     buf_send[0]=0x0;
     buf_send[1]=0x0;
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);
//
//
//

       printf(" set the controller to offline state before reset can be applied \n");
//
     imod=0;
     ichip=0;
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_cntrl_offline)+(0x1<<16); //enable offline run on
     i=1;
     k=1;
     i = pcie_send_1(hDev, i, k, px);

//
//
//
     if(isel_xmit == 1) {
      ichip = sp_xmit_sub;

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxanalogreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxdigitalreset + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

//      for (ia=0; ia< 1000000; ia++) {
       printf(" type 1 to do the byte ordering \n");
       scanf("%d",&is);
       buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_rxbytord + (0<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
//      }

      buf_send[0]=(imod_xmit <<11)+ (ichip << 8) + sp_xmit_init + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);

      printf(" xmit reset complete type 1 to continue \n");
      scanf("%d",&is);



     }
//
//   send init to the controller
//
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     buf_send[0]= (0x2<<8)+sp_cntrl_timing+ (sp_cntrl_init<<16);
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
//   send reset to the controller
//
//     printf(" type 1 to send reset \n");
//     scanf("%d",&is);

//     for (is =0; is<1000000000; is++) {
      buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ (sp_cntrl_reset<<16);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1000);
//     }

//
//   after initial the xmit and controller -- initialize the DCM II
//
     if(isel_dcm == 1) {

      nmask = 0x1; /*turn non all channel */
      for (i=1; i<5; i++) {
        ichip=i;
        iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to online mode */
        buf_send[0]=iadd+dcm2_online+(0x1<<16);
        ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
        buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
        ik=pcie_send(hDev2,1,1,px);
      }
/** work on 5th FPGA **/
      ichip=5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set module to offline mode */
      buf_send[0]=iadd+dcm2_online+(0x0<<16);
      ik=pcie_send(hDev2,1,1,px);
/* set mask on for all channel*/
      buf_send[0]=iadd+dcm2_setmask+((nmask &0xff) <<16);
      ik=pcie_send(hDev2,1,1,px);

/* set dcm first module */
      buf_send[0]=iadd+dcm2_5_firstdcm+(0x1<<16);   // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
/* set last module*/
      buf_send[0]=iadd+dcm2_5_lastdcm+(0x1<<16);    // bit 0 =1 on
      ik=pcie_send(hDev2,1,1,px);
//
//
      ichip =5;
      iadd=(imod_dcm<<11)+(ichip<<8);
/* set run =1 */
      buf_send[0]=iadd+dcm2_run_on;
      ik=pcie_send(hDev2,1,1,px);
     }

//
//   set sample size  -- to 10
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is)
     for (ik =0; ik<nmod; ik++) {

//#define  sp_adc_calib_dac         100
//#define  sp_adc_calib_ch          101
//#define  sp_adc_calib_write       102
//#define  sp_adc_calib_send        103
//#define  sp_adc_trg_tx_dreset      22
//#define  sp_adc_trg_tx_areset      23
      if(igen ==1) {
//
// remove analog reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_areset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
// remove digital reset
//
        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trg_tx_dreset + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" trigger transmitter resets removed \n");
        scanf("%d",&i);


        for (is=0; is< 16; is++) {
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((0xe00)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value \n", is);
//         scanf("%d",&i);

        }
//
//
//



/*        imod = ik+imod_start;
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);

        printf(" loading channel %d, dac value \n", is);
        scanf("%d",&i);
*/
      }



      imod = ik+imod_start;
      ichip = sp_adc_slowcntl_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_evt_sample + ((nsample-1)<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set L1 delay  -- to 100
//
      printf(" set L1 delay module %d\n", imod);
//      printf(" type 1 to set L1 delay \n");
//      scanf("%d",&is);
      if((ipulse != 0) | (igen !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (l1_delay<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l1_delay + (0x10<<16) ;
      printf(" buf_send = %x\n", buf_send[0]);
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2link off
//
//     printf(" type 1 to send sample size");
//    scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_link + (0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set dat2control  on
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(isel_xmit == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_rd_cntrl + (1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set pulse trigger off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(ipulse != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set calibarion trigger on/off
//
//     printf(" type 1 to send sample size");
//     scanf("%d",&is);
      if(igen != 0) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x1<<16) ;
      else  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_caltrig + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set test trigger off
//
      printf(" type 1 to set test ram state  \n");
      scanf("%d",&is);
//
//   verilog code issue I don't understand so I flip the test pulse bit
//

//      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x1<<16) ;
//      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_test_trig + (0x0<<16) ;
      if(itest_ram == 1) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x1<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//
//   set select L1 trigger on
//
      printf(" type 1 to select L1 trigger \n");
      scanf("%d",&is);
//      if((ipulse != 0) | (igen  !=0) | (itest_ram != 0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      if((ipulse != 0) | (igen  !=0)) buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x0<<16) ;
      else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_l1 + (0x1<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
//      printf(" set up complete type 1 to continue \n");
//      scanf("%d",&is);
//
//    if select xmit module and not last module tunr off link_rxoff
//
      if(isel_xmit == 1) {
       if(imod != imod_start) {
        ichip = sp_adc_slowcntl_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_sel_link_rxoff + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        printf(" rx_off called , module %d\n", imod);
       }
      }
      printf(" call adc setup  module %d\n", imod);
      i = adc_setup(hDev,imod, 1);
      scanf("%d",&is);
      if(itest_ram == 1) {
       printf(" call adc setup  module %d\n", imod);
       scanf("%d",&is);
       i = adc_testram_load(hDev,imod, 400);
      }
//sp_adc_sel_link_rxoff



     }
//

//
//sp_xmit_lastmod
     if(isel_xmit == 1) {
      imod = imod_xmit;
      ichip = sp_xmit_sub;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_xmit_lastmod + (imod_start<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(10);
      printf(" set last module %d\n", imod_start);
     }




     for (j=0; j<nloop; j++) {
//
//
//   send L1 trigger to the controller
//
     for (ia=0; ia<nevent; ia++) {
      if(iwrite != 1) {
       printf(" type 1 to send L1 trigger \n");
       scanf("%d",&is);
      }

     for (ik =0; ik<nmod; ik++) {
       imod = ik+imod_start;
       nword =3;
       py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
//
       i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       py = &read_array;
       i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iwrite != 1) {
        printf("module %d receive data word = %x, %x, %x\n", imod, read_array[0], read_array[1], read_array[2]);
        printf (" header word = %x \n" ,((read_array[0] & 0xffff) >> 8));
        printf (" module address = %d \n" ,(read_array[0] & 0x1f));
        printf (" upper adc rx pll locked %d\n", ((read_array[0] >>31) & 0x1));
        printf (" upper adc rx dpa locked %d\n", ((read_array[0] >>30) & 0x1));
        printf (" upper adc rx aligment %d\n", ((read_array[0] >>29) & 0x1));
        printf (" upper adc rx data valid %d\n", ((read_array[0] >>28) & 0x1));
        printf (" lower adc rx pll locked %d\n", ((read_array[0] >>27) & 0x1));
        printf (" lower adc rx dpa locked %d\n", ((read_array[0] >>26) & 0x1));
        printf (" lower adc rx aligment %d\n", ((read_array[0] >>25) & 0x1));
        printf (" lower adc rx data valid %d\n", ((read_array[0] >>24) & 0x1));
        printf (" link pll locked %d\n", ((read_array[0] >>23) & 0x1));
        printf (" clock pll locked %d\n", ((read_array[0] >>22) & 0x1));
        printf (" trigger bufer empty %d\n", ((read_array[0] >>21) & 0x1));
        printf (" firmware version %d\n", ((read_array[2]>>8) & 0xff));
        printf (" firmware sub version %d\n", ((read_array[2]) & 0xff));
        printf (" firmware version header %x\n", ((read_array[2])>>16));
       }
      }



//      for (ijk=0; ijk<1000000000; ijk++) {
      if(ipulse != 0) buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_pulse)<<16);
      else if (igen != 0) {
         idac_shaper = (ia/nstep_event);
         if(ifix_dac != 1) idac_shaper = idac_shaper *nstep_dac;    //set up the dac value
         else idac_shaper = 4000;

         imod = imod_start;
         for (is=0; is< 16; is++) {
         ic= ipattern>> is;
         if((ic & 0x1) != 1) idac_shaper_load =0;
         else idac_shaper_load = idac_shaper;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_ch + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_dac + ((idac_shaper_load)<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_send + (is<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);

/*
         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         imod = ik+imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
*/
         printf(" loading channel %d, dac value %d , ia= %d, ic= %d \n", is, idac_shaper_load, ia,ic );
//         scanf("%d",&i);

        }

         imod = imod_start;
         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x1<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(1);

         ichip = sp_adc_slowcntl_sub;
         buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_calib_gate + (0x0<<16) ;
         i= 1;
         k= 1;
         i = pcie_send_1(hDev, i, k, px);
         usleep(10);
      }
//      else if (itest_ram == 1) {
//       printf(" send test pulse trigger \n");
//       scanf("%d", &i);
//       ichip = sp_adc_slowcntl_sub;
//       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_test_pulse + (0x0<<16) ;
//      }
//      else if ((iext_trig != 1) & (igen != 1) & (itest_ram != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      else if ((iext_trig != 1) & (igen != 1) )buf_send[0]= (0x2<<8)+ sp_cntrl_timing+ ((sp_cntrl_l1)<<16);
      i= 1;
      k= 1;
      if((iext_trig != 1) & (igen != 1)) i = pcie_send_1(hDev, i, k, px);
      usleep(100);
//      }
      if(iwrite != 1) {
       if(iext_trig != 1) {
        printf(" trigger send \n");
        scanf("%d",&is);
       }
      }

      if(iext_trig == 1) {
       ik =0;
       while (ik != 1) {
        imod = imod_start;
        nword =1;
        py = &read_array;
//
//     command no-op to enable module output enable
// otherwise the LVDS input at controller will be floating high
//
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
//
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
        buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
        if (((read_array[0] >>21) & 0x1) == 0) {
         printf(" trigger received \n");
         ik=1;
        }
       }
      }


//
//
//
      if(isel_dcm == 1) {
       nread = 3;
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       ichip =5;
       iadd = (imod_dcm<<11)+ (ichip<<8);
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(100);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       if(iwrite != 1) {
        printf(" header 1 = %x\n", read_array[0]);
        printf(" header 2 = %x\n", read_array[1]);
        printf(" header 3 = %x\n", read_array[2]);
        printf(" header word = %x\n", (read_array[0]& 0xffff));
        printf(" event number = %x\n", (((read_array[0])>>16)+((read_array[1] & 0xffff)<<16)));
        printf(" word count = %x %d\n", iread, iread);
        printf(" trail word = %x\n", ((read_array[2] >>16) & 0xffff));
        scanf("%d", &i );
       }
//
       iread = read_array[2] & 0xffff;
       nread = iread+1;
       kword = (nread/2);
       if(nread%2 !=0) kword = kword+1;
//
       i = pcie_rec(hDev2,0,1,nread,iprint,py);     // read out 2 32 bits words
       buf_send[0]=(imod_dcm <<11)+ (ichip << 8) + dcm2_5_readdata + ((nread-2)<< 16);  /* number word to read- (header+trailer)*/
       buf_send[1]=0x5555aaaa;                                                      // -1 for the counter
       ik = pcie_send(hDev2, 1, 1, px);  //** for dcm2 status read send 2 words **//
       usleep(10);
       i = pcie_rec(hDev2,0,2,nread,iprint,py);
       for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
        u32Data = (read_array[i] & 0xffff0000) + (read_array[i+1] &0xffff);
        read_array1[i] = u32Data;
        if(iwrite != 1) {
         if(i%8 == 0) printf("%3d",i);
         printf(" %9x",u32Data);
         if(i%8 == 7) printf("\n");
        }
       }
       if(iwrite == 1) {
        fprintf(outf,"%d\n", nread);
        for (i=0; i<(nread-1); i++) {
//        u32Data = (idcm_read_array[2*i+1]<<16)+idcm_read_array[2*i+2];
         fprintf(outf," %9x",read_array1[i]);
         if((i%8) == 7) fprintf(outf,"\n");
        }
        fprintf(outf,"\n");
//        if((i%8) != 7) fprintf(outf,"\n");
       }
//       fprintf(outf,"\n");

       if(iwrite != 1) {
        if((i%8) != 7) printf("\n");
        scanf("%d", &i );
        printf(" event number = %d \n", ( read_array1[1] & 0xffff));
        printf(" flag word = %x \n", (read_array1[2] & 0xffff));
        printf(" detector ID = %x \n", (read_array1[3] & 0xffff));
        printf(" module address = %x \n", (read_array1[4] & 0xffff));
        printf(" clock number = %x \n", (read_array1[5] & 0xffff));
//        printf(" FEM header = %x \n", (read_array1[6] & 0xffff));
//        printf(" FEM module address= %x \n", (read_array1[7] & 0xffff));
//        printf(" FEM event number = %d \n", (read_array1[8] & 0xffff));
//        printf(" FEM clock number = %x \n", (read_array1[9] & 0xffff));
       }
//       iparity =0;
       for (ic=0; ic< nmod; ic++ ){
        ioffset = (64*nsample+4+2)*ic;              // 4 words header + 2 word parity
        iparity =0;
        if(iwrite !=1)printf(" FEM header = %x \n", (read_array1[6+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM module address= %x \n", (read_array1[7+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM event number = %d \n", (read_array1[8+ioffset] & 0xffff));
        if(iwrite !=1)printf(" FEM clock number = %x \n", (read_array1[9+ioffset] & 0xffff));
        adc_up_clk[ic] =  read_array1[9+ioffset] & 0xffff;
        adc_up_evt[ic] =  read_array1[8+ioffset] & 0xffff;

        for (is=0; is<4+(nsample*64); is++) {
         if(is%2 == 0) u32Data = (read_array1[is+6+ioffset] & 0xffff) <<16;
         else {
          u32Data = u32Data + (read_array1[is+6+ioffset] & 0xffff);
//         u32Data = u32Data+ ((read_array1[is+6] & 0xffff) <<16);
          iparity = iparity ^ u32Data;
         }
        }
        ioffset_t = ioffset + (64*nsample+4)+6;   // 4 words header + 5 event header -1 for array started at 0
        i= ((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff);
        if(i != iparity) {
         printf(" event = %d, module %d Partity error....... = %x %x\n", ia, (imod_start+ic), i, iparity);
         if(iwrite != 1) scanf("%d", &i);
        }
        if(iwrite != 1) printf(" event = %d, Partity word = %x %x\n", ia, i, iparity);

        if(iwrite != 1) {
         printf(" parity word = %x\n", iparity);
         printf(" packet parity word = %x\n", (((read_array1[ioffset_t] & 0xffff) <<16) +(read_array1[ioffset_t+1] & 0xffff)));
         scanf("%d", &i );
        }
        for (is=0; is<nsample; is++) {
         for (k=0; k<32; k++) {
          adc_data[k*2][is] = read_array1[11+ioffset+((k*nsample+is)*2)] & 0xffff;
          adc_data[(k*2)+1][is] = read_array1[10+ioffset+((k*nsample+is)*2)] & 0xffff;
         }
        }
        for (is=0; is<64; is++) {
         if(iwrite != 1) printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          if(iwrite != 1) printf(" %4x", adc_data[is][k]);
          adc_up[ic][is][k] = adc_data[is][k];
         }
         if(iwrite !=1) printf("\n");
        }
        if(iwrite !=1) scanf("%d", &i );
       }
       if(icomp == 1) {
        error_up=0;
        for (ic=1; ic<nmod; ic++) {
         for (is=0; is<64; is++) {
          for (k=0; k<nsample ; k++) {
           if(adc_up[ic][is][k] != adc_up[0][is][k]) {
             error_up =1;
             printf (" error found  event %d\n", ia);
             scanf("%d", &i);
           }
          }
         }
        }
        if(error_up ==1) {
         printf (" error found  event %d\n", ia);
         scanf("%d", &i);
         for (ic=0; ic<nmod; ic++) {
          printf(" module = %d\n",ic);
          for (is=0; is<64; is++) {
           printf(" channel %d ", is);
           for (k=0; k<nsample; k++) {
            printf(" %4x", adc_up[ic][is][k]);
           }
           printf("\n");
          }
         }
        }
       }
      }


//
//
      else {
       ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
       for (ik =0; ik<nmod; ik++) {
        imod = ik+imod_start;
        iparity =0;

//
        if(iwrite != 1) {
         printf(" type 1 to send the transfer \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_transfer + (0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
//
        nread =2+(64*nsample/2)+1;
        i = pcie_rec_2(hDev,0,1,nread,iprint,py);     // read out 2 32 bits words

        if(iwrite != 1) {
         printf(" type 1 to send the read \n");
         scanf("%d",&is);
        }
        buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_readback_read + (1<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(100);
//
//
        i = pcie_rec_2(hDev,0,2,nread,iprint,py);     // read out 2 32 bits words
        for (is=0; is< nread-1; is++) {
          iparity = iparity ^ read_array[is];
        }

        if (iwrite == 1) {
         fprintf(outf," %x\n", read_array[0]);
         fprintf(outf," %x\n", read_array[1]);
        }
        else {
         printf(" header 1 = %x\n", read_array[0]);
         printf(" header 2 = %x\n", read_array[1]);
        }

        k=0;
        for (is=0; is< (nread-2); is++) {
         if(iwrite == 1) {
          fprintf(outf," %8X", read_array[is+2]);
         }
         else {
          if(is%8 ==0) printf(" %d ", is);
          printf(" %x", read_array[is+2]);
         }
         k=k+1;
         if(iwrite == 1) {
          if((k%8) ==0) fprintf(outf,"\n");
         }
         else {
          if((k%8) ==0) printf("\n");
         }
        }
        if(iwrite == 1) {
          if((is%8) !=0) fprintf(outf,"\n");
        }
        else {
         if((is%8) !=0) printf("\n");
        }

        if (iwrite != 1) printf(" data parity = %x generated parity = %x  \n", read_array[is+1], iparity);
        if(read_array[is+1] !=  iparity) {
         printf(" event = %d, Partity error....... = %x %x\n", ia,read_array[is+1], iparity);
//         scanf("%d", &i);
        }
        if(iwrite == 1) fprintf(outf,"\n");
        else printf("\n");
//        printf(" parity = %x  \n", iparity);

        if(iwrite != 1) {
         printf(" header = %x \n", (read_array[0] & 0xffff));
         printf(" module number = %d \n", ((read_array[0]>> 16) & 0x1f));
         printf(" triggernumber = %x \n", (read_array[1] & 0xffff));
         printf(" beam crossing number = %x \n", ((read_array[1]>> 16) & 0xffff));
         for (is=0; is< nsample; is++ ) {
          for (k=0; k< 32; k++) {
//        adc_data[(k*2)][is] = read_array[(is*32)+k+2] & 0xffff;
//        adc_data[((k*2)+1)][is] = (read_array[(is*32)+k+2] >>16) & 0xffff;
           adc_data[(k*2)][is] = read_array[(k*nsample)+is+2] & 0xffff;
           adc_data[((k*2)+1)][is] = (read_array[(k*nsample)+is+2] >>16) & 0xffff;
          }
         }


         for (is=0; is<64; is++) {
         printf(" channel %d ", is);
         for (k=0; k<nsample; k++) {
          printf(" %4x", adc_data[is][k]);
         }
         printf("\n");
         }
        }


        if(iwrite != 1) {
         printf(" type 1 to continue \n");
         scanf("%d",&is);
        }
       }
      }
//     fclose(inputf);


//#define  sp_adc_readback_sub        4
//#define  sp_adc_readback_transfer   1
//#define  sp_adc_readback_read       2
//#define  sp_adc_readback_status     3

//
      if(iwrite ==1) {
       if((ia%10) == 0) {
//         printf(" write evennt = %d \n", ia);
         if(icomp == 1) printf(" write event = %d %x %x %x %x \n", ia, adc_up[0][0][0],adc_up[1][0][0],adc_up[2][0][0],adc_up[3][0][0]);
         else printf(" write evennt = %d \n", ia);
       }
      }
     }
      if(iwrite ==1 ) {
       printf(" event looop finished, type 1 to continue \n");
       fclose(outf);
       printf("close file \n");
       scanf("%d",&is);
      }
     }
     break;



    }



}





/* -----------------------------------------------
    Read/write memory and I/O addresses -- TEST
   ----------------------------------------------- */
/* Read/write memory or I/O space address menu options */
static void Menujsebii_test(WDC_DEVICE_HANDLE hDev)
{
/*  pci express bar setting
bar 0,1 is for transceiver 1
bar 2,3 is for command
bar 4,5 is for transceiver 2
*/

#include "wdc_defs.h"

#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/
/** GKQ: are these specific to a pcie? **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

  /** bunch of variable initializations **/
  static DWORD dwAddrSpace;

  static UINT32 u32Data, u32Data_send;
  static unsigned long long u64Data;
  static DWORD dwOffset;
  static unsigned long long buff[10000];
/*    PVOID buff_p; */
  static UINT32 *buffp_send;
  static UINT32 *buffp_rec;
  static UINT64 *buffp_rec64;
/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
  static UINT32 i,j,k,ifr,jk,nwrite,iprint,nread;
  int newcmd,itr,tr_bar,icheck,istop,iloop,t_cs_reg,r_cs_reg;
  int idone,iseq,incomp,dma_tr,isweep,nsize_sw,irand,nwrite_max,nwrite_min;
  int kwrite;
  UINT32 write_array[100000],read_array[100000];
  int n_written;
  DWORD dwDMABufSize;
  PVOID pbuf_send;
  PVOID pbuf_rec;
  WD_DMA *pDma_send;
  WD_DMA *pDma_rec;
  DWORD dwStatus;
  DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
  DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE;

  iprint =1;
  ifr =0;
  istop =0;
  icheck =1;
  
    /** main menu (options) of routine **/
  printf(" PCIe board testing routing \n");
  printf(" type 1 to use random number \n");
  scanf("%d",&irand);
  printf(" which transceiver to test (1,2 ) \n");
  scanf("%d", &itr);
  printf(" input testing method \n");
  printf(" 1) for slave loop back test \n");
  printf(" 2) DMA loop back test \n");
  //  printf(" 3) combine optical DMA test \n");
  printf(" 3) write-to-file test \n");
  scanf("%d",&newcmd);
  switch(newcmd) {

  case 1:
    if(icheck == 1) printf(" data checking on \n");
    printf("enter number words per packet, -1 for sequence test \n");
    scanf("%d",&kwrite);
    if(kwrite == -1) {
      printf("enter min number of word \n");
      scanf("%d",&nwrite_min);
      printf("enter max number of word \n");
      scanf("%d",&nwrite_max);
      nwrite=nwrite_min;
    }
    else nwrite = kwrite;
    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
    }
    
/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


      /** begin timer **/
    struct timeval starttest1, endtest1;
    gettimeofday(&starttest1,NULL);
    long mytime1, seconds1, useconds1;
    seconds1 = starttest1.tv_sec;
    useconds1 = starttest1.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds1,useconds1);
      //get a fresh timestamp
    gettimeofday(&starttest1,NULL);


    for (j=0; j<iloop; j++) {
	//GSK
	//       printf("started loop = %d \n",j);
/* set tx mode register */
      u32Data = 0xf0000fff;
      dwOffset = tx_md_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** initialize the tranmission ***/
      u32Data = cs_init;
      dwOffset = t_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = t_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");

/** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if (iprint ==1 && j < 2) printf(" set up receiver \n");

       //GSK
       //       if(icheck == 1) {
       //         dwAddrSpace =cs_bar;
       //         u64Data =0;
       //         dwOffset = t_cs_reg;
       //         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //         if(iprint==1 && j < 2) {
       //          u32Data=u64Data;
       //          printf (" transmitter status before send  = %8X \n",u32Data);
       //          u32Data=u64Data>>32;
       //          printf (" receiver status before send  = %8X \n",u32Data);
       //         }
       //       }

       //GSK
      u32Data = 0x22211; 

      for (i=0; i< nwrite; i++) {
        dwAddrSpace = tr_bar;
	//GSK
	//        if(irand == 1) u32Data=rand();
	//        else u32Data = i;
/*        if(i%2 == 0) u32Data =~i;   */
        dwOffset = 0;
	//GSK
	//        write_array[i]=u32Data;
        WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      }

       //GSK
       //       if(icheck ==1 ) {
       //        dwAddrSpace =cs_bar;
       //        u64Data =0;
       //        dwOffset = t_cs_reg;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        if(iprint==1 && j < 2) {
       //         u32Data=u64Data;
       //         printf (" transmitter status after send  = %8X \n",u32Data);
       //         u32Data=u64Data>>32;
       //         printf (" receiver status after send  = %8X \n",u32Data);
       //        }
       //       }
       //       nread = nwrite/2;
       //       if(nwrite%2 !=0) nread= nwrite/2 +1;
       //       for (i=0; i< nread; i++) {
       //        dwAddrSpace = tr_bar;
       //        u32Data = 0;
       //        dwOffset = 0;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        read_array[i*2] = u64Data;
       //        read_array[i*2+1] =u64Data>>32;
       //       }
       //       if(icheck == 1) {
       //        dwAddrSpace =cs_bar;
       //        u64Data =0;
       //        dwOffset = t_cs_reg;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        if(iprint==1 && j < 2) {
       //         u32Data=u64Data;
       //         printf (" transmitter status after read  = %8X \n",u32Data);
       //         u32Data=u64Data>>32;
       //         printf (" receiver status after read  = %8X \n",u32Data);
       //        }
       //        for (i=0; i< nwrite; i++) {
       //           if(iprint == 1 && j < 2) {
       //             if(i%8 ==0) printf("%d",i);
       //             printf("%9X",read_array[i]);
       //             if((i+1)%8 ==0) printf("\n");
       //           }
       //           if(read_array[i] != write_array[i]) printf("data mismatch, loop = %d word =%d read= %9X write = %9X\n",j,i,read_array[i],write_array[i]);
       //        }
       //        if((iprint ==1) && (nwrite%8 !=0) && j < 2) printf("\n");
       //       }
       //       if(j%100 ==0) printf(" loop = %d, nwrite= %d \n",j, nwrite);
       //       if(kwrite == -1) {
       //         nwrite =nwrite+1;
       //         if(nwrite > nwrite_max) nwrite =nwrite_min;
       //       }
    }

     /** end timer **/
    gettimeofday(&endtest1,NULL);
    seconds1 = endtest1.tv_sec;
    useconds1 = endtest1.tv_usec;
    
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds1,useconds1);

    seconds1 = endtest1.tv_sec - starttest1.tv_sec;
    useconds1 = endtest1.tv_usec - starttest1.tv_usec;
    
    mytime1 = seconds1*1000000. + useconds1*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime1);

    break;

  case 2:
    icheck=0;
    iprint=0;
    if(icheck == 1) printf(" data checking on \n");
    printf(" enter number of 32bits word send (< 20000), -1 for sequence test\n");
    scanf("%d",&kwrite);
    if(kwrite == -1) {
      printf("enter min number of word \n");
      scanf("%d",&nwrite_min);
      printf("enter max number of word \n");
      scanf("%d",&nwrite_max);
      nwrite=nwrite_min;
    }
    else nwrite = kwrite;

    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    printf(" DMA sequence -> 1 for DMA read after DMA write \n");
    printf("                 2 for Open DMA read and slave write \n");
    scanf("%d",&iseq);
    printf(" type 1 for incomplete DMA test \n");
    scanf("%d",&incomp);
    

/*** allocate the DMA buffer for send and receive **/
    dwDMABufSize = 80000;
    if(ifr ==0) {
      ifr=1;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
	printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
	printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
    }
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    dma_tr = dma_tr1;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
      dma_tr = dma_tr2;
    }

/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       /* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


       
       //GSK
       //rand() generation outside loop, for speed test

    buffp_send = pbuf_send;
    buffp_rec = pbuf_rec;
    //	 printf("%llX\n",buffp_send);
    //this is not actually necessary:
    int ig;
    for (ig=0; ig<nwrite; ig++) {
      if(irand == 1) *buffp_send++=rand();
      else *buffp_send++= ig;
      *buffp_rec++ =0x0;
    }
    //    }
    printf("\nGenerated data (words) for loop-back test\n");
    for (i=0; i<nwrite; i++) {
      k = i%8;
      if( k ==0) printf(" %3d", i);
      u32Data = *buffp_send++;
      printf(" %llX",u32Data);
      if(k == 7 ) printf("\n");
    }
    printf("\n");
    for (i=0; i<nwrite; i++) {
      k = i%8;
      if( k ==0) printf(" %3d", i);
      u32Data = *buffp_rec++;
      printf(" %llX",u32Data);
      if(k == 7 ) printf("\n");
    }


      /** begin timer **/
    struct timeval starttest, endtest;
    gettimeofday(&starttest,NULL);
    long mytime, seconds, useconds;
    seconds = starttest.tv_sec;
    useconds = starttest.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds,useconds);
      //get a fresh timestamp
    gettimeofday(&starttest,NULL);


    for (j=0; j<iloop; j++) {
/* set tx mode register */
      u32Data = 0xf0000008;
      dwOffset = tx_md_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** initialize the tranmission ***/
      u32Data = cs_init;
      dwOffset = t_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = t_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");
/** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      //GSK
       //       if(incomp ==1) u32Data = cs_start+nwrite*4+16; /* set up 4 less words to receive */
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up receiver \n");
       //       if(icheck == 1) {
       //         dwAddrSpace =cs_bar;
       //         u64Data =0;
       //         dwOffset = t_cs_reg;
       //         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //	 if(iprint==1 && j < 2) {
       //	   u32Data=u64Data;
       //	   printf (" transmitter status before send  = %8X \n",u32Data);
       //	   u32Data=u64Data>>32;
       //	   printf (" receiver status before send  = %8X \n",u32Data);
       //	 }
       //       }

      buffp_send = pbuf_send;
      buffp_rec = pbuf_rec;

       //GSK
       //do rand() generation outside the loop, and fill array(s) ahead of time
       //       for (i=0; i<nwrite+100; i++) {
       //	 if(irand == 1) *buffp_send++=rand();
       //	 else *buffp_send++= i;
       //	 *buffp_rec++ =0;
       //       }

/*
       buffp_rec = pbuf_rec;
       buffp_send = pbuf_send;

       for (i=0; i<nwrite; i++) {
	  k = i%8;
	  if(iprint ==1 && k ==0) printf(" %3d", i);
	  u32Data = *buffp_send++;
          if(iprint==1) printf(" %llX",u32Data);
	  if(k == 7 && iprint == 1) printf("\n");
       }
*/

//GSK iseq==1 by definition for this test
//       if(iseq == 1) {
/* set up transmitter DMA starting address */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      u32Data = nwrite*4;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

	/* synch cache */
      WDC_DMASyncCpu(pDma_send);

/* write this will start DMA */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_cntrl;
      u32Data = dma_tr+dma_3dw_trans;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/***    check to see if DMA is done or not **/
      idone =0;
      for (i=0; i<200; i++) {;
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = cs_dma_cntrl;
	WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	  //GSK
	  //	  if(iprint ==1 && j < 2) printf(" send DMA status word %d %X \n", i, u32Data);
	if((u32Data & dma_in_progress) == 0) {
	    //GSK
	    //	    if(iprint == 1 && j < 2) printf(" send DMA complete %d \n", i);
	  idone =1;
	}
	if((u32Data & dma_in_progress) == 0) break;
      }
      if(idone == 0) {
	  //gsk
	  //	  printf(" sending dma is not finished \n");
	  //	  printf(" send DMA status word %d %X \n", i, u32Data);
	break;
      }
	//GSK
	//        if(icheck == 1) {
	//         dwAddrSpace =cs_bar;
	//         u64Data =0;
	//         dwOffset = t_cs_reg;
	//         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	//	 if(iprint==1 && j < 2) {
	//	   u32Data=u64Data;
	//	   printf (" transmitter status after send  = %8X \n",u32Data);
	//	   u32Data=u64Data>>32;
	//	   printf (" receiver status after send  = %8X \n",u32Data);
	//	 }
	//        }
	//GSK end if iseq==1
	//       }

 	/* synch DMA i/O cache **/
      WDC_DMASyncIo(pDma_send);

	//GSK iseq==1 for this test
	//       if (iseq != 1) {
	///** now write data to the transmiiter */
//        buffp_send = pbuf_send;
//        for (i=0; i< nwrite; i++) {
//         dwAddrSpace = tr_bar;
//         u32Data = *buffp_send++;
//         dwOffset = 0;
//         WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//        }
//       }


 /** set up the receiver DMA and first  **/

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      u32Data = nwrite*4;
      if(incomp ==1) u32Data = cs_start+nwrite*4+16; /* set up 4 more words to receive */
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      u32Data = dma_tr+dma_3dw_rec;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

	/* synch cache */
      WDC_DMASyncCpu(pDma_rec);



/***    check to see if DMA is done or not **/
      idone =0;
      for (i=0; i<200; i++) {;
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = cs_dma_cntrl;
	WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	//GSK
	//	  if(iprint ==1 && j < 2) printf(" receive DMA status word %d %X \n", i, u32Data);
	if((u32Data & dma_in_progress) == 0) {
	  idone =1;
	  //GSK
	  //	    if(iprint == 1 && j < 2) printf(" receive DMA complete %d \n", i);
	}
	if((u32Data & dma_in_progress) == 0) break;
      }
      /* synch DMA i/O cache **/

      WDC_DMASyncIo(pDma_rec);

      if(idone == 0){
	 //gsk
	 //	 printf(" DMA is not done, %d, iloop = %d, nwrite= %d\n",i, j, nwrite);
	 //         if(incomp ==1) {
	 //           u32Data = dma_abort;
	 //           dwOffset = cs_dma_msi_abort;
	 //           dwAddrSpace =cs_bar;
	 //           WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	 //           u32Data = 0;
	 //           dwOffset = cs_dma_msi_abort;
	 //           dwAddrSpace =cs_bar;
	 //           WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	 //           dwAddrSpace =cs_bar;
	 //	   dwOffset = cs_dma_cntrl;
	 //           WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	 //	   if(iprint ==1 && j < 2) printf(" receive DMA status word after abort %d %X \n", i, u32Data);
	 //           dwAddrSpace =cs_bar;
	 //           dwOffset = t_cs_reg;
	 //           WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	 //	   if(iprint==1 && j < 2) {
	 //	     u32Data=u64Data;
	 //	     printf (" transmitter status after abort  = %8X \n",u32Data);
	 //	     u32Data=u64Data>>32;
	 //	     printf (" receiver status after abort  = %8X \n",u32Data);
	 //	   }
	 //         }
	 //         else 
	break;
      }

      if(idone == 1) {
	buffp_rec = pbuf_rec;
	buffp_send = pbuf_send;
	
	 //GSK
	 //	 for (i=0; i<nwrite; i++) {
	 //	   k = i%8;
	 //	  if(iprint ==1 && k ==0 && j < 2) printf(" %3d", i);
	 //	  u32Data = *buffp_rec++;
	 //	  u32Data_send = *buffp_send++;
	 //	  if((u32Data != u32Data_send) && (icheck ==1) ) printf(" %d, %d, %11x, %11x\n", j,i,u32Data_send,u32Data);
	 //	  if(iprint==1 && j < 2) printf(" %llX",u32Data);
	 //	  if(k == 7 && iprint == 1 && j < 2) printf("\n");
	 //	 }
	 //	 if(k !=7 && iprint ==1 && j < 2) printf("\n");
      }
       //       if(j%100 ==0) printf(" loop = %d, nwrite= %d \n",j, nwrite);

       //GSK
       //       if(kwrite == -1) {
       //        nwrite =nwrite+1;
       //        if(nwrite > nwrite_max) nwrite =nwrite_min;
       //       }
    }

      /** end timer **/
    gettimeofday(&endtest,NULL);
    seconds = endtest.tv_sec;
    useconds = endtest.tv_usec;
      
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds,useconds);

    seconds = endtest.tv_sec - starttest.tv_sec;
    useconds = endtest.tv_usec - starttest.tv_usec;

    mytime = seconds*1000000. + useconds*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime);

    break;
    
  case 3:
    printf("enter number words per packet \n");
    scanf("%d",&nwrite);
    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
    }

/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

    printf("\n\nWriting to file: -----------> test.bin\n");

    FILE * pFile;
    pFile = fopen("test.bin","w");
    if (pFile==NULL){
      printf("\nFile NOT open; Exiting.\n");
      break;
    }

    //first write some stuff

/* set tx mode register */
    u32Data = 0xf0000fff;
    dwOffset = tx_md_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** initialize the tranmission ***/
    u32Data = cs_init;
    dwOffset = t_cs_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
    dwAddrSpace = cs_bar;
    u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
    dwOffset = t_cs_reg;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");
/** initialize the receiver ***/
    u32Data = cs_init;
    dwOffset = r_cs_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** start the receiver **/
    dwAddrSpace = cs_bar;
    u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
    dwOffset = r_cs_reg;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


    //now write to transmitter ---> edit from this point on

    u32Data = 0x3333;
    for (i=0; i< nwrite; i++) {
      dwAddrSpace = tr_bar;
      dwOffset = 0;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    }


    //receiver read and write to file

    //loop read



      /** begin timer **/
    struct timeval starttest2, endtest2;
    gettimeofday(&starttest2,NULL);
    long mytime2, seconds2, useconds2;
    seconds2 = starttest2.tv_sec;
    useconds2 = starttest2.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds2,useconds2);
      //get a fresh timestamp
    gettimeofday(&starttest2,NULL);




      /** end timer **/
    gettimeofday(&endtest2,NULL);
    seconds2 = endtest2.tv_sec;
    useconds2 = endtest2.tv_usec;
      
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds2,useconds2);

    seconds2 = endtest2.tv_sec - starttest2.tv_sec;
    useconds2 = endtest2.tv_usec - starttest2.tv_usec;
      
    mytime2 = seconds2*1000000. + useconds2*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime2);
    

    fclose(pFile);

    break;

  }

}
  
static int dcm2_fpga_boot(WDC_DEVICE_HANDLE hDev, int imod, int fpga_t)
{

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
    static unsigned long long u64Data;
    static DWORD dwOffset;
    static long ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,istop,newcmd,ifr_readback;
    static UINT32 send_array[4000],read_array[4000];
    DWORD dwDMABufSize;
    PVOID pbuf;
    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck;
    UINT32 buf_send[2000];
    static int   count,num,counta,nword,ireadback,nloop;
    static int   iwait_loop;
    static int   ij,nsend,iloop,inew,idma_readback;
    unsigned char    charchannel;
    unsigned char    carray[4000];
    UINT32 *px,*py;

    FILE *inpf;


    ifr_readback=0;
    ifr=0;
    iwrite =0;
    iprint =0;
    icheck =0;
    istop=0;
    ireadback =1;
    idma_readback=1;
    nsend = 1000;
    iwait_loop =0;

    px = &buf_send;
    py = &read_array;
    ichip=6;

/** initialize **/

    buf_send[0]=0x0;
    buf_send[1]=0x0;
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
/** test command 1 ***/
    if (ifr == 0) {
       ifr=1;
       buf_send[0]=(imod <<11)+ (ichip << 8) + poweron;
       buf_send[1]=0x1111;
       i= 1;
       k= 2;
/** try to cover  1.5*100ms */
       i = pcie_send(hDev, i, k, px);
       if(iwait_loop == 0) {
        for (k=0; k<150000000; k++) {
         ik=k+1;
         i=ik*ik;
        }
       }
       else {
        printf(" start wait \n");
        sleep(1);
        printf("end wait \n");
       }
    }
    iloop=1;
    ik=configure_s60;
    if(fpga_t == 2) {
     iloop=4;
     ik=configure_s30;
    }
    buf_send[0]=(imod <<11)+ (ichip << 8) + ik;
    buf_send[1]=0x5555aaaa;
    i= 1;
    k= 2;
    i = pcie_send(hDev, i, k, px);
/** wait for at least 100us **/

    if(iwait_loop == 0) {
     for (k=0; k<1000000; k++) {
      ik=k+1;
      i=ik*ik;
     }
    }
    else usleep(200);    // wait 200 microsec.

    if(ireadback == 1) {
        buf_send[0]=(imod <<11)+ (ichip << 8) + loopback;
        i= 1;
        k= 1;
        i = pcie_send(hDev, i, k, px);
    }
    for (j=0; j<iloop; j++) {
       if(fpga_t == 2)
//         inpf = fopen("/home/chi/dcm2_compress.rbf","r");
         inpf = fopen("/home/chi/dcm2_780_boot_adctest","r");

       else
          inpf = fopen("/home/chi/dcm2_1152_boot_adctest","r");

        /* read data as characters (28941) */

       count = 0;
       counta= 0;
       while (fread(&charchannel,sizeof(char),1,inpf)==1) {

         carray[count] = charchannel;
         count++;
         counta++;
         if((count%(nsend*2)) == 0){

           buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16);
           send_array[0] =buf_send[0];
/*           printf(" counta = %d, first word = %x, %x, %x \n",counta,buf_send[0], carray[0], carray[1]);  */
           for (ij=0; ij< nsend; ij++) {
            buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
            send_array[ij+1] = buf_send[ij+1];
           }
           nword =nsend+1;

           if(ireadback == 1) {
            if(idma_readback == 1) {
              i=pcie_rec(hDev,1,1,nword,0,py); /** set up readback  **/
            }
            else {
              if(ifr_readback ==0) {
 //              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
               dwAddrSpace =2;
               u32Data = 0x20000000;
               dwOffset = 0x1c;
               WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
               if(iprint == 1) printf(" receiver inited \n");
              }
              ifr_readback =1;
              dwAddrSpace =2;
              u32Data = 0x40000000+nword*4;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u64Data =0;
              dwOffset = 0x18;
              WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
              if(iprint==1) printf (" status word before send = %llX \n",u64Data);
            }
           }

           i =1;
           i = pcie_send(hDev, i, nword, px);
//  50ns per byt, 2000 bytes*50ns*2 = 200 microsec
           if(ireadback != 1){
            if(iwait_loop == 0) {
             for (k=0; k<200000; k++) {    /* 100000 for 100 microsec */
              ik=k+1;
              i=ik*ik;
             }
            }
            else usleep(300);  // wait for 300 microsec
           }

           if(ireadback == 1) {
            if(idma_readback == 1) {
              i=pcie_rec(hDev,1,2,nword,0,py); /** set up readback  **/
            }
            else {
             dwAddrSpace =2;
             u64Data =0;
             dwOffset = 0x18;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
             if(iprint == 1) printf (" status word before read = %llX \n",u64Data);
             k = nword%2;
             ik= nword/2+1;
             if(k == 0) ik = nword/2;
             for (i=0; i<ik; i++) {
               dwAddrSpace =0;
               u64Data =0;
               dwOffset = 0x0;
               WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
               read_array[i*2] = u64Data;
               read_array[i*2+1] = u64Data>>32;
             }
             dwAddrSpace =2;
             u64Data =0;
             dwOffset = 0x18;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
             if(iprint ==1 )printf (" status word after read = %llX \n",u64Data);
//           printf (" status word after read = %llX \n",u64Data);
            }
            for (i=0; i< nword; i++) {
               if(iprint ==1 ) {
                if(i%8 == 0) printf("%d", i);
                printf("%9X",read_array[i]);
                if(((i+1)%8) ==0) printf("\n");
               }
               if(read_array[i] != send_array[i]) {
                 printf("\n counta=%d, i=%d, send =%9X read= %9X \n",counta,i,send_array[i],read_array[i]);
               }
            }
            if(iprint == 1) {
               if(nword%8 !=0) printf("\n");
            }
           }
/*           }  */
           count=0;
//           printf ("enter something to continue\n");
//           scanf("%d",&k);

         }
       }
       if (feof(inpf)) {
        printf("You have reached the end-of-file word count= %d %d\n", counta, count);
        buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16);
        if ( count > 1) {
           if( ((count-1)%2) ==0) {
             ik =(count-1)/2;
           }
           else {
             ik =(count-1)/2+1;
           }
           printf("ik= %d\n",ik);
           for (ij=0; ij<ik;ij++){
            buf_send[ij+1] = carray[2*ij+1]+(carray[2*ij+2]<<16);
            send_array[ij+1] = buf_send[ij+1];
           }
        }
        else ik=1;
/*
           for (ij=ik-10; ij< ik; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }
*/
        if(j == iloop-1)
         nword =ik+5;
        else
         nword =ik+1;
        if(ireadback == 1) {
//              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
            if(idma_readback == 1) {
              i=pcie_rec(hDev,1,1,nword,0,py); /** set up readback  **/
            }
            else {
              dwAddrSpace =2;
              u32Data = 0x20000000;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u32Data = 0x40000000+nword*4;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u64Data =0;
              dwOffset = 0x18;
              WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
              if(iprint==1) printf (" status word before send = %llX \n",u64Data);
            }
        }
        i=1;
        i = pcie_send(hDev, i, nword, px);
//  50ns per byt, 2000 bytes*50ns*2 = 200 microsec
//           if(ireadback != 1){
            if(iwait_loop == 0) {
             for (k=0; k<200000; k++) {    /* 100000 for 100 microsec */
              ik=k+1;
              i=ik*ik;
             }
            }
            else usleep(300);
//           }
        if(ireadback == 1) {
         if(idma_readback == 1) {
          i=pcie_rec(hDev,1,2,nword,0,py); /** set up readback  **/
         }
         else {
          dwAddrSpace =2;
          u64Data =0;
          dwOffset = 0x18;
          WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
          if(iprint == 1) printf (" status word before read = %llX \n",u64Data);
          k = nword%2;
          ik= nword/2+1;
          if(k == 0) ik = nword/2;
          for (i=0; i<ik; i++) {
             dwAddrSpace =0;
             u64Data =0;
             dwOffset = 0x0;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
             read_array[i*2] = u64Data;
             read_array[i*2+1] = u64Data>>32;
          }
          if(iprint ==1 )printf (" status word after read = %llX \n",u64Data);
         }
         for (i=0; i< nword; i++) {
          if(iprint ==1 ) {
            if(i%8 == 0) printf("%d", i);
            printf("%9X",read_array[i]);
            if(((i+1)%8) ==0) printf("\n");
          }
          if(read_array[i] != send_array[i]) {
            printf("\n counta=%d, i=%d, send =%9X read= %9X \n",counta,i,send_array[i],read_array[i]);
          }
         }
        }
        fclose(inpf);
//           printf ("enter something to continue\n");
//           scanf("%d",&k);
     }
    }
//   turn off readback
    if(ireadback == 1) {
        buf_send[0]=(imod <<11)+ ((ichip+1) << 8) + loopback;
        i= 1;
        k= 1;
        i = pcie_send(hDev, i, k, px);
    }

/*** reack back status ***/

    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u32Data = 0x20000000;
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    if(iprint == 1) printf(" receiver inited \n");
    dwAddrSpace =2;
    u32Data = 0x40000000+4;
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u64Data =0;
    dwOffset = 0x18;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    printf (" status word in the status read = %llX \n",u64Data);

    buf_send[0]=(imod <<11)+ (ichip << 8) + rdstatus;  /* turn on status read*/
    buf_send[1]=0x5555aaaa;
    i= 1;
    k= 1;
    i = pcie_send(hDev, i, k, px);
//
//    wait for 10 microsec
//
    if(iwait_loop == 0) {
     for (k=0; k<10000; k++) {    /* 100000 for 100 microsec */
      ik=k+1;
      i=ik*ik;
     }
    }
    else usleep(15000); // wait for 15 microsec

    dwAddrSpace =2;
    u64Data =0;
    dwOffset = 0x18;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    printf (" status word in the status read = %llX \n",u64Data);

    dwAddrSpace =0;
    u64Data =0;
    dwOffset = 0x0;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    u32Data = u64Data;
    if(fpga_t ==1)
       printf(" status word from FPGA 5 = %11X \n", u32Data);
    else
       printf(" status word from FPGA 1-4 = %11X \n", u32Data);
    return i;
}


static int dcm2_fpga_boot_n(WDC_DEVICE_HANDLE hDev, int imod, int fpga_t)
{

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
    static unsigned long long u64Data;
    static DWORD dwOffset;
    static long ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,istop,newcmd,ifr_readback;
    static UINT32 send_array[4000],read_array[4000];
    DWORD dwDMABufSize;
    PVOID pbuf;
    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck;
    UINT32 buf_send[2000];
    static int   count,num,counta,nword,ireadback,nloop;
    static int   iwait_loop;
    static int   ij,nsend,iloop,inew,idma_readback;
    unsigned char    charchannel;
    unsigned char    carray[4000];
    UINT32 *px,*py;

    FILE *inpf;


    ifr_readback=0;
    ifr=0;
    iwrite =0;
    iprint =0;
    icheck =0;
    istop=0;
    ireadback =1;
    idma_readback=1;
    nsend = 1000;
    iwait_loop =0;

    px = &buf_send;
    py = &read_array;
    ichip=6;

/** initialize **/

    buf_send[0]=0x0;
    buf_send[1]=0x0;
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
/** test command 1 ***/
    if (ifr == 0) {
       ifr=1;
       buf_send[0]=(imod <<11)+ (ichip << 8) + poweron;
       buf_send[1]=0x1111;
       i= 1;
       k= 2;
/** try to cover  1.5*100ms */
       i = pcie_send(hDev, i, k, px);
       if(iwait_loop == 0) {
        for (k=0; k<150000000; k++) {
         ik=k+1;
         i=ik*ik;
        }
       }
       else {
        printf(" start wait \n");
        sleep(1);
        printf("end wait \n");
       }
    }
    iloop=1;
    ik=configure_s60;
    if(fpga_t == 2) {
     iloop=4;
     ik=configure_s30;
    }
    buf_send[0]=(imod <<11)+ (ichip << 8) + ik;
    buf_send[1]=0x5555aaaa;
    i= 1;
    k= 2;
    i = pcie_send(hDev, i, k, px);
/** wait for at least 100us **/

    if(iwait_loop == 0) {
     for (k=0; k<1000000; k++) {
      ik=k+1;
      i=ik*ik;
     }
    }
    else usleep(200);    // wait 200 microsec.

    if(ireadback == 1) {
        buf_send[0]=(imod <<11)+ (ichip << 8) + loopback;
        i= 1;
        k= 1;
        i = pcie_send(hDev, i, k, px);
    }
    for (j=0; j<iloop; j++) {
       if(fpga_t == 2)
//         inpf = fopen("/home/chi/dcm2_compress.rbf","r");
         inpf = fopen("/home/chi/dcm2_compress.rbf","r");

       else
          inpf = fopen("/home/chi/eventmerge_new_0520.rbf","r");

        /* read data as characters (28941) */

       count = 0;
       counta= 0;
       while (fread(&charchannel,sizeof(char),1,inpf)==1) {

         carray[count] = charchannel;
         count++;
         counta++;
         if((count%(nsend*2)) == 0){

           buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16);
           send_array[0] =buf_send[0];
/*           printf(" counta = %d, first word = %x, %x, %x \n",counta,buf_send[0], carray[0], carray[1]);  */
           for (ij=0; ij< nsend; ij++) {
            buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
            send_array[ij+1] = buf_send[ij+1];
           }
           nword =nsend+1;

           if(ireadback == 1) {
            if(idma_readback == 1) {
              i=pcie_rec(hDev,1,1,nword,0,py); /** set up readback  **/
            }
            else {
              if(ifr_readback ==0) {
 //              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
               dwAddrSpace =2;
               u32Data = 0x20000000;
               dwOffset = 0x1c;
               WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
               if(iprint == 1) printf(" receiver inited \n");
              }
              ifr_readback =1;
              dwAddrSpace =2;
              u32Data = 0x40000000+nword*4;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u64Data =0;
              dwOffset = 0x18;
              WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
              if(iprint==1) printf (" status word before send = %llX \n",u64Data);
            }
           }

           i =1;
           i = pcie_send(hDev, i, nword, px);
//  50ns per byt, 2000 bytes*50ns*2 = 200 microsec
           if(ireadback != 1){
            if(iwait_loop == 0) {
             for (k=0; k<200000; k++) {    /* 100000 for 100 microsec */
              ik=k+1;
              i=ik*ik;
             }
            }
            else usleep(300);  // wait for 300 microsec
           }

           if(ireadback == 1) {
            if(idma_readback == 1) {
              i=pcie_rec(hDev,1,2,nword,0,py); /** set up readback  **/
            }
            else {
             dwAddrSpace =2;
             u64Data =0;
             dwOffset = 0x18;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
             if(iprint == 1) printf (" status word before read = %llX \n",u64Data);
             k = nword%2;
             ik= nword/2+1;
             if(k == 0) ik = nword/2;
             for (i=0; i<ik; i++) {
               dwAddrSpace =0;
               u64Data =0;
               dwOffset = 0x0;
               WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
               read_array[i*2] = u64Data;
               read_array[i*2+1] = u64Data>>32;
             }
             dwAddrSpace =2;
             u64Data =0;
             dwOffset = 0x18;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
             if(iprint ==1 )printf (" status word after read = %llX \n",u64Data);
//           printf (" status word after read = %llX \n",u64Data);
            }
            for (i=0; i< nword; i++) {
               if(iprint ==1 ) {
                if(i%8 == 0) printf("%d", i);
                printf("%9X",read_array[i]);
                if(((i+1)%8) ==0) printf("\n");
               }
               if(read_array[i] != send_array[i]) {
                 printf("\n counta=%d, i=%d, send =%9X read= %9X \n",counta,i,send_array[i],read_array[i]);
               }
            }
            if(iprint == 1) {
               if(nword%8 !=0) printf("\n");
            }
           }
/*           }  */
           count=0;
//           printf ("enter something to continue\n");
//           scanf("%d",&k);

         }
       }
       if (feof(inpf)) {
        printf("You have reached the end-of-file word count= %d %d\n", counta, count);
        buf_send[0] = (imod <<11) + (ichip << 8) + configure_cont + (carray[0]<<16);
        if ( count > 1) {
           if( ((count-1)%2) ==0) {
             ik =(count-1)/2;
           }
           else {
             ik =(count-1)/2+1;
           }
           printf("ik= %d\n",ik);
           for (ij=0; ij<ik;ij++){
            buf_send[ij+1] = carray[2*ij+1]+(carray[2*ij+2]<<16);
            send_array[ij+1] = buf_send[ij+1];
           }
        }
        else ik=1;
/*
           for (ij=ik-10; ij< ik; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }
*/
        if(j == iloop-1)
         nword =ik+5;
        else
         nword =ik+1;
        if(ireadback == 1) {
//              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
            if(idma_readback == 1) {
              i=pcie_rec(hDev,1,1,nword,0,py); /** set up readback  **/
            }
            else {
              dwAddrSpace =2;
              u32Data = 0x20000000;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u32Data = 0x40000000+nword*4;
              dwOffset = 0x1c;
              WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
              dwAddrSpace =2;
              u64Data =0;
              dwOffset = 0x18;
              WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
              if(iprint==1) printf (" status word before send = %llX \n",u64Data);
            }
        }
        i=1;
        i = pcie_send(hDev, i, nword, px);
//  50ns per byt, 2000 bytes*50ns*2 = 200 microsec
//           if(ireadback != 1){
            if(iwait_loop == 0) {
             for (k=0; k<200000; k++) {    /* 100000 for 100 microsec */
              ik=k+1;
              i=ik*ik;
             }
            }
            else usleep(300);
//           }
        if(ireadback == 1) {
         if(idma_readback == 1) {
          i=pcie_rec(hDev,1,2,nword,0,py); /** set up readback  **/
         }
         else {
          dwAddrSpace =2;
          u64Data =0;
          dwOffset = 0x18;
          WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
          if(iprint == 1) printf (" status word before read = %llX \n",u64Data);
          k = nword%2;
          ik= nword/2+1;
          if(k == 0) ik = nword/2;
          for (i=0; i<ik; i++) {
             dwAddrSpace =0;
             u64Data =0;
             dwOffset = 0x0;
             WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
             read_array[i*2] = u64Data;
             read_array[i*2+1] = u64Data>>32;
          }
          if(iprint ==1 )printf (" status word after read = %llX \n",u64Data);
         }
         for (i=0; i< nword; i++) {
          if(iprint ==1 ) {
            if(i%8 == 0) printf("%d", i);
            printf("%9X",read_array[i]);
            if(((i+1)%8) ==0) printf("\n");
          }
          if(read_array[i] != send_array[i]) {
            printf("\n counta=%d, i=%d, send =%9X read= %9X \n",counta,i,send_array[i],read_array[i]);
          }
         }
        }
        fclose(inpf);
//           printf ("enter something to continue\n");
//           scanf("%d",&k);
     }
    }
//   turn off readback
    if(ireadback == 1) {
        buf_send[0]=(imod <<11)+ ((ichip+1) << 8) + loopback;
        i= 1;
        k= 1;
        i = pcie_send(hDev, i, k, px);
    }

/*** reack back status ***/

    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u32Data = 0x20000000;
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    if(iprint == 1) printf(" receiver inited \n");
    dwAddrSpace =2;
    u32Data = 0x40000000+4;
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u64Data =0;
    dwOffset = 0x18;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    printf (" status word in the status read = %llX \n",u64Data);

    buf_send[0]=(imod <<11)+ (ichip << 8) + rdstatus;  /* turn on status read*/
    buf_send[1]=0x5555aaaa;
    i= 1;
    k= 1;
    i = pcie_send(hDev, i, k, px);
//
//    wait for 10 microsec
//
    if(iwait_loop == 0) {
     for (k=0; k<10000; k++) {    /* 100000 for 100 microsec */
      ik=k+1;
      i=ik*ik;
     }
    }
    else usleep(15000); // wait for 15 microsec

    dwAddrSpace =2;
    u64Data =0;
    dwOffset = 0x18;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    printf (" status word in the status read = %llX \n",u64Data);

    dwAddrSpace =0;
    u64Data =0;
    dwOffset = 0x0;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    u32Data = u64Data;
    if(fpga_t ==1)
       printf(" status word from FPGA 5 = %11X \n", u32Data);
    else
       printf(" status word from FPGA 1-4 = %11X \n", u32Data);
    return i;
}




static int eprom_readback(WDC_DEVICE_HANDLE hDev, int imod, int mode, UINT32 *buff_rec)
{

#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3

#define  sp_adc_slowcntl_sub        1

#define  sp_adc_eprom_addr_l       50
#define  sp_adc_eprom_addr_h       51
#define  sp_adc_eprom_wdata        52
#define  sp_adc_eprom_w_pulse      53
#define  sp_adc_eprom_read_pulse   54
#define  sp_adc_eprom_bulk_erase_p 55
#define  sp_adc_eprom_read_status_p  56
#define  sp_adc_eprom_read_id_p    57
#define  sp_adc_eprom_reset_p      58

    int ichip,ich,i,k, nword, iprint;
    UINT32 buf_send[40000];
    static UINT32 send_array[40000];
    static UINT32 read_array[10];
    UINT32 *px;
    UINT32 *py;



    py = &read_array;
    px = &buf_send;
    iprint =0;

    nword = 3;
//
//         status read is not usefull unless busy is not low
//
    ichip = sp_adc_slowcntl_sub ;   // controller data go to slow control section
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_eprom_read_status_p + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);
//    printf(" eprom read status send \n");
//    scanf("%d", &i);


    ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
    buf_send[0]=(imod<<11)+(ichip<<8)+(8) + (0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send_1(hDev, i, k, px);
//    printf(" eprom read back command send \n");
//    scanf("%d", &i);
//
    i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
    ichip = sp_adc_readback_sub ;   // controller data go to ADC input section
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_readback_status) + (0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send_1(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//       printf("module %d address %d receive data word = %x, %x \n", imod, ia, read_array[0], read_array[1]);
//    printf(" data = %x \n", read_array[1]);
    i= read_array[1];
//
//  sort of strange, lazy to change other code
//
    for (k=0; k< nword; k++) {
     *buff_rec++ = read_array[k];
    }

    return i;
}


static int adc_setup(WDC_DEVICE_HANDLE hDev, int imod, int iprint)
{
#define  sp_cntrl_timing            3
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22



#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#
#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_linux_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1


    int ichip,ich,i,k;
    UINT32 buf_send[40000];
    UINT32 *px;



    px = &buf_send;
    ichip = sp_adc_input_sub ;   // controller data go to ADC input section
    for (ich=0; ich<8; ich++) {

//    set spi address

     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
     if(iprint==1) {
       printf(" set spi address to channel %d, module %d\n", ich, imod);
       printf(" power reset \n");
//       scanf("%d",&is);
     }

//      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_)+((is & 0xf)<<16); //set spi address
//      i=1;
//        k=1;
//        i = pcie_send(hDev, i, k, px);
//       printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=11;
//        ichip=5;
//
//
//     power reset the ADC
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x8))+((0x03)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x8, data =0x03;
//

     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
     if(iprint==1) {
       printf(" set spi address to channel %d, module %d\n", ich, imod);
       printf(" remove power reset \n");
//       scanf("%d",&is);
     }

//
//     reove power reset
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x8))+((0x00)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x8, data =0x00;
//

     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//     reset ADC
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//       if(ich ==7) {
     if(iprint ==1) printf(" send last command ich= %d module %d\n", ich, imod);
//        scanf("%d",&is);
//       }
//
//    set LVDS termination  set addess 0x15  to 1 to 2x drive
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<12)+(0x15))+((0x20)<<24)+((0x0)<<16);   // 100 ohms termation
//     buf_send[1]=(((0x0)<<12)+(0x15))+((0x0)<<24)+((0x0)<<16);   // no ohms termation, 1x drive
//     buf_send[1]=(((0x0)<<12)+(0x15))+((0x1)<<24)+((0x0)<<16);   // no ohms termation, 2x drive
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x15, data =0x1;
//
     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//       printf(" termination set, type 1 to continue \n");
//       scanf("%d",&i);

//
//    set fix pattern  0xa = sync pattern
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xa;
//

     i=1;
     k=2;
//      i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//       printf(" fix pattern set type 1 to continue \n");
//       scanf("%d",&i);
    }


    usleep(100);
//
//    set up for ADC alignment
//
    ichip = sp_adc_slowcntl_sub ;   // controller data go to ADC input section
//
//       pll reset
//
    if(iprint == 1)printf(" send pll reset\n");
//      scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_pll_reset + (0<<16) ;
    i= 1;
    k= 1;
//    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);

//
//       DPA reset
//
    if(iprint == 1) printf(" send ADC DPA reset module %d\n", imod);
//    scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_dpa_reset + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);

//
//       upper ADC alignment
//
    if(iprint==1) printf(" send upper channel align module %d \n", imod);
//    scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_u_adc_align + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);
//
//       lower ADC alignment
//
    if(iprint == 1) printf(" send lower channel align module %d\n", imod);
//      scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l_adc_align + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);
//
//
//

   ichip = sp_adc_input_sub ;   // controller data go to ADC input section
   for (ich=0; ich<8; ich++) {
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(100);
//
//    output offset binary code
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<12)+(0x14))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x14, data =0x0;
//

    i=1;
    k=2;

    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us

//
//    unset fix pattern  0x0 for normal data taking   --- set to test condition
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0x0;
//

    i=1;
    k=2;

    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
   }
//
//  test routine
//
//    set spi address

    ich =0;
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
    i= 1;
    k= 1;
//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);
//
//    remove channel H,G,F,E from the selection list
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x4))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x4, data =0x0;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    only keep channel a from the selection list
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x5))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x5, data =0x1;
//

    i=1;
    k=2;

///    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    set fix pattern  0xa = sync pattern
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0xd))+((0xc)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xc;
//

     i=1;
     k=2;
//      i = pcie_send(hDev, i, k, px);
//     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//    restore selection list 1
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x4))+((0xf)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x4, data =0x0;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    restore selection list 2
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x5))+((0x3f)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x5, data =0x1;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us



    return i;
}


static int adc_setup_debug(WDC_DEVICE_HANDLE hDev, int imod, int iprint)
{
#define  sp_cntrl_timing            3
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22



#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#
#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_linux_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1


    int ichip,ich,i,k, is;
    UINT32 buf_send[40000];
    UINT32 *px;



    px = &buf_send;
    ichip = sp_adc_input_sub ;   // controller data go to ADC input section

    for (ich=0; ich<8; ich++) {

//    set spi address

     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
//
     if(iprint==1) printf(" set spi address to channel %d, module %d\n", ich, imod);
//       scanf("%d",&is);

//
//  once per chip
//
     if(iprint==1) {
      printf(" ADC power reset \n");
      scanf("%d",&is);
     }


//
//     power reset the ADC -- Digital reset
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x8))+((0x03)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x8, data =0x03;
//

     i=1;
     k=2;
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
     if(iprint==1) {
      printf(" remove ADC power reset \n");
      scanf("%d",&is);
     }
//
//     reove power reset
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x8))+((0x00)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x8, data =0x00;
//

     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//
//
     if(iprint==1) {
      printf(" ADC reset and SPI mode \n");
      scanf("%d",&is);
     }
//
//     reset ADC
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0x0))+((0x3c)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x0, data =0x3c;
//

     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
     if(iprint==1) {
      printf(" set output 100 ohms termination \n");
      scanf("%d",&is);
     }

//
//    set LVDS termination  set addess 0x15  to 1 to 2x drive
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<12)+(0x15))+((0x20)<<24)+((0x0)<<16);   // 100 ohms termation
//     buf_send[1]=(((0x0)<<12)+(0x15))+((0x0)<<24)+((0x0)<<16);   // no ohms termation, 1x drive
//     buf_send[1]=(((0x0)<<12)+(0x15))+((0x1)<<24)+((0x0)<<16);   // no ohms termation, 2x drive
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x15, data =0x1;
//
     i=1;
     k=2;
//       i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us


//
//       if(ich ==7) {
     if(iprint ==1) {
       printf(" send last command ich= %d module %d\n", ich, imod);
       scanf("%d",&is);
     }
//       }

//       printf(" termination set, type 1 to continue \n");
//       scanf("%d",&i);

//
//    set fix pattern  0xa = sync pattern
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0xd))+((0xa)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xa;
//

     i=1;
     k=2;
//      i = pcie_send(hDev, i, k, px);
     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//       printf(" fix pattern set type 1 to continue \n");
//       scanf("%d",&i);
    }


    usleep(100);
//
//    set up for ADC alignment
//
    ichip = sp_adc_slowcntl_sub ;   // controller data go to ADC input section
//
//       pll reset
//
    if(iprint == 1)printf(" send pll reset\n");
//      scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_pll_reset + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);

//
//       DPA reset
//
    if(iprint == 1) printf(" send ADC DPA reset module %d\n", imod);
//    scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_dpa_reset + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);

//
//       upper ADC alignment
//
    if(iprint==1) printf(" send upper channel align module %d \n", imod);
//    scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_u_adc_align + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);
//
//       lower ADC alignment
//
    if(iprint == 1) printf(" send lower channel align module %d\n", imod);
//      scanf("%d",&is);
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_l_adc_align + (0<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1000);
//
//
//

   ichip = sp_adc_input_sub ;   // controller data go to ADC input section
   for (ich=0; ich<8; ich++) {
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(100);
//
//    output offset binary code
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<12)+(0x14))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x14, data =0x0;
//

    i=1;
    k=2;

    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us

//
//    unset fix pattern  0x0 for normal data taking   --- set to test condition
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0x0;
//

    i=1;
    k=2;

    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
   }
//
//  test routine
//
//    set spi address

    ich =0;
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_spi_add + (ich<<16) ;
    i= 1;
    k= 1;
//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);
//
//    remove channel H,G,F,E from the selection list
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x4))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x4, data =0x0;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    only keep channel a from the selection list
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x5))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x5, data =0x1;
//

    i=1;
    k=2;

///    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    set fix pattern  0xa = sync pattern
//
     buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
     buf_send[1]=(((0x0)<<13)+(0xd))+((0xc)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xc;
//

     i=1;
     k=2;
//      i = pcie_send(hDev, i, k, px);
//     i = pcie_send_1(hDev, i, k, px);
     usleep(100);   // sleep for 100us
//
//    restore selection list 1
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x4))+((0xf)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x4, data =0x0;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us
//
//    restore selection list 2
//
    buf_send[0]=(imod<<11)+(ichip<<8)+(sp_adc_spi_data)+(0x0300<<16); //1st next word will be overwrite by the next next word
    buf_send[1]=(((0x0)<<13)+(0x5))+((0x3f)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0x5, data =0x1;
//

    i=1;
    k=2;

//    i = pcie_send_1(hDev, i, k, px);
    usleep(100);   // sleep for 100us



    return i;
}


static int adc_testram_load(WDC_DEVICE_HANDLE hDev, int imod, int idelay)
{
#define  sp_cntrl_timing            3
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22



#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#
#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_linux_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_testram_load_ch     4
#define  sp_adc_testram_load_data   5
#define  sp_adc_testram_trig_delay  7

#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1


    int ichip,ich,i,k,idata, iad;
    UINT32 buf_send[40000];
    UINT32 *px;



    px = &buf_send;
    ichip = sp_adc_input_sub ;   // controller data go to ADC input section

    for (ich =0; ich< 64; ich++) {
     if(ich== 0)  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (64<<16);  // set channel 0 to 64
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (ich<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1);
     printf(" load testram ch = %d, module %d\n", ich, imod);
//     scanf("%d", &i);
     for (iad =0; iad<512 ; iad++) {
      idata =  ich*128+iad;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_data + (idata<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
//      printf(" load testram ch = %d, address %d\n", ich, iad);
//      scanf("%d", &i);
     }
    }

    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_trig_delay + (idelay<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);




    return i;
}


static int trigger_board_setup(WDC_DEVICE_HANDLE hDev, int imod, int delay, int sync_step, int opt_mask, int ithr)
{
/*
#define  sp_L1_s10_slow_thr         6
#define  sp_L1_s10_slow_reset       7
#define  sp_L1_s10_slow_en0         8
#define  sp_L1_s10_slow_en1         9
#define  sp_L1_s10_slow_test       12
#define  sp_L1_s10_slow_delay      13
#define  sp_L1_s10_slow_phasen     14
#define  sp_L1_s10_slow_rst_p      15
#define  sp_L1_s10_slow_RESET      16
#define  sp_L1_s10_slow_monitor_p  20
#define  sp_L1_s10_slow_ch_dis1    21
#define  sp_L1_s10_slow_ch_dis2    22


#define  sp_L1_s10_rst_pll          1
#define  sp_L1_s10_rst_opt_fem      2
#define  sp_L1_s10_rst_opt_st_t     3
#define  sp_L1_s10_rst_opt_st_r     5
#define  sp_L1_s10_rst_opt_out_t    6
*/
    static int    i,j,k, nword,iprint;
    static int    ichip,imask;
    static UINT32        buf_send[40000],read_array[10000];
    static UINT32        *px, *py;


        px = &buf_send;
        iprint=0;
//
//      reset the optical parts
//
        printf(" reset trigger module optics \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_RESET + (0x0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      disable optucal channel
//
//
//      reset the optical parts
//
        printf(" disable optical channel \n");
        scanf("%d", &i);
        ichip = 0;
        imask = opt_mask & 0xffff;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_ch_dis1 + (imask<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
        imask = (opt_mask >> 16) & 0xff;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_ch_dis2 + (imask<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);


//
//
        printf(" reset trigger module pll rseet \n");
        scanf("%d", &i);

//
//         pll reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_pll<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" reset trigger module stich transmiiter reset \n");
        scanf("%d", &i);

//
//        sttich transmitter reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_opt_st_t<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
        printf(" reset trigger module stich receiver reset \n");
        scanf("%d", &i);

//
//         stich receiver reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_opt_st_r<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//         transmitter reset
//
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_rst_p + (sp_L1_s10_rst_opt_out_t<< 16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" reset test data register \n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_reset + (0x0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" set phase number (0-15)\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_phasen  + (sync_step<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" set align data delay\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_delay  + (delay<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//
//
        printf(" set threshold\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_thr  + (ithr<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
//
//      readout starus
//
        nword =4;
        py = &read_array;
        ichip =0;
//
        printf(" send read command \n");
        scanf("%d", &i);
//       for (ik=0; ik<100000000; ik++) {
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        usleep(10);
        buf_send[0]=(imod<<10)+(ichip<<8)+(sp_L1_s10_slow_mbd_o_read) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        printf(" before read data word received = %x %x %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3]);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//        usleep(10);
        printf(" after read data word received = %x %x %x %x\n", read_array[0], read_array[1], read_array[2], read_array[3]);
//
//
        printf(" send read command \n");
        scanf("%d", &i);
//       for (ik=0; ik<100000000; ik++) {
        i = pcie_rec_2(hDev,0,1,nword,iprint,py);       // init receiver
        usleep(10);
        buf_send[0]=(imod<<10)+(ichip<<8)+(sp_L1_s10_slow_mbd_o_read) + (0x0<<16);  // read out status
        i=1;
        k=1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
        py = &read_array;
        i = pcie_rec_2(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//        usleep(10);
        printf(" data word received = %x %x\n", read_array[0], read_array[1]);


        return i;
//
//
//
/*
        printf(" enter 0 for sequence loading, 1 for test case\n");
        scanf("%d", &itest_p);
*/
//
//
//
/*
        printf(" set test to 0\n");
        scanf("%d", &i);
        ichip = 0;
        buf_send[0]=(imod <<10)+ (ichip << 8) + sp_L1_s10_slow_test  + (0x0<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(1000);
*/
//

//
//       load EN0 set of test data
//       1st word to set command
//       2nd - word 25 is to set 28 resgister
//       last word is to set channel 0 again
//


}



static int adc_testram_trig_load(WDC_DEVICE_HANDLE hDev, int imod, int idelay)
{
#define  sp_cntrl_timing            3
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22

#define  sp_adc_trigproc_sub        5

#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#
#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_linux_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_testram_load_ch     4
#define  sp_adc_testram_load_data   5
#define  sp_adc_testram_trig_delay  7

#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_adc_trig_sub_delay      1
#define  sp_adc_trig_tbl_chnl       2
#define  sp_adc_trig_lkp_addr       3
#define  sp_adc_trig_lkp_data       4
#define  sp_adc_trig_smpl_phase     5
#define  sp_adc_trig_read_delay     6
#define  sp_adc_trig_read_size      7
#define  sp_adc_trig_lkp_write     10


#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1


    int ichip,ich,i,k,idata, iad;
    int istart, iwidth, iph, trig_rw_delay;
    int itrig_lk_data, ia, ik;
    UINT32 buf_send[40000];
    UINT32 *px;

    int patten[16] = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0};
    int patten1[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    int patten2[16] = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0};

    px = &buf_send;
    ichip = sp_adc_input_sub ;   // controller data go to ADC input section
    istart =10;
    iwidth =6;
    iph = 0x3fff;
    trig_rw_delay =6;

    for (ich =0; ich< 64; ich++) {
     if(ich== 0)  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (64<<16);  // set channel 0 to 64
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (ich<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1);
     printf(" load testram ch = %d, module %d\n", ich, imod);
//     scanf("%d", &i);
     for (iad =0; iad<512 ; iad++) {
      if(ich%4 == 0) {
        if((iad >= istart) && (iad<= istart+iwidth)) idata= iph;
        else idata = ich;
      }
      else idata =ich;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_data + (idata<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
//      printf(" load testram ch = %d, address %d\n", ich, iad);
//      scanf("%d", &i);
     }
    }

    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_trig_delay + (idelay<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);
//
//
    ichip = sp_adc_trigproc_sub;
    for (ia =0; ia <64; ia ++) {
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_tbl_chnl + (ia<<16);  // set channel 0 to 63
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1);
//        printf("type 1 to continue \n");
//        scanf("%d",&i);
     for (ik=0; ik<1024; ik++) {
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_addr + (ik<<16);  // set table write address
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
//         printf("load address type 1 to continue \n");
//         scanf("%d",&i);
      itrig_lk_data = ik;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_data + ( itrig_lk_data <<16);  // set lookup table data word
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
//      printf("load data type 1 to continue \n");
//      scanf("%d",&i);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_write + (ik<<16);  // just a write pulse
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
      if(ik == 0)     printf(" channel %d, address = %d \n", ia,ik);
//      scanf("%d",&i);
     }
    }
//
//
//
    ichip = sp_adc_trigproc_sub;
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_sub_delay + (trig_rw_delay<<16);  // set trigger substract delay to 2
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);
//
//
//
//
//#define  sp_adc_trig_smpl_phase      5
    ichip = sp_adc_trigproc_sub;
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_smpl_phase + (0x6<<16);  // set trigger sample phase 5
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);





    return i;
}

static int adc_testram_trig_load_1(WDC_DEVICE_HANDLE hDev, int imod, int idelay, int ipattern, int iph)
{
#define  sp_cntrl_timing            3
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22

#define  sp_adc_trigproc_sub        5

#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#
#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_linux_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_testram_load_ch     4
#define  sp_adc_testram_load_data   5
#define  sp_adc_testram_trig_delay  7

#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_adc_trig_sub_delay      1
#define  sp_adc_trig_tbl_chnl       2
#define  sp_adc_trig_lkp_addr       3
#define  sp_adc_trig_lkp_data       4
#define  sp_adc_trig_smpl_phase     5
#define  sp_adc_trig_read_delay     6
#define  sp_adc_trig_read_size      7
#define  sp_adc_trig_lkp_write     10


#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1


    int ichip,ich,i,k,idata, iad;
    int istart, iwidth, trig_rw_delay;
    int itrig_lk_data, ia, ik, iz;
    UINT32 buf_send[40000];
    UINT32 *px;

    static int pattern1[16] = {1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0};
    static int pattern2[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    static int pattern3[16] = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0};
    static int pattern[16];

    for (i=0; i<16; i++) {
      if(ipattern == 1) pattern[i] = pattern1[i];
      if(ipattern == 2) pattern[i] = pattern2[i];
      if(ipattern == 3) pattern[i] = pattern3[i];
    }


    px = &buf_send;
    ichip = sp_adc_input_sub ;   // controller data go to ADC input section
    istart =10;
    iwidth =6;
//    iph = 0x3fff;
    trig_rw_delay =6;

    for (ich =0; ich< 64; ich++) {
     iz = ich/4;
     if(ich== 0)  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (64<<16);  // set channel 0 to 64
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (ich<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1);
     printf(" load testram ch = %d, module %d\n", ich, imod);
//     scanf("%d", &i);
     for (iad =0; iad<512 ; iad++) {
      if((ich%4 == 0) & (pattern[iz] !=0)) {
        if((iad >= istart) && (iad<= istart+iwidth)) {
          idata= iph;
          printf(" ich = %d, iz =%d, ia= %d, idata = %d \n", ich,iz, iad, idata);
        }
        else idata = 0;
      }
      else idata =0;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_data + (idata<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
//      printf(" load testram ch = %d, address %d\n", ich, iad);
//      scanf("%d", &i);
     }
    }

    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_trig_delay + (idelay<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);
//
//
    ichip = sp_adc_trigproc_sub;
    for (ia =0; ia <64; ia ++) {
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_tbl_chnl + (ia<<16);  // set channel 0 to 63
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1);
//        printf("type 1 to continue \n");
//        scanf("%d",&i);
     for (ik=0; ik<1024; ik++) {
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_addr + (ik<<16);  // set table write address
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
//         printf("load address type 1 to continue \n");
//         scanf("%d",&i);
      itrig_lk_data = ik;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_data + ( itrig_lk_data <<16);  // set lookup table data word
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
//      printf("load data type 1 to continue \n");
//      scanf("%d",&i);
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_write + (ik<<16);  // just a write pulse
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
      if(ik == 0)     printf(" channel %d, address = %d \n", ia,ik);
//      scanf("%d",&i);
     }
    }
//
//
//
    ichip = sp_adc_trigproc_sub;
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_sub_delay + (trig_rw_delay<<16);  // set trigger substract delay to 2
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);
//
//
//
//
//#define  sp_adc_trig_smpl_phase      5
    ichip = sp_adc_trigproc_sub;
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_smpl_phase + (0x6<<16);  // set trigger sample phase 5
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);





    return i;
}



static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =0;
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100000;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }

static int pcie_send_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint,is;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =0;
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =4;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
//      printf(" upper address = %x\n", u32Data);
//      scanf("%d",&is);
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00200000;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<2000000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }


static int adc_testram_trig_load_mbd(WDC_DEVICE_HANDLE hDev, int imod, int idelay, int ipattern, int iph, int iph1)
{
#define  sp_cntrl_timing            3
#define  sp_cntrl_init           0x30
#define  sp_cntrl_reset          0x28
#define  sp_cntrl_l1             0x24
#define  sp_cntrl_pulse          0x22

#define  sp_adc_trigproc_sub        5

#define  sp_adc_readback_sub        4
#define  sp_adc_readback_transfer   1
#define  sp_adc_readback_read       2
#define  sp_adc_readback_status     3
#
#define  sp_adc_input_sub           2
#define  sp_adc_slowcntl_sub        1

#define  sp_adc_l1_delay            1
#define  sp_adc_evt_sample          2

#define  sp_adc_rd_link             3
#define  sp_adc_rd_cntrl            4

#define  sp_adc_sel_l1              5
#define  sp_adc_sel_pulse           6
#define  sp_adc_sel_test_trig       7

#define  sp_adc_sel_linux_rxoff     8

#define  sp_adc_u_adc_align        10
#define  sp_adc_l_adc_align        11
#define  sp_adc_pll_reset          12

#define  sp_adc_rstblk             13
#define  sp_adc_test_pulse         14

#define  sp_adc_dpa_reset          15

#define  sp_adc_spi_add            20
#define  sp_adc_spi_data           30

#define  sp_adc_testram_load_ch     4
#define  sp_adc_testram_load_data   5
#define  sp_adc_testram_trig_delay  7

#define  sp_adc_lnk_tx_dreset      20
#define  sp_adc_lnk_tx_areset      21
#define  sp_adc_trg_tx_dreset      22
#define  sp_adc_trg_tx_areset      23
#define  sp_adc_lnk_rx_dreset      24
#define  sp_adc_lnk_rx_areset      25

#define  sp_adc_link_mgmt_reset    26
#define  sp_adc_link_conf_w        27
#define  sp_adc_link_conf_add      30
#define  sp_adc_link_conf_data_l   31
#define  sp_adc_link_conf_data_u   32

#define  sp_adc_trig_sub_delay      1
#define  sp_adc_trig_tbl_chnl       2
#define  sp_adc_trig_lkp_addr       3
#define  sp_adc_trig_lkp_data       4
#define  sp_adc_trig_smpl_phase     5
#define  sp_adc_trig_read_delay     6
#define  sp_adc_trig_read_size      7
#define  sp_adc_trig_lkp_write     10
#define  sp_adc_trig_mbd_tbl_add   11
#define  sp_adc_trig_mbd_tbl_data  12    


#define  sp_xmit_lastmod            1
#define  sp_xmit_rxanalogreset      2
#define  sp_xmit_rxdigitalreset     3
#define  sp_xmit_init               4

#define  sp_xmit_sub                1


    int ichip,ich,i,k,idata, iad;
    int istart, iwidth, trig_rw_delay;
    int itrig_lk_data, ia, ik, iz;
    int l1_slewing_table[4096], l1_adc_table[1024];
    int step_size, ib, j, is;
    int nrepeat, ngape;
    UINT32 buf_send[40000];
    UINT32 *px;

    static int pattern1[64], pattern2[64], pattern3[64];
    static int pattern[64];
    
    nrepeat=6;
    ngape=60;

    for (i<0; i<64; i++) {
      pattern1[i] = 0;
      pattern2[i] = 0;
      pattern3[i] = 0;
    }

    pattern1[1] = 1;
    pattern1[33] = 1;
    for (i=0; i<64; i++) {
      if(ipattern == 1) pattern[i] = pattern1[i];
      if(ipattern == 2) pattern[i] = pattern2[i];
      if(ipattern == 3) pattern[i] = pattern3[i];
    }


    px = &buf_send;
    ichip = sp_adc_input_sub ;   // controller data go to ADC input section
    istart =10;
    iwidth =6;
//    iph = 0x3fff;
    trig_rw_delay =6;

    for (ich =0; ich< 64; ich++) {
//     iz = ich/4;
     if(ich== 0)  buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (64<<16);  // set channel 0 to 64
     else buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_ch + (ich<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(1);
     printf(" load testram ch = %d, module %d\n", ich, imod);
//     scanf("%d", &i);
     for (iad =0; iad<512 ; iad++) {
      if ( pattern[ich] !=0) {
        idata=0;
        for (i=0; i< nrepeat; i++) {
         if((iad >= (istart+(i*ngape))) && (iad<= (istart+(i*ngape)+iwidth))) {
          if(ich < 32) idata= iph;
          else idata = iph1;
          printf(" ich = %d, ia= %d, idata = %d \n", ich, iad, idata);
         }
        }
      }
      else idata =0;
      buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_load_data + (idata<<16) ;
      i= 1;
      k= 1;
      i = pcie_send_1(hDev, i, k, px);
      usleep(1);
//      printf(" load testram ch = %d, address %d\n", ich, iad);
//      scanf("%d", &i);
     }
    }

    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_testram_trig_delay + (idelay<<16) ;
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);
//
//
//
//      loading the ADC correction table for channel 0-63
//
    for (ich=0 ; ich< 64; ich++) {
//#define  sp_adc_trig_tbl_chnl       2
     ichip = sp_adc_trigproc_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_tbl_chnl + (ich<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
     printf(" adc table loading channel %d \n", ich);

     for (i=0; i<1024; i++) {
//      l1_adc_table[i] = (i+ich) & 0x3ff;
      l1_adc_table[i] = (i) & 0x3ff;
     }
     step_size = 1024;
//       for (is=0; is<5; is++) {
//        ia = is*step_size;
//        ib = (is+1)*step_size+1;
     ia=0;
     ib= 1025;
     ichip = sp_adc_trigproc_sub;
     buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_addr + (ia<<16) ;
     i= 1;
     k= 1;
     i = pcie_send_1(hDev, i, k, px);
     usleep(10);
//
//
     printf(" sending data packet ADC correction %d\n", ich);
     if(ich == 1) scanf("%d", &i);
     for (i=ia; i<ib; i++) {
      if(i == ia) buf_send[0] = (imod <<11)+ (ichip << 8) + sp_adc_trig_lkp_data + (l1_adc_table[i] & 0x3ff) ;
      else if (((i%2) == 0) &&(i !=ia)) {
       j = (i-ia)/2;
       buf_send[j] = (l1_adc_table[i-1] & 0x3ff) + ((l1_adc_table[i] & 0x3ff) <<16);
//         printf(" %d %x\n", j, buf_send[j]);
      }
     }
     i=1;
     k=(step_size/2)+1;
     i = pcie_send_1(hDev, i, k, px);
     k=(step_size/10)+1;
     usleep(k);
    }
//
//

//
//      loading the adc correction table
//
      for (ich=0 ; ich< 32; ich++) {
//#define  sp_adc_trig_tbl_chnl       2
       ichip = sp_adc_trigproc_sub;
       buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_tbl_chnl + (ich<<16) ;
       i= 1;
       k= 1;
       i = pcie_send_1(hDev, i, k, px);
       usleep(10);
       printf(" slewing table loading channel %d \n", ich);

       for (i=0; i<4096; i++) {
//        l1_slewing_table[i] = (i+ich) & 0x1ff;
        l1_slewing_table[i] = (i) & 0x1ff;
       }
       step_size = 1024;
       for (is=0; is<5; is++) {
        ia = is*step_size;
        ib = (is+1)*step_size+1;
        ichip = sp_adc_trigproc_sub;
        buf_send[0]=(imod <<11)+ (ichip << 8) +  + (ia<<16) ;
        i= 1;
        k= 1;
        i = pcie_send_1(hDev, i, k, px);
        usleep(10);
//
//
        printf(" sending data packet %d\n", is);
//        scanf("%d", &i);
        for (i=ia; i<ib; i++) {
         if(i == ia) buf_send[0] = (imod <<11)+ (ichip << 8) + sp_adc_trig_mbd_tbl_data + (l1_slewing_table[i] & 0x1ff) ;
         else if (((i%2) == 0) &&(i !=ia)) {
          j = (i-ia)/2;
          buf_send[j] = (l1_slewing_table[i-1] & 0x1ff) + ((l1_slewing_table[i] & 0x1ff) <<16);
//         printf(" %d %x\n", j, buf_send[j]);
         }
        }
        i=1;
        k=(step_size/2)+1;
        i = pcie_send_1(hDev, i, k, px);
        k=(step_size/10)+1;
        usleep(k);
       }
      }






//
//
    ichip = sp_adc_trigproc_sub;
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_sub_delay + (trig_rw_delay<<16);  // set trigger substract delay to 2
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);
//
//
//
//
//#define  sp_adc_trig_smpl_phase      5
    ichip = sp_adc_trigproc_sub;
    buf_send[0]=(imod <<11)+ (ichip << 8) + sp_adc_trig_smpl_phase + (0x6<<16);  // set trigger sample phase 5
    i= 1;
    k= 1;
    i = pcie_send_1(hDev, i, k, px);
    usleep(1);





    return i;
}





 static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
//    printf(" istart = %d\n", istart);
//   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     printf(" nword = %d \n",nword);
/*
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }
*/
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*4;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/2+1;
      if(nword%2 == 0) nread = nword/2;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }


 static int pcie_rec_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
/* nword assume to be number of 16 bits word */

#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp,is;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
 //   printf(" istart = %d\n", istart);
 //   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = tx_mode_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(mode == 1) {
/* write this will abort previous DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = dma_abort;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
       dwAddrSpace =2;
       dwOffset = cs_dma_msi_abort;
       u32Data = 0;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     /*initialize the receiver */
     dwAddrSpace =cs_bar;
     u32Data = cs_init;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =cs_bar;
     u32Data = cs_start+nword*4;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =cs_bar;
      u64Data =0;
      dwOffset = t2_cs_reg;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/2+1;
      if(nword%2 == 0) nread = nword/2;
      for (j=0; j< nread; j++) {
       dwAddrSpace =t2_tr_bar;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*2;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
//      dwAddrSpace =2;
//      dwOffset = 0xc;
//      u32Data = 0x00100040;
//      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      is = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      if(is == 0) {
//**         if(iwrite !=1 ) printf(" use 3dw \n");
       u32Data = dma_tr2+dma_3dw_rec;
      }
      else {
       u32Data = dma_tr2+dma_4dw_rec;
//**        if(iwrite !=1 ) printf(" use 4dw \n");
      }
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xc;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
//          if(iprint == 1) printf(" DMA complete %d \n", i);
          printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }



 static int pcie_rec_16b(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
//    printf(" istart = %d\n", istart);
//   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     printf(" nword = %d \n",nword);
/*
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }
*/
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*2;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%2 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }


static int pcie_send_6_1(WDC_DEVICE_HANDLE hDev2, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =1;
    if(iprint ==1) printf(" enter pcie_send_6_1 \n");
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && (iprint == 1)) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100000;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) &&( iprint == 1)) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }


 static int pcie_rec_6_1(WDC_DEVICE_HANDLE hDev2, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
 //   printf(" istart = %d\n", istart);
 //   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
 //    dwAddrSpace =2;
 //    u32Data = 0xf0000008;
 //    dwOffset = 0x28;
 //    WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*2;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read hDev2 = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%4 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev2,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read hDev2 = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }


 static int trigger_sort(int *sum1, int *sum2, int *add1, int *add2, int *out_sum, int *out_add)
 {
     static int sum[8], add[8], ia, ib, ic, gt[8][8], s[8];
     static int k0,k1,k2,k3,k4,k5,k6,k7;

     for (ia=0; ia< 4; ia++) {
      sum[ia] = (*sum1++)*2;
      add[ia] = *add1++;
     }
     for (ia=0; ia< 4; ia++) {
      sum[ia+4] = (*sum2++)*2;
      add[ia+4] = *add2++;
     }
     for (ia=0; ia<8; ia++) {
       out_sum[ia] =0;
       out_add[ia] = 0;
     }
     
//     for (ia=0; ia<7; ia++) {
//       printf(" ia= %d, sum= %x, add = %x\n", ia, sum[ia], add[ia]);
//     }
     k0 = sum[0];
     k1 = sum[1];
     k2 = sum[2];
     k3 = sum[3];
     k4 = sum[4];
     k5 = sum[5];
     k6 = sum[6];
     k7 = sum[7];
     if (((k7 == k6) || (k7 == k5) || (k7 == k4) || (k7 == k3) || (k7 == k2) || (k7 == k1) || (k7 == k0)) && (k7 !=0)) sum[7] = sum[7]+1;
     if (((k6 == k5) || (k6 == k4) || (k6 == k3) || (k6 == k2) || (k6 == k1) || (k6 == k0)) && (k6 !=0))  sum[6] = sum[6]+1;
     if (((k5 == k4) || (k5 == k3) || (k5 == k2) || (k5 == k1) || (k5 == k0)) && (k5 !=0))  sum[5] = sum[5]+1;
     if (((k4 == k3) || (k4 == k2) || (k4 == k1) || (k4 == k0)) && (k4 !=0))  sum[4] = sum[4]+1;
     if (((k3 == k2) || (k3 == k1) || (k3 == k0)) && (k3 !=0))  sum[3] = sum[3]+1;
     if (((k2 == k1) || (k2 == k0)) && (k2 !=0))  sum[2] = sum[2]+1;
     if ((k1 == k0) && (k1 !=0))  sum[1] = sum[1]+1;

     for (ia=0; ia<8; ia++) {
      for (ib=0; ib<8; ib++) {
//       if(ia >= ib) ic= ia-ib;
//       else ic=ib-ia;
       if(sum[ia] > sum[ib]) gt[ia][ib] = 1;
       else gt[ia][ib] = 0;
      }
      s[ia] =0;
      for (ib=0; ib<8; ib++) {
       s[ia] = s[ia]+ gt[ia][ib];
      }
     }
/*
     for (ia=0; ia<8; ia++) {
      for (ib=0; ib<8; ib++) {
       printf("%3d",gt[ia][ib]);
      }
      printf("\n");
     }

//     for (ia=0; ia<8; ia++) {
//       printf("%3d",s[ia]);
//     }
     printf("\n");
*/
     for (ia=0; ia<8; ia++) {
      for (ib=0; ib<8; ib++) {
       if(s[ib] == ia) {
         out_sum[ia] = sum[ib]>>1;
         out_add[ia] = add[ib];
       }
       if(s[ib] == ia) break;
      }
     }
//     for (ia=0; ia<8; ia++) {
//      printf(" ia= %d, out_sum = %x, out_add = %x \n", ia, out_sum[ia], out_add[ia]);
//     }
     return ia;
 }


 static int pcie_rec_6_2(WDC_DEVICE_HANDLE hDev2, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
 //   printf(" istart = %d\n", istart);
 //   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     dwAddrSpace =2;
//     u32Data = 0xf0000008;
//     dwOffset = tx_mode_reg;
//     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =cs_bar;
     u32Data = cs_init;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =cs_bar;
     u32Data = cs_start+nword*2;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =cs_bar;
      u64Data =0;
      dwOffset = t2_cs_reg;
      WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%4 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =t2_tr_bar;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev2,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }



    static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit)
{
#include "wdc_defs.h"
#define  mb_xmit_conf_add 0x2

    FILE *inpf;
    int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
    unsigned char charchannel,carray[4000];
    int nsend,nword,k;
    UINT32 buf_send[10000],send_array[10000];
    UINT32 *px;
    struct timespec tim,tim2;
    tim.tv_sec=0;
    tim.tv_nsec = 128000;
//
//    boot up xmit module 1st
//
      nsend=500;
      px = &buf_send;
      printf(" boot xmit module \n");
      inpf = fopen("/home/ub/xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      return i;
}


    static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem)
{
#include "wdc_defs.h"
#define  mb_feb_conf_add 0x2

    FILE *inpf;
    int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
    unsigned char charchannel,carray[4000];
    int nsend,nword,k;
    UINT32 buf_send[10000],send_array[10000];
    UINT32 *px;
    struct timespec tim,tim2;
    tim.tv_sec=0;
    tim.tv_nsec = 128000;
//
//    boot up xmit module 1st
//
      nsend=500;
      px = &buf_send;
//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=imod_fem;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
      return i;
}




/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
/* Read/write address menu options */
enum {
    MENU_RW_ADDR_SET_ADDR_SPACE = 1,
    MENU_RW_ADDR_SET_MODE,
    MENU_RW_ADDR_SET_TRANS_TYPE,
    MENU_RW_ADDR_READ,
    MENU_RW_ADDR_WRITE,
    MENU_RW_ADDR_EXIT = DIAG_EXIT_MENU,
};

#define ACTIVE_ADDR_SPACE_NEEDS_INIT 0xFF

/* Read/write memory or I/O space address menu */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    static DWORD dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
    static WDC_ADDR_MODE mode = WDC_MODE_32;
    static BOOL fBlock = FALSE;

    /* Initialize active address space */
    if (ACTIVE_ADDR_SPACE_NEEDS_INIT == dwAddrSpace)
    {
        DWORD dwNumAddrSpaces = JSEB2_GetNumAddrSpaces(hDev);
        
        /* Find the first active address space */
        for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
        {
            if (WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
                break;
        }
        
        /* Sanity check */
        if (dwAddrSpace == dwNumAddrSpaces)
        {
            JSEB2_ERR("MenuReadWriteAddr: Error - no active address spaces found\n");
            dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
            return;
        }
    }

    do
    {
        printf("\n");
        printf("Read/write the device's memory and IO ranges\n");
        printf("---------------------------------------------\n");
        printf("%d. Change active address space for read/write "
            "(currently: BAR %ld)\n", MENU_RW_ADDR_SET_ADDR_SPACE, dwAddrSpace);
        printf("%d. Change active read/write mode (currently: %s)\n",
            MENU_RW_ADDR_SET_MODE,
            (WDC_MODE_8 == mode) ? "8 bit" : (WDC_MODE_16 == mode) ? "16 bit" :
            (WDC_MODE_32 == mode) ? "32 bit" : "64 bit");
        printf("%d. Toggle active transfer type (currently: %s)\n",
            MENU_RW_ADDR_SET_TRANS_TYPE,
            (fBlock ? "block transfers" : "non-block transfers"));
        printf("%d. Read from active address space\n", MENU_RW_ADDR_READ);
        printf("%d. Write to active address space\n", MENU_RW_ADDR_WRITE);
        printf("%d. Exit menu\n", MENU_RW_ADDR_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }
        
        switch (option)
        {
        case MENU_RW_ADDR_EXIT: /* Exit menu */
            break;
        case MENU_RW_ADDR_SET_ADDR_SPACE: /* Set active address space for read/write address requests */
        {
            SetAddrSpace(hDev, &dwAddrSpace);
            break;
        }
        case MENU_RW_ADDR_SET_MODE: /* Set active mode for read/write address requests */
            WDC_DIAG_SetMode(&mode);
            break;
        case MENU_RW_ADDR_SET_TRANS_TYPE: /* Toggle active transfer type */
            fBlock = !fBlock;
            break;
        case MENU_RW_ADDR_READ:  /* Read from a memory or I/O address */
        case MENU_RW_ADDR_WRITE: /* Write to a memory or I/O address */
        {
            WDC_DIRECTION direction =
                (MENU_RW_ADDR_READ == option) ? WDC_READ : WDC_WRITE;

            if (fBlock)
                WDC_DIAG_ReadWriteBlock(hDev, direction, dwAddrSpace);
            else
                WDC_DIAG_ReadWriteAddr(hDev, direction, dwAddrSpace, mode);
            
            break;
        }
        }
    } while (MENU_RW_ADDR_EXIT != option);
}

static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace)
{
    DWORD dwAddrSpace;
    DWORD dwNumAddrSpaces = JSEB2_GetNumAddrSpaces(hDev);
    JSEB2_ADDR_SPACE_INFO addrSpaceInfo;
    
    printf("\n");
    printf("Select an active address space:\n");
    printf("-------------------------------\n");

    for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
    {
        BZERO(addrSpaceInfo);
        addrSpaceInfo.dwAddrSpace = dwAddrSpace;
        if (!JSEB2_GetAddrSpaceInfo(hDev, &addrSpaceInfo))
        {
            JSEB2_ERR("SetAddrSpace: Error - Failed to get address space information: %s",
                JSEB2_GetLastErr());
            return;
        }

        printf("%ld. %-*s %-*s %s\n",
            dwAddrSpace + 1,
            MAX_NAME_DISPLAY, addrSpaceInfo.sName,
            MAX_TYPE - 1, addrSpaceInfo.sType,
            addrSpaceInfo.sDesc);
    }
    printf("\n");

    if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwAddrSpace,
        "Enter option", FALSE, 1, dwNumAddrSpaces))
    {
         return;
    }

    dwAddrSpace--;
    if (!WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
    {
        printf("You have selected an inactive address space\n");
        return;
    }
            
    *pdwAddrSpace = dwAddrSpace;
}

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
/* Read/write the configuration space menu options */
enum {
    MENU_RW_CFG_SPACE_READ_OFFSET = 1,
    MENU_RW_CFG_SPACE_WRITE_OFFSET,
    MENU_RW_CFG_SPACE_READ_ALL_REGS,
    MENU_RW_CFG_SPACE_READ_REG,
    MENU_RW_CFG_SPACE_WRITE_REG,
    MENU_RW_CFG_SPACE_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write configuration space menu */
/* static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev) */
/* { */
/*     DWORD option; */
  
/*     do { */
/*         /1* Display pre-defined registers' information *1/ */
/*         if (JSEB2_CFG_REGS_NUM) */
/*         { */
/*             printf("\n"); */
/*             printf("Configuration registers:\n"); */
/*             printf("------------------------\n"); */
/*             WDC_DIAG_RegsInfoPrint(gpJSEB2_CfgRegs, JSEB2_CFG_REGS_NUM, */
/*                 WDC_DIAG_REG_PRINT_ALL & ~WDC_DIAG_REG_PRINT_ADDR_SPACE); */
/*         } */

/*         printf("\n"); */
/*         printf("Read/write the device's configuration space\n"); */
/*         printf("--------------------------------------------\n"); */
/*         printf("%d. Read from an offset\n", MENU_RW_CFG_SPACE_READ_OFFSET); */
/*         printf("%d. Write to an offset\n", MENU_RW_CFG_SPACE_WRITE_OFFSET); */
/*         if (JSEB2_CFG_REGS_NUM) */
/*         { */
/*             printf("%d. Read all configuration registers defined for the device (see list above)\n", */
/*                 MENU_RW_CFG_SPACE_READ_ALL_REGS); */
/*             printf("%d. Read from a named register\n", MENU_RW_CFG_SPACE_READ_REG); */
/*             printf("%d. Write to a named register\n", MENU_RW_CFG_SPACE_WRITE_REG); */
/*         } */
/*         printf("%d. Exit menu\n", MENU_RW_CFG_SPACE_EXIT); */
/*         printf("\n"); */

/*         if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option, */
/*             JSEB2_CFG_REGS_NUM ? MENU_RW_CFG_SPACE_WRITE_REG : */
/*             MENU_RW_CFG_SPACE_WRITE_OFFSET)) */
/*         { */
/*             continue; */
/*         } */

/*         switch (option) */
/*         { */
/*         case MENU_RW_CFG_SPACE_EXIT: /1* Exit menu *1/ */
/*             break; */
/*         case MENU_RW_CFG_SPACE_READ_OFFSET: /1* Read from a configuration space offset *1/ */
/*             WDC_DIAG_ReadWriteBlock(hDev, WDC_READ, WDC_AD_CFG_SPACE); */
/*             break; */
/*         case MENU_RW_CFG_SPACE_WRITE_OFFSET: /1* Write to a configuration space offset *1/ */
/*             WDC_DIAG_ReadWriteBlock(hDev, WDC_WRITE, WDC_AD_CFG_SPACE); */
/*             break; */
/*         case MENU_RW_CFG_SPACE_READ_ALL_REGS: */
/*             WDC_DIAG_ReadRegsAll(hDev, gpJSEB2_CfgRegs, JSEB2_CFG_REGS_NUM, TRUE); */
/*             break; */
/*         case MENU_RW_CFG_SPACE_READ_REG:  /1* Read from a configuration register *1/ */
/*             WDC_DIAG_ReadWriteReg(hDev, gpJSEB2_CfgRegs, JSEB2_CFG_REGS_NUM, WDC_READ, TRUE); */
/*             break; */
/*         case MENU_RW_CFG_SPACE_WRITE_REG: /1* Write to a configuration register *1/ */
/*             WDC_DIAG_ReadWriteReg(hDev, gpJSEB2_CfgRegs, JSEB2_CFG_REGS_NUM, WDC_WRITE, TRUE); */
/*             break; */
/*         } */
/*     } while (MENU_RW_CFG_SPACE_EXIT != option); */
/* } */

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
/* Read/write the run-time registers menu options */
enum {
    MENU_RW_REGS_READ_ALL = 1,
    MENU_RW_REGS_READ_REG,
    MENU_RW_REGS_WRITE_REG,
    MENU_RW_REGS_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write run-time registers menu */
/* static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev) */
/* { */
/*     DWORD option; */
    
/*     if (!JSEB2_REGS_NUM) */
/*     { */
/*         printf("There are currently no pre-defined run-time registers\n"); */
/*         return; */
/*     } */
  
/*     do { */
/*         /1* Display pre-defined registers' information *1/ */
/*         printf("\n"); */
/*         printf("JSEB2 run-time registers:\n"); */
/*         printf("--------------------------\n"); */   
/*         WDC_DIAG_RegsInfoPrint(gpJSEB2_Regs, JSEB2_REGS_NUM, WDC_DIAG_REG_PRINT_ALL); */

/*         printf("\n"); */
/*         printf("Read/write the JSEB2 run-time registers\n"); */
/*         printf("-----------------------------------------\n"); */
/*         printf("%d. Read all run-time registers defined for the device (see list above)\n", */
/*             MENU_RW_REGS_READ_ALL); */
/*         printf("%d. Read from a specific register\n", MENU_RW_REGS_READ_REG); */
/*         printf("%d. Write to a specific register\n", MENU_RW_REGS_WRITE_REG); */
/*         printf("%d. Exit menu\n", MENU_RW_REGS_EXIT); */
/*         printf("\n"); */

/*         if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option, */
/*             MENU_RW_REGS_WRITE_REG)) */
/*         { */
/*             continue; */
/*         } */

/*         switch (option) */
/*         { */
/*         case MENU_RW_REGS_EXIT: /1* Exit menu *1/ */
/*             break; */
/*         case MENU_RW_REGS_READ_ALL: */
/*             WDC_DIAG_ReadRegsAll(hDev, gpJSEB2_Regs, JSEB2_REGS_NUM, FALSE); */
/*             break; */
/*         case MENU_RW_REGS_READ_REG:  /1* Read from a register *1/ */
/*             WDC_DIAG_ReadWriteReg(hDev, gpJSEB2_Regs, JSEB2_REGS_NUM, WDC_READ, FALSE); */
/*             break; */
/*         case MENU_RW_REGS_WRITE_REG: /1* Write to a register *1/ */
/*             WDC_DIAG_ReadWriteReg(hDev, gpJSEB2_Regs, JSEB2_REGS_NUM, WDC_WRITE, FALSE); */
/*             break; */
/*         } */
/*     } while (MENU_RW_REGS_EXIT != option); */
/* } */

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
/* Interrupts menu options */
enum {
    MENU_INT_ENABLE_DISABLE = 1,
    MENU_INT_EXIT = DIAG_EXIT_MENU,
};

/* Enable/Disable interrupts menu */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev)
{
    DWORD option, dwIntOptions;
    BOOL fIntEnable, fIsMsi;

    dwIntOptions = WDC_GET_INT_OPTIONS(hDev);
    fIsMsi = WDC_INT_IS_MSI(dwIntOptions);
    if (dwIntOptions & INTERRUPT_LEVEL_SENSITIVE)
    {
        /* TODO: You can remove this message after you have modified the
           implementation of JSEB2_IntEnable() in pcie_lib.c to 
           correctly acknowledge level-sensitive interrupts (see guidelines
           in JSEB2_IntEnable()) */
        printf("\n");
        printf("WARNING!!!\n");
        printf("----------\n");
        printf("Your hardware has level sensitive interrupts.\n");
        printf("Before enabling the interrupts, %s first modify the source "
           "code of JSEB2_IntEnable(), in the file pcie_lib.c, to "
           "correctly acknowledge\n%s interrupts when they occur (as dictated by "
           "the hardware's specifications)\n",
           fIsMsi ? "it's recommended that you" : "you must",
           fIsMsi ? "level sensitive" : "");    }

    do
    {
        fIntEnable = !JSEB2_IntIsEnabled(hDev);

        printf("\n");
        printf("Interrupts\n");
        printf("-----------\n");
        printf("%d. %s interrupts\n", MENU_INT_ENABLE_DISABLE,
            fIntEnable ? "Enable" : "Disable");
        printf("%d. Exit menu\n", MENU_INT_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }

        switch (option)
        {
        case MENU_INT_EXIT: /* Exit menu */
            break;
        case MENU_INT_ENABLE_DISABLE: /* Enable/disable interrupts */
            if (fIntEnable)
            {
                DWORD dwStatus = JSEB2_IntEnable(hDev, DiagIntHandler);

                if (WD_STATUS_SUCCESS == dwStatus)
                    printf("Interrupts enabled\n");
                else
                {
                    JSEB2_ERR("Failed enabling interrupts. Error 0x%lx - %s\n",
                       dwStatus, Stat2Str(dwStatus));
                }
            }
            else
            {
                if (WD_STATUS_SUCCESS == JSEB2_IntDisable(hDev))
                    printf("Interrupts disabled\n");
                else
                    JSEB2_ERR("Failed disabling interrupts: %s", JSEB2_GetLastErr());
            }
            break;
        }
    } while (MENU_INT_EXIT != option);
}

/* Diagnostics interrupt handler routine */
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, JSEB2_INT_RESULT *pIntResult)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics interrupt handler routine */

    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
        WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
        printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
}

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
/* Events menu options */
enum {
    MENU_EVENTS_REGISTER_UNREGISTER = 1,
    MENU_EVENTS_EXIT = DIAG_EXIT_MENU,
};

/* Register/unregister Plug-and-play and power management events */
static void MenuEvents(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    BOOL fRegister;

    do
    {
        fRegister = !JSEB2_EventIsRegistered(hDev);
        
        printf("\n");
        printf("Plug-and-play and power management events\n");
        printf("------------------------------------------\n");
        printf("%d. %s events\n", MENU_EVENTS_REGISTER_UNREGISTER,
            fRegister ? "Register" : "Unregister");
        printf("%d. Exit menu\n", MENU_EVENTS_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_EVENTS_REGISTER_UNREGISTER))
        {
            continue;
        }

        switch (option)
        {
        case MENU_EVENTS_EXIT: /* Exit menu */
            break;
        case MENU_EVENTS_REGISTER_UNREGISTER: /* Register/unregister events */
            if (fRegister)
            {
                if (WD_STATUS_SUCCESS == JSEB2_EventRegister(hDev, DiagEventHandler))
                    printf("Events registered\n");
                else
                    JSEB2_ERR("Failed to register events. Last error:\n%s", JSEB2_GetLastErr());
            }
            else
            {
                if (WD_STATUS_SUCCESS == JSEB2_EventUnregister(hDev))
                    printf("Events unregistered\n");
                else
                    JSEB2_ERR("Failed to unregister events. Last Error:\n%s", JSEB2_GetLastErr());
            }
            break;
        }
    } while (MENU_EVENTS_EXIT != option);
}

/* Plug-and-play and power management events handler routine */
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics events handler routine */

    printf("\nReceived event notification (device handle 0x%p): ", hDev);
    switch (dwAction)
    {
    case WD_INSERT:
        printf("WD_INSERT\n");
        break;
    case WD_REMOVE:
        printf("WD_REMOVE\n");
        break;
    case WD_POWER_CHANGED_D0:
        printf("WD_POWER_CHANGED_D0\n");
        break;
    case WD_POWER_CHANGED_D1:
        printf("WD_POWER_CHANGED_D1\n");
        break;
    case WD_POWER_CHANGED_D2:
        printf("WD_POWER_CHANGED_D2\n");
        break;
    case WD_POWER_CHANGED_D3:
        printf("WD_POWER_CHANGED_D3\n");
        break;
    case WD_POWER_SYSTEM_WORKING:
        printf("WD_POWER_SYSTEM_WORKING\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING1:
        printf("WD_POWER_SYSTEM_SLEEPING1\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING2:
        printf("WD_POWER_SYSTEM_SLEEPING2\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING3:
        printf("WD_POWER_SYSTEM_SLEEPING3\n");
        break;
    case WD_POWER_SYSTEM_HIBERNATE:
        printf("WD_POWER_SYSTEM_HIBERNATE\n");
        break;
    case WD_POWER_SYSTEM_SHUTDOWN:
        printf("WD_POWER_SYSTEM_SHUTDOWN\n");
        break;
    default:
        printf("0x%lx\n", dwAction);
        break;
    }
}

